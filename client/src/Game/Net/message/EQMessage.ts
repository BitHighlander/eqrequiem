// @generated by protobuf-ts 2.9.6
// @generated from protobuf file "EQMessage.proto" (package "eq", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message eq.JWTLogin
 */
export interface JWTLogin {
    /**
     * @generated from protobuf field: string token = 1;
     */
    token: string;
}
/**
 * @generated from protobuf message eq.JWTResponse
 */
export interface JWTResponse {
    /**
     * @generated from protobuf field: int32 status = 1;
     */
    status: number;
}
/**
 * @generated from protobuf message eq.LoginReply
 */
export interface LoginReply {
    /**
     * @generated from protobuf field: string key = 1;
     */
    key: string;
    /**
     * @generated from protobuf field: int32 error_str_id = 2;
     */
    errorStrId: number;
    /**
     * @generated from protobuf field: int32 failed_attempts = 3;
     */
    failedAttempts: number;
    /**
     * @generated from protobuf field: int32 lsid = 4;
     */
    lsid: number;
    /**
     * @generated from protobuf field: bool success = 5;
     */
    success: boolean;
    /**
     * @generated from protobuf field: bool show_player_count = 6;
     */
    showPlayerCount: boolean;
}
/**
 * @generated from protobuf message eq.LoginRequest
 */
export interface LoginRequest {
    /**
     * @generated from protobuf field: int32 sequence = 1;
     */
    sequence: number;
}
/**
 * @generated from protobuf message eq.WorldServer
 */
export interface WorldServer {
    /**
     * @generated from protobuf field: string ip = 1;
     */
    ip: string;
    /**
     * @generated from protobuf field: int32 server_type = 2;
     */
    serverType: number;
    /**
     * @generated from protobuf field: int32 server_id = 3;
     */
    serverId: number;
    /**
     * @generated from protobuf field: string long_name = 4;
     */
    longName: string;
    /**
     * @generated from protobuf field: string country_code = 5;
     */
    countryCode: string;
    /**
     * @generated from protobuf field: string language_code = 6;
     */
    languageCode: string;
    /**
     * @generated from protobuf field: int32 status = 7;
     */
    status: number;
    /**
     * @generated from protobuf field: int32 players_online = 8;
     */
    playersOnline: number;
}
/**
 * @generated from protobuf message eq.LoginServerResponse
 */
export interface LoginServerResponse {
    /**
     * @generated from protobuf field: int32 server_count = 1;
     */
    serverCount: number;
    /**
     * @generated from protobuf field: repeated eq.WorldServer servers = 2;
     */
    servers: WorldServer[];
}
/**
 * @generated from protobuf message eq.PlayEverquest
 */
export interface PlayEverquest {
    /**
     * @generated from protobuf field: int32 server_id = 1;
     */
    serverId: number;
}
/**
 * @generated from protobuf message eq.PlayEverquestResponse
 */
export interface PlayEverquestResponse {
    /**
     * @generated from protobuf field: int32 server_id = 1;
     */
    serverId: number;
    /**
     * @generated from protobuf field: bool success = 2;
     */
    success: boolean;
    /**
     * @generated from protobuf field: int32 error_str_id = 3;
     */
    errorStrId: number;
}
/**
 * World
 *
 * @generated from protobuf message eq.WebInitiateConnection
 */
export interface WebInitiateConnection {
    /**
     * @generated from protobuf field: bool login = 1;
     */
    login: boolean;
}
/**
 * @generated from protobuf message eq.LoginInfo
 */
export interface LoginInfo {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string password = 2;
     */
    password: string;
    /**
     * @generated from protobuf field: int32 zoning = 3;
     */
    zoning: number;
}
/**
 * @generated from protobuf message eq.Tint
 */
export interface Tint {
    /**
     * @generated from protobuf field: int32 blue = 1;
     */
    blue: number;
    /**
     * @generated from protobuf field: int32 green = 2;
     */
    green: number;
    /**
     * @generated from protobuf field: int32 red = 3;
     */
    red: number;
    /**
     * @generated from protobuf field: int32 use_tint = 4;
     */
    useTint: number;
}
/**
 * @generated from protobuf message eq.CharSelectEquip
 */
export interface CharSelectEquip {
    /**
     * @generated from protobuf field: int32 material = 1;
     */
    material: number;
    /**
     * @generated from protobuf field: eq.Tint color = 2;
     */
    color?: Tint;
}
/**
 * @generated from protobuf message eq.CharacterSelectEntry
 */
export interface CharacterSelectEntry {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: int32 char_class = 2;
     */
    charClass: number;
    /**
     * @generated from protobuf field: int32 race = 3;
     */
    race: number;
    /**
     * @generated from protobuf field: int32 level = 4;
     */
    level: number;
    /**
     * @generated from protobuf field: int32 zone = 5;
     */
    zone: number;
    /**
     * @generated from protobuf field: int32 instance = 6;
     */
    instance: number;
    /**
     * @generated from protobuf field: int32 gender = 7;
     */
    gender: number;
    /**
     * @generated from protobuf field: int32 face = 8;
     */
    face: number;
    /**
     * @generated from protobuf field: repeated eq.CharSelectEquip equip = 9;
     */
    equip: CharSelectEquip[];
    /**
     * @generated from protobuf field: int32 deity = 10;
     */
    deity: number;
    /**
     * @generated from protobuf field: int32 primary_id_file = 11;
     */
    primaryIdFile: number;
    /**
     * @generated from protobuf field: int32 secondary_id_file = 12;
     */
    secondaryIdFile: number;
    /**
     * @generated from protobuf field: int32 go_home = 13;
     */
    goHome: number;
    /**
     * @generated from protobuf field: int32 enabled = 14;
     */
    enabled: number;
    /**
     * @generated from protobuf field: int32 last_login = 15;
     */
    lastLogin: number;
}
/**
 * @generated from protobuf message eq.CharacterSelect
 */
export interface CharacterSelect {
    /**
     * @generated from protobuf field: int32 character_count = 1;
     */
    characterCount: number;
    /**
     * @generated from protobuf field: repeated eq.CharacterSelectEntry characters = 2;
     */
    characters: CharacterSelectEntry[];
}
/**
 * @generated from protobuf message eq.EnterWorld
 */
export interface EnterWorld {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: int32 tutorial = 2;
     */
    tutorial: number;
    /**
     * @generated from protobuf field: int32 return_home = 3;
     */
    returnHome: number;
}
/**
 * @generated from protobuf message eq.InventorySlot
 */
export interface InventorySlot {
    /**
     * @generated from protobuf field: int32 type = 1;
     */
    type: number;
    /**
     * @generated from protobuf field: int32 slot = 2;
     */
    slot: number;
    /**
     * @generated from protobuf field: int32 sub_index = 3;
     */
    subIndex: number;
}
/**
 * @generated from protobuf message eq.TypelessInventorySlot
 */
export interface TypelessInventorySlot {
    /**
     * @generated from protobuf field: int32 slot = 1;
     */
    slot: number;
    /**
     * @generated from protobuf field: int32 sub_index = 2;
     */
    subIndex: number;
}
/**
 * @generated from protobuf message eq.NameApproval
 */
export interface NameApproval {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: int32 race = 2;
     */
    race: number;
    /**
     * @generated from protobuf field: int32 char_class = 3;
     */
    charClass: number;
    /**
     * @generated from protobuf field: int32 deity = 4;
     */
    deity: number;
}
/**
 * @generated from protobuf message eq.EntityId
 */
export interface EntityId {
    /**
     * @generated from protobuf field: int32 entity_id = 1;
     */
    entityId: number;
}
/**
 * @generated from protobuf message eq.Duel
 */
export interface Duel {
    /**
     * @generated from protobuf field: int32 duel_initiator = 1;
     */
    duelInitiator: number;
    /**
     * @generated from protobuf field: int32 duel_target = 2;
     */
    duelTarget: number;
}
/**
 * @generated from protobuf message eq.DuelResponse
 */
export interface DuelResponse {
    /**
     * @generated from protobuf field: int32 target_id = 1;
     */
    targetId: number;
    /**
     * @generated from protobuf field: int32 entity_id = 2;
     */
    entityId: number;
}
/**
 * @generated from protobuf message eq.AdventureInfo
 */
export interface AdventureInfo {
    /**
     * @generated from protobuf field: int32 quest_id = 1;
     */
    questId: number;
    /**
     * @generated from protobuf field: int32 npc_id = 2;
     */
    npcId: number;
    /**
     * @generated from protobuf field: bool in_use = 3;
     */
    inUse: boolean;
    /**
     * @generated from protobuf field: int32 status = 4;
     */
    status: number;
    /**
     * @generated from protobuf field: bool show_compass = 5;
     */
    showCompass: boolean;
    /**
     * @generated from protobuf field: int32 objetive = 6;
     */
    objetive: number;
    /**
     * @generated from protobuf field: int32 objetive_value = 7;
     */
    objetiveValue: number;
    /**
     * @generated from protobuf field: string text = 8;
     */
    text: string;
    /**
     * @generated from protobuf field: int32 type = 9;
     */
    type: number;
    /**
     * @generated from protobuf field: int32 minutes = 10;
     */
    minutes: number;
    /**
     * @generated from protobuf field: int32 points = 11;
     */
    points: number;
    /**
     * @generated from protobuf field: float x = 12;
     */
    x: number;
    /**
     * @generated from protobuf field: float y = 13;
     */
    y: number;
    /**
     * @generated from protobuf field: int32 zoneid = 14;
     */
    zoneid: number;
    /**
     * @generated from protobuf field: int32 zonedungeonid = 15;
     */
    zonedungeonid: number;
}
/**
 * @generated from protobuf message eq.TextureProfile
 */
export interface TextureProfile {
    /**
     * @generated from protobuf field: int32 head = 1;
     */
    head: number;
    /**
     * @generated from protobuf field: int32 chest = 2;
     */
    chest: number;
    /**
     * @generated from protobuf field: int32 arms = 3;
     */
    arms: number;
    /**
     * @generated from protobuf field: int32 wrist = 4;
     */
    wrist: number;
    /**
     * @generated from protobuf field: int32 hands = 5;
     */
    hands: number;
    /**
     * @generated from protobuf field: int32 legs = 6;
     */
    legs: number;
    /**
     * @generated from protobuf field: int32 feet = 7;
     */
    feet: number;
    /**
     * @generated from protobuf field: int32 primary = 8;
     */
    primary: number;
    /**
     * @generated from protobuf field: int32 secondary = 9;
     */
    secondary: number;
}
/**
 * @generated from protobuf message eq.TintProfile
 */
export interface TintProfile {
    /**
     * @generated from protobuf field: int32 head = 1;
     */
    head: number;
    /**
     * @generated from protobuf field: int32 chest = 2;
     */
    chest: number;
    /**
     * @generated from protobuf field: int32 arms = 3;
     */
    arms: number;
    /**
     * @generated from protobuf field: int32 wrist = 4;
     */
    wrist: number;
    /**
     * @generated from protobuf field: int32 hands = 5;
     */
    hands: number;
    /**
     * @generated from protobuf field: int32 legs = 6;
     */
    legs: number;
    /**
     * @generated from protobuf field: int32 feet = 7;
     */
    feet: number;
    /**
     * @generated from protobuf field: int32 primary = 8;
     */
    primary: number;
    /**
     * @generated from protobuf field: int32 secondary = 9;
     */
    secondary: number;
}
/**
 * @generated from protobuf message eq.Spawns
 */
export interface Spawns {
    /**
     * @generated from protobuf field: int32 spawn_count = 1;
     */
    spawnCount: number;
    /**
     * @generated from protobuf field: eq.Spawn spawns = 2;
     */
    spawns?: Spawn;
}
/**
 * @generated from protobuf message eq.Spawn
 */
export interface Spawn {
    /**
     * @generated from protobuf field: int32 gm = 1;
     */
    gm: number;
    /**
     * @generated from protobuf field: int32 aaitle = 2;
     */
    aaitle: number;
    /**
     * @generated from protobuf field: int32 anon = 3;
     */
    anon: number;
    /**
     * @generated from protobuf field: int32 face = 4;
     */
    face: number;
    /**
     * @generated from protobuf field: string name = 5;
     */
    name: string;
    /**
     * @generated from protobuf field: int32 deity = 6;
     */
    deity: number;
    /**
     * @generated from protobuf field: float size = 7;
     */
    size: number;
    /**
     * @generated from protobuf field: int32 npc = 8;
     */
    npc: number;
    /**
     * @generated from protobuf field: int32 invis = 9;
     */
    invis: number;
    /**
     * @generated from protobuf field: int32 haircolor = 10;
     */
    haircolor: number;
    /**
     * @generated from protobuf field: int32 cur_hp = 11;
     */
    curHp: number;
    /**
     * @generated from protobuf field: int32 max_hp = 12;
     */
    maxHp: number;
    /**
     * @generated from protobuf field: int32 findable = 13;
     */
    findable: number;
    /**
     * @generated from protobuf field: int32 delta_heading = 14;
     */
    deltaHeading: number;
    /**
     * @generated from protobuf field: int32 x = 15;
     */
    x: number;
    /**
     * @generated from protobuf field: int32 y = 16;
     */
    y: number;
    /**
     * @generated from protobuf field: int32 animation = 17;
     */
    animation: number;
    /**
     * @generated from protobuf field: int32 z = 18;
     */
    z: number;
    /**
     * @generated from protobuf field: int32 delta_y = 19;
     */
    deltaY: number;
    /**
     * @generated from protobuf field: int32 delta_x = 20;
     */
    deltaX: number;
    /**
     * @generated from protobuf field: int32 heading = 21;
     */
    heading: number;
    /**
     * @generated from protobuf field: int32 delta_z = 22;
     */
    deltaZ: number;
    /**
     * @generated from protobuf field: int32 eyecolor1 = 23;
     */
    eyecolor1: number;
    /**
     * @generated from protobuf field: int32 showhelm = 24;
     */
    showhelm: number;
    /**
     * @generated from protobuf field: int32 is_npc = 25;
     */
    isNpc: number;
    /**
     * @generated from protobuf field: int32 hairstyle = 26;
     */
    hairstyle: number;
    /**
     * @generated from protobuf field: int32 beardcolor = 27;
     */
    beardcolor: number;
    /**
     * @generated from protobuf field: int32 level = 28;
     */
    level: number;
    /**
     * @generated from protobuf field: int32 player_state = 29;
     */
    playerState: number;
    /**
     * @generated from protobuf field: int32 beard = 30;
     */
    beard: number;
    /**
     * @generated from protobuf field: string suffix = 31;
     */
    suffix: string;
    /**
     * @generated from protobuf field: int32 pet_owner_id = 32;
     */
    petOwnerId: number;
    /**
     * @generated from protobuf field: int32 guildrank = 33;
     */
    guildrank: number;
    /**
     * @generated from protobuf field: eq.TextureProfile equipment = 34;
     */
    equipment?: TextureProfile;
    /**
     * @generated from protobuf field: float runspeed = 35;
     */
    runspeed: number;
    /**
     * @generated from protobuf field: int32 afk = 36;
     */
    afk: number;
    /**
     * @generated from protobuf field: int32 guild_id = 37;
     */
    guildId: number;
    /**
     * @generated from protobuf field: string title = 38;
     */
    title: string;
    /**
     * @generated from protobuf field: int32 helm = 39;
     */
    helm: number;
    /**
     * @generated from protobuf field: int32 race = 40;
     */
    race: number;
    /**
     * @generated from protobuf field: string last_name = 41;
     */
    lastName: string;
    /**
     * @generated from protobuf field: float walkspeed = 42;
     */
    walkspeed: number;
    /**
     * @generated from protobuf field: int32 is_pet = 43;
     */
    isPet: number;
    /**
     * @generated from protobuf field: int32 light = 44;
     */
    light: number;
    /**
     * @generated from protobuf field: int32 char_class = 45;
     */
    charClass: number;
    /**
     * @generated from protobuf field: int32 eyecolor2 = 46;
     */
    eyecolor2: number;
    /**
     * @generated from protobuf field: int32 flymode = 47;
     */
    flymode: number;
    /**
     * @generated from protobuf field: int32 gender = 48;
     */
    gender: number;
    /**
     * @generated from protobuf field: int32 bodytype = 49;
     */
    bodytype: number;
    /**
     * @generated from protobuf field: int32 equip_chest = 50;
     */
    equipChest: number;
    /**
     * @generated from protobuf field: int32 mount_color = 51;
     */
    mountColor: number;
    /**
     * @generated from protobuf field: int32 spawn_id = 52;
     */
    spawnId: number;
    /**
     * @generated from protobuf field: float bounding_radius = 53;
     */
    boundingRadius: number;
    /**
     * @generated from protobuf field: int32 equipment_tint = 54;
     */
    equipmentTint: number;
    /**
     * @generated from protobuf field: int32 lfg = 55;
     */
    lfg: number;
}
/**
 * @generated from protobuf message eq.NewSpawn
 */
export interface NewSpawn {
    /**
     * @generated from protobuf field: eq.Spawn spawn = 1;
     */
    spawn?: Spawn;
}
/**
 * @generated from protobuf message eq.ClientZoneEntry
 */
export interface ClientZoneEntry {
    /**
     * @generated from protobuf field: string char_name = 1;
     */
    charName: string;
}
/**
 * @generated from protobuf message eq.ServerZoneEntry
 */
export interface ServerZoneEntry {
    /**
     * @generated from protobuf field: eq.NewSpawn player = 1;
     */
    player?: NewSpawn;
}
/**
 * @generated from protobuf message eq.NewZone
 */
export interface NewZone {
    /**
     * @generated from protobuf field: string char_name = 1;
     */
    charName: string;
    /**
     * @generated from protobuf field: string zone_short_name = 2;
     */
    zoneShortName: string;
    /**
     * @generated from protobuf field: string zone_long_name = 3;
     */
    zoneLongName: string;
    /**
     * @generated from protobuf field: int32 ztype = 4;
     */
    ztype: number;
    /**
     * @generated from protobuf field: repeated int32 fog_red = 5;
     */
    fogRed: number[];
    /**
     * @generated from protobuf field: repeated int32 fog_green = 6;
     */
    fogGreen: number[];
    /**
     * @generated from protobuf field: repeated int32 fog_blue = 7;
     */
    fogBlue: number[];
    /**
     * @generated from protobuf field: repeated float fog_minclip = 8;
     */
    fogMinclip: number[];
    /**
     * @generated from protobuf field: repeated float fog_maxclip = 9;
     */
    fogMaxclip: number[];
    /**
     * @generated from protobuf field: float gravity = 10;
     */
    gravity: number;
    /**
     * @generated from protobuf field: int32 time_type = 11;
     */
    timeType: number;
    /**
     * @generated from protobuf field: repeated int32 rain_chance = 12;
     */
    rainChance: number[];
    /**
     * @generated from protobuf field: repeated int32 rain_duration = 13;
     */
    rainDuration: number[];
    /**
     * @generated from protobuf field: repeated int32 snow_chance = 14;
     */
    snowChance: number[];
    /**
     * @generated from protobuf field: repeated int32 snow_duration = 15;
     */
    snowDuration: number[];
    /**
     * @generated from protobuf field: int32 sky = 16;
     */
    sky: number;
    /**
     * @generated from protobuf field: float zone_exp_multiplier = 17;
     */
    zoneExpMultiplier: number;
    /**
     * @generated from protobuf field: float safe_y = 18;
     */
    safeY: number;
    /**
     * @generated from protobuf field: float safe_x = 19;
     */
    safeX: number;
    /**
     * @generated from protobuf field: float safe_z = 20;
     */
    safeZ: number;
    /**
     * @generated from protobuf field: float max_z = 21;
     */
    maxZ: number;
    /**
     * @generated from protobuf field: float underworld = 22;
     */
    underworld: number;
    /**
     * @generated from protobuf field: float minclip = 23;
     */
    minclip: number;
    /**
     * @generated from protobuf field: float maxclip = 24;
     */
    maxclip: number;
    /**
     * @generated from protobuf field: string zone_short_name2 = 25;
     */
    zoneShortName2: string;
    /**
     * @generated from protobuf field: int32 zone_id = 26;
     */
    zoneId: number;
    /**
     * @generated from protobuf field: int32 zone_instance = 27;
     */
    zoneInstance: number;
}
/**
 * @generated from protobuf message eq.MemorizeSpell
 */
export interface MemorizeSpell {
    /**
     * @generated from protobuf field: int32 slot = 1;
     */
    slot: number;
    /**
     * @generated from protobuf field: int32 spell_id = 2;
     */
    spellId: number;
    /**
     * @generated from protobuf field: int32 scribing = 3;
     */
    scribing: number;
    /**
     * @generated from protobuf field: int32 reduction = 4;
     */
    reduction: number;
}
/**
 * @generated from protobuf message eq.Charm
 */
export interface Charm {
    /**
     * @generated from protobuf field: int32 owner_id = 1;
     */
    ownerId: number;
    /**
     * @generated from protobuf field: int32 pet_id = 2;
     */
    petId: number;
    /**
     * @generated from protobuf field: int32 command = 3;
     */
    command: number;
}
/**
 * @generated from protobuf message eq.InterruptCast
 */
export interface InterruptCast {
    /**
     * @generated from protobuf field: int32 spawnid = 1;
     */
    spawnid: number;
    /**
     * @generated from protobuf field: int32 messageid = 2;
     */
    messageid: number;
    /**
     * @generated from protobuf field: string message = 3;
     */
    message: string;
}
/**
 * @generated from protobuf message eq.DeleteSpell
 */
export interface DeleteSpell {
    /**
     * @generated from protobuf field: int32 spell_slot = 1;
     */
    spellSlot: number;
    /**
     * @generated from protobuf field: int32 success = 2;
     */
    success: number;
}
/**
 * @generated from protobuf message eq.ManaChange
 */
export interface ManaChange {
    /**
     * @generated from protobuf field: int32 new_mana = 1;
     */
    newMana: number;
    /**
     * @generated from protobuf field: int32 stamina = 2;
     */
    stamina: number;
    /**
     * @generated from protobuf field: int32 spell_id = 3;
     */
    spellId: number;
    /**
     * @generated from protobuf field: int32 keepcasting = 4;
     */
    keepcasting: number;
    /**
     * @generated from protobuf field: repeated int32 padding = 5;
     */
    padding: number[];
}
/**
 * @generated from protobuf message eq.SwapSpell
 */
export interface SwapSpell {
    /**
     * @generated from protobuf field: int32 from_slot = 1;
     */
    fromSlot: number;
    /**
     * @generated from protobuf field: int32 to_slot = 2;
     */
    toSlot: number;
}
/**
 * @generated from protobuf message eq.BeginCast
 */
export interface BeginCast {
    /**
     * @generated from protobuf field: int32 caster_id = 1;
     */
    casterId: number;
    /**
     * @generated from protobuf field: int32 spell_id = 2;
     */
    spellId: number;
    /**
     * @generated from protobuf field: int32 cast_time = 3;
     */
    castTime: number;
}
/**
 * @generated from protobuf message eq.CastSpell
 */
export interface CastSpell {
    /**
     * @generated from protobuf field: int32 slot = 1;
     */
    slot: number;
    /**
     * @generated from protobuf field: int32 spell_id = 2;
     */
    spellId: number;
    /**
     * @generated from protobuf field: int32 inventoryslot = 3;
     */
    inventoryslot: number;
    /**
     * @generated from protobuf field: int32 target_id = 4;
     */
    targetId: number;
}
/**
 * @generated from protobuf message eq.SpawnAppearance
 */
export interface SpawnAppearance {
    /**
     * @generated from protobuf field: int32 spawn_id = 1;
     */
    spawnId: number;
    /**
     * @generated from protobuf field: int32 type = 2;
     */
    type: number;
    /**
     * @generated from protobuf field: int32 parameter = 3;
     */
    parameter: number;
}
/**
 * @generated from protobuf message eq.SpellBuff
 */
export interface SpellBuff {
    /**
     * @generated from protobuf field: int32 effect_type = 1;
     */
    effectType: number;
    /**
     * @generated from protobuf field: int32 level = 2;
     */
    level: number;
    /**
     * @generated from protobuf field: int32 bard_modifier = 3;
     */
    bardModifier: number;
    /**
     * @generated from protobuf field: int32 spellid = 4;
     */
    spellid: number;
    /**
     * @generated from protobuf field: int32 duration = 5;
     */
    duration: number;
    /**
     * @generated from protobuf field: int32 counters = 6;
     */
    counters: number;
    /**
     * @generated from protobuf field: int32 player_id = 7;
     */
    playerId: number;
}
/**
 * @generated from protobuf message eq.SpellBuffPacket
 */
export interface SpellBuffPacket {
    /**
     * @generated from protobuf field: int32 entityid = 1;
     */
    entityid: number;
    /**
     * @generated from protobuf field: eq.SpellBuff buff = 2;
     */
    buff?: SpellBuff;
    /**
     * @generated from protobuf field: int32 slotid = 3;
     */
    slotid: number;
    /**
     * @generated from protobuf field: int32 bufffade = 4;
     */
    bufffade: number;
}
/**
 * @generated from protobuf message eq.ItemNamePacket
 */
export interface ItemNamePacket {
    /**
     * @generated from protobuf field: int32 item_id = 1;
     */
    itemId: number;
    /**
     * @generated from protobuf field: int32 unkown = 2;
     */
    unkown: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
}
/**
 * @generated from protobuf message eq.ItemProperties
 */
export interface ItemProperties {
    /**
     * @generated from protobuf field: int32 charges = 1;
     */
    charges: number;
}
/**
 * @generated from protobuf message eq.GMTrainee
 */
export interface GMTrainee {
    /**
     * @generated from protobuf field: int32 npcid = 1;
     */
    npcid: number;
    /**
     * @generated from protobuf field: int32 playerid = 2;
     */
    playerid: number;
    /**
     * @generated from protobuf field: repeated int32 skills = 3;
     */
    skills: number[];
}
/**
 * @generated from protobuf message eq.GMTrainEnd
 */
export interface GMTrainEnd {
    /**
     * @generated from protobuf field: int32 npcid = 1;
     */
    npcid: number;
    /**
     * @generated from protobuf field: int32 playerid = 2;
     */
    playerid: number;
}
/**
 * @generated from protobuf message eq.GMSkillChange
 */
export interface GMSkillChange {
    /**
     * @generated from protobuf field: int32 npcid = 1;
     */
    npcid: number;
    /**
     * @generated from protobuf field: int32 skillbank = 2;
     */
    skillbank: number;
    /**
     * @generated from protobuf field: int32 skill_id = 3;
     */
    skillId: number;
}
/**
 * @generated from protobuf message eq.ConsentResponse
 */
export interface ConsentResponse {
    /**
     * @generated from protobuf field: string grantname = 1;
     */
    grantname: string;
    /**
     * @generated from protobuf field: string ownername = 2;
     */
    ownername: string;
    /**
     * @generated from protobuf field: int32 permission = 3;
     */
    permission: number;
    /**
     * @generated from protobuf field: string zonename = 4;
     */
    zonename: string;
}
/**
 * @generated from protobuf message eq.NameGeneration
 */
export interface NameGeneration {
    /**
     * @generated from protobuf field: int32 race = 1;
     */
    race: number;
    /**
     * @generated from protobuf field: int32 gender = 2;
     */
    gender: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
}
/**
 * @generated from protobuf message eq.NameApprove
 */
export interface NameApprove {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: int32 race = 2;
     */
    race: number;
    /**
     * @generated from protobuf field: int32 gender = 3;
     */
    gender: number;
}
/**
 * @generated from protobuf message eq.CharCreate
 */
export interface CharCreate {
    /**
     * @generated from protobuf field: int32 char_class = 1;
     */
    charClass: number;
    /**
     * @generated from protobuf field: int32 haircolor = 2;
     */
    haircolor: number;
    /**
     * @generated from protobuf field: int32 beardcolor = 3;
     */
    beardcolor: number;
    /**
     * @generated from protobuf field: int32 beard = 4;
     */
    beard: number;
    /**
     * @generated from protobuf field: int32 gender = 5;
     */
    gender: number;
    /**
     * @generated from protobuf field: int32 race = 6;
     */
    race: number;
    /**
     * @generated from protobuf field: int32 start_zone = 7;
     */
    startZone: number;
    /**
     * @generated from protobuf field: int32 hairstyle = 8;
     */
    hairstyle: number;
    /**
     * @generated from protobuf field: int32 deity = 9;
     */
    deity: number;
    /**
     * @generated from protobuf field: int32 str = 10;
     */
    str: number;
    /**
     * @generated from protobuf field: int32 sta = 11;
     */
    sta: number;
    /**
     * @generated from protobuf field: int32 agi = 12;
     */
    agi: number;
    /**
     * @generated from protobuf field: int32 dex = 13;
     */
    dex: number;
    /**
     * @generated from protobuf field: int32 wis = 14;
     */
    wis: number;
    /**
     * @generated from protobuf field: int32 intel = 15;
     */
    intel: number;
    /**
     * @generated from protobuf field: int32 cha = 16;
     */
    cha: number;
    /**
     * @generated from protobuf field: int32 face = 17;
     */
    face: number;
    /**
     * @generated from protobuf field: int32 eyecolor1 = 18;
     */
    eyecolor1: number;
    /**
     * @generated from protobuf field: int32 eyecolor2 = 19;
     */
    eyecolor2: number;
    /**
     * @generated from protobuf field: int32 tutorial = 20;
     */
    tutorial: number;
}
/**
 * @generated from protobuf message eq.AA_Array
 */
export interface AA_Array {
    /**
     * @generated from protobuf field: int32 aa = 1;
     */
    aa: number;
    /**
     * @generated from protobuf field: int32 value = 2;
     */
    value: number;
}
/**
 * @generated from protobuf message eq.Disciplines
 */
export interface Disciplines {
    /**
     * @generated from protobuf field: repeated int32 values = 1;
     */
    values: number[];
}
/**
 * @generated from protobuf message eq.Tribute
 */
export interface Tribute {
    /**
     * @generated from protobuf field: int32 tribute = 1;
     */
    tribute: number;
    /**
     * @generated from protobuf field: int32 tier = 2;
     */
    tier: number;
}
/**
 * @generated from protobuf message eq.BandolierItem
 */
export interface BandolierItem {
    /**
     * @generated from protobuf field: int32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: int32 icon = 2;
     */
    icon: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
}
/**
 * @generated from protobuf message eq.Bandolier
 */
export interface Bandolier {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: repeated eq.BandolierItem items = 2;
     */
    items: BandolierItem[];
}
/**
 * @generated from protobuf message eq.PotionBeltItem
 */
export interface PotionBeltItem {
    /**
     * @generated from protobuf field: int32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: int32 icon = 2;
     */
    icon: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
}
/**
 * @generated from protobuf message eq.PotionBelt
 */
export interface PotionBelt {
    /**
     * @generated from protobuf field: repeated eq.PotionBeltItem items = 1;
     */
    items: PotionBeltItem[];
}
/**
 * @generated from protobuf message eq.StringList
 */
export interface StringList {
    /**
     * @generated from protobuf field: string str = 1;
     */
    str: string;
}
/**
 * @generated from protobuf message eq.GroupLeadershipAA
 */
export interface GroupLeadershipAA {
    /**
     * @generated from protobuf field: int32 group_aa_mark_npc = 1;
     */
    groupAaMarkNpc: number;
    /**
     * @generated from protobuf field: int32 group_aanpc_health = 2;
     */
    groupAanpcHealth: number;
    /**
     * @generated from protobuf field: int32 group_aa_delegate_main_assist = 3;
     */
    groupAaDelegateMainAssist: number;
    /**
     * @generated from protobuf field: int32 group_aa_delegate_mark_npc = 4;
     */
    groupAaDelegateMarkNpc: number;
    /**
     * @generated from protobuf field: int32 group_aa4 = 5;
     */
    groupAa4: number;
    /**
     * @generated from protobuf field: int32 group_aa5 = 6;
     */
    groupAa5: number;
    /**
     * @generated from protobuf field: int32 group_aa_inspect_buffs = 7;
     */
    groupAaInspectBuffs: number;
    /**
     * @generated from protobuf field: int32 group_aa7 = 8;
     */
    groupAa7: number;
    /**
     * @generated from protobuf field: int32 group_aa_spell_awareness = 9;
     */
    groupAaSpellAwareness: number;
    /**
     * @generated from protobuf field: int32 group_aa_offense_enhancement = 10;
     */
    groupAaOffenseEnhancement: number;
    /**
     * @generated from protobuf field: int32 group_aa_mana_enhancement = 11;
     */
    groupAaManaEnhancement: number;
    /**
     * @generated from protobuf field: int32 group_aa_health_enhancement = 12;
     */
    groupAaHealthEnhancement: number;
    /**
     * @generated from protobuf field: int32 group_aa_health_regeneration = 13;
     */
    groupAaHealthRegeneration: number;
    /**
     * @generated from protobuf field: int32 group_aa_find_path_to_pc = 14;
     */
    groupAaFindPathToPc: number;
    /**
     * @generated from protobuf field: int32 group_aa_health_of_targets_target = 15;
     */
    groupAaHealthOfTargetsTarget: number;
    /**
     * @generated from protobuf field: int32 group_aa15 = 16;
     */
    groupAa15: number;
}
/**
 * @generated from protobuf message eq.RaidLeadershipAA
 */
export interface RaidLeadershipAA {
    /**
     * @generated from protobuf field: int32 raid_aa_mark_npc = 1;
     */
    raidAaMarkNpc: number;
    /**
     * @generated from protobuf field: int32 raid_aanpc_health = 2;
     */
    raidAanpcHealth: number;
    /**
     * @generated from protobuf field: int32 raid_aa_delegate_main_assist = 3;
     */
    raidAaDelegateMainAssist: number;
    /**
     * @generated from protobuf field: int32 raid_aa_delegate_mark_npc = 4;
     */
    raidAaDelegateMarkNpc: number;
    /**
     * @generated from protobuf field: int32 raid_aa4 = 5;
     */
    raidAa4: number;
    /**
     * @generated from protobuf field: int32 raid_aa5 = 6;
     */
    raidAa5: number;
    /**
     * @generated from protobuf field: int32 raid_aa6 = 7;
     */
    raidAa6: number;
    /**
     * @generated from protobuf field: int32 raid_aa_spell_awareness = 8;
     */
    raidAaSpellAwareness: number;
    /**
     * @generated from protobuf field: int32 raid_aa_offense_enhancement = 9;
     */
    raidAaOffenseEnhancement: number;
    /**
     * @generated from protobuf field: int32 raid_aa_mana_enhancement = 10;
     */
    raidAaManaEnhancement: number;
    /**
     * @generated from protobuf field: int32 raid_aa_health_enhancement = 11;
     */
    raidAaHealthEnhancement: number;
    /**
     * @generated from protobuf field: int32 raid_aa_health_regeneration = 12;
     */
    raidAaHealthRegeneration: number;
    /**
     * @generated from protobuf field: int32 raid_aa_find_path_to_pc = 13;
     */
    raidAaFindPathToPc: number;
    /**
     * @generated from protobuf field: int32 raid_aa_health_of_targets_target = 14;
     */
    raidAaHealthOfTargetsTarget: number;
    /**
     * @generated from protobuf field: int32 raid_aa14 = 15;
     */
    raidAa14: number;
    /**
     * @generated from protobuf field: int32 raid_aa15 = 16;
     */
    raidAa15: number;
}
/**
 * @generated from protobuf message eq.LeadershipAA
 */
export interface LeadershipAA {
    /**
     * @generated from protobuf field: eq.GroupLeadershipAA group = 1;
     */
    group?: GroupLeadershipAA;
    /**
     * @generated from protobuf field: eq.RaidLeadershipAA raid = 2;
     */
    raid?: RaidLeadershipAA;
}
/**
 * @generated from protobuf message eq.Bind
 */
export interface Bind {
    /**
     * @generated from protobuf field: int32 zone_id = 1;
     */
    zoneId: number;
    /**
     * @generated from protobuf field: float x = 2;
     */
    x: number;
    /**
     * @generated from protobuf field: float y = 3;
     */
    y: number;
    /**
     * @generated from protobuf field: float z = 4;
     */
    z: number;
    /**
     * @generated from protobuf field: float heading = 5;
     */
    heading: number;
}
/**
 * @generated from protobuf message eq.PVPStatsEntry
 */
export interface PVPStatsEntry {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: int32 level = 2;
     */
    level: number;
    /**
     * @generated from protobuf field: int32 race = 3;
     */
    race: number;
    /**
     * @generated from protobuf field: int32 char_class = 4;
     */
    charClass: number;
    /**
     * @generated from protobuf field: int32 zone = 5;
     */
    zone: number;
    /**
     * @generated from protobuf field: int32 time = 6;
     */
    time: number;
    /**
     * @generated from protobuf field: int32 points = 7;
     */
    points: number;
}
/**
 * @generated from protobuf message eq.PlayerProfile
 */
export interface PlayerProfile {
    /**
     * @generated from protobuf field: int32 checksum = 1;
     */
    checksum: number;
    /**
     * @generated from protobuf field: int32 gender = 2;
     */
    gender: number;
    /**
     * @generated from protobuf field: int32 race = 3;
     */
    race: number;
    /**
     * @generated from protobuf field: int32 char_class = 4;
     */
    charClass: number;
    /**
     * @generated from protobuf field: int32 level = 5;
     */
    level: number;
    /**
     * @generated from protobuf field: int32 level1 = 6;
     */
    level1: number;
    /**
     * @generated from protobuf field: repeated eq.Bind binds = 7;
     */
    binds: Bind[];
    /**
     * @generated from protobuf field: int32 deity = 8;
     */
    deity: number;
    /**
     * @generated from protobuf field: int32 intoxication = 9;
     */
    intoxication: number;
    /**
     * @generated from protobuf field: repeated int32 spell_slot_refresh = 10;
     */
    spellSlotRefresh: number[];
    /**
     * @generated from protobuf field: int32 ability_slot_refresh = 11;
     */
    abilitySlotRefresh: number;
    /**
     * @generated from protobuf field: int32 haircolor = 12;
     */
    haircolor: number;
    /**
     * @generated from protobuf field: int32 beardcolor = 13;
     */
    beardcolor: number;
    /**
     * @generated from protobuf field: int32 eyecolor1 = 14;
     */
    eyecolor1: number;
    /**
     * @generated from protobuf field: int32 eyecolor2 = 15;
     */
    eyecolor2: number;
    /**
     * @generated from protobuf field: int32 hairstyle = 16;
     */
    hairstyle: number;
    /**
     * @generated from protobuf field: int32 beard = 17;
     */
    beard: number;
    /**
     * @generated from protobuf field: eq.TextureProfile item_material = 18;
     */
    itemMaterial?: TextureProfile;
    /**
     * @generated from protobuf field: int32 item_tint = 19;
     */
    itemTint: number;
    /**
     * @generated from protobuf field: repeated eq.AA_Array aa_array = 20;
     */
    aaArray: AA_Array[];
    /**
     * @generated from protobuf field: int32 points = 21;
     */
    points: number;
    /**
     * @generated from protobuf field: int32 mana = 22;
     */
    mana: number;
    /**
     * @generated from protobuf field: int32 cur_hp = 23;
     */
    curHp: number;
    /**
     * @generated from protobuf field: int32 str = 24;
     */
    str: number;
    /**
     * @generated from protobuf field: int32 sta = 25;
     */
    sta: number;
    /**
     * @generated from protobuf field: int32 cha = 26;
     */
    cha: number;
    /**
     * @generated from protobuf field: int32 dex = 27;
     */
    dex: number;
    /**
     * @generated from protobuf field: int32 intel = 28;
     */
    intel: number;
    /**
     * @generated from protobuf field: int32 agi = 29;
     */
    agi: number;
    /**
     * @generated from protobuf field: int32 wis = 30;
     */
    wis: number;
    /**
     * @generated from protobuf field: int32 face = 31;
     */
    face: number;
    /**
     * @generated from protobuf field: repeated int32 spell_book = 32;
     */
    spellBook: number[];
    /**
     * @generated from protobuf field: repeated int32 mem_spells = 33;
     */
    memSpells: number[];
    /**
     * @generated from protobuf field: int32 platinum = 34;
     */
    platinum: number;
    /**
     * @generated from protobuf field: int32 gold = 35;
     */
    gold: number;
    /**
     * @generated from protobuf field: int32 silver = 36;
     */
    silver: number;
    /**
     * @generated from protobuf field: int32 copper = 37;
     */
    copper: number;
    /**
     * @generated from protobuf field: int32 platinum_cursor = 38;
     */
    platinumCursor: number;
    /**
     * @generated from protobuf field: int32 gold_cursor = 39;
     */
    goldCursor: number;
    /**
     * @generated from protobuf field: int32 silver_cursor = 40;
     */
    silverCursor: number;
    /**
     * @generated from protobuf field: int32 copper_cursor = 41;
     */
    copperCursor: number;
    /**
     * @generated from protobuf field: repeated int32 skills = 42;
     */
    skills: number[];
    /**
     * @generated from protobuf field: repeated int32 innate_skills = 43;
     */
    innateSkills: number[];
    /**
     * @generated from protobuf field: int32 toxicity = 44;
     */
    toxicity: number;
    /**
     * @generated from protobuf field: int32 thirst_level = 45;
     */
    thirstLevel: number;
    /**
     * @generated from protobuf field: int32 hunger_level = 46;
     */
    hungerLevel: number;
    /**
     * @generated from protobuf field: repeated eq.SpellBuff buffs = 47;
     */
    buffs: SpellBuff[];
    /**
     * @generated from protobuf field: eq.Disciplines disciplines = 48;
     */
    disciplines?: Disciplines;
    /**
     * @generated from protobuf field: repeated int32 recast_timers = 49;
     */
    recastTimers: number[];
    /**
     * @generated from protobuf field: int32 endurance = 50;
     */
    endurance: number;
    /**
     * @generated from protobuf field: int32 aapoints_spent = 51;
     */
    aapointsSpent: number;
    /**
     * @generated from protobuf field: int32 aapoints = 52;
     */
    aapoints: number;
    /**
     * @generated from protobuf field: repeated eq.Bandolier bandoliers = 53;
     */
    bandoliers: Bandolier[];
    /**
     * @generated from protobuf field: eq.PotionBelt potionbelt = 54;
     */
    potionbelt?: PotionBelt;
    /**
     * @generated from protobuf field: int32 available_slots = 55;
     */
    availableSlots: number;
    /**
     * @generated from protobuf field: string name = 56;
     */
    name: string;
    /**
     * @generated from protobuf field: string last_name = 57;
     */
    lastName: string;
    /**
     * @generated from protobuf field: int32 guild_id = 58;
     */
    guildId: number;
    /**
     * @generated from protobuf field: int32 birthday = 59;
     */
    birthday: number;
    /**
     * @generated from protobuf field: int32 lastlogin = 60;
     */
    lastlogin: number;
    /**
     * @generated from protobuf field: int32 time_played_min = 61;
     */
    timePlayedMin: number;
    /**
     * @generated from protobuf field: int32 pvp = 62;
     */
    pvp: number;
    /**
     * @generated from protobuf field: int32 anon = 63;
     */
    anon: number;
    /**
     * @generated from protobuf field: int32 gm = 64;
     */
    gm: number;
    /**
     * @generated from protobuf field: int32 guildrank = 65;
     */
    guildrank: number;
    /**
     * @generated from protobuf field: int32 guildbanker = 66;
     */
    guildbanker: number;
    /**
     * @generated from protobuf field: int32 exp = 67;
     */
    exp: number;
    /**
     * @generated from protobuf field: int32 timeentitledonaccount = 68;
     */
    timeentitledonaccount: number;
    /**
     * @generated from protobuf field: repeated int32 languages = 69;
     */
    languages: number[];
    /**
     * @generated from protobuf field: float x = 70;
     */
    x: number;
    /**
     * @generated from protobuf field: float y = 71;
     */
    y: number;
    /**
     * @generated from protobuf field: float z = 72;
     */
    z: number;
    /**
     * @generated from protobuf field: float heading = 73;
     */
    heading: number;
    /**
     * @generated from protobuf field: int32 platinum_bank = 74;
     */
    platinumBank: number;
    /**
     * @generated from protobuf field: int32 gold_bank = 75;
     */
    goldBank: number;
    /**
     * @generated from protobuf field: int32 silver_bank = 76;
     */
    silverBank: number;
    /**
     * @generated from protobuf field: int32 copper_bank = 77;
     */
    copperBank: number;
    /**
     * @generated from protobuf field: int32 platinum_shared = 78;
     */
    platinumShared: number;
    /**
     * @generated from protobuf field: int32 expansions = 79;
     */
    expansions: number;
    /**
     * @generated from protobuf field: int32 autosplit = 80;
     */
    autosplit: number;
    /**
     * @generated from protobuf field: int32 zone_id = 81;
     */
    zoneId: number;
    /**
     * @generated from protobuf field: int32 zone_instance = 82;
     */
    zoneInstance: number;
    /**
     * @generated from protobuf field: repeated eq.StringList group_members = 83;
     */
    groupMembers: StringList[];
    /**
     * @generated from protobuf field: string group_leader = 84;
     */
    groupLeader: string;
    /**
     * @generated from protobuf field: int32 entityid = 85;
     */
    entityid: number;
    /**
     * @generated from protobuf field: int32 lead_aa_active = 86;
     */
    leadAaActive: number;
    /**
     * @generated from protobuf field: int32 ldon_points_guk = 87;
     */
    ldonPointsGuk: number;
    /**
     * @generated from protobuf field: int32 ldon_points_mir = 88;
     */
    ldonPointsMir: number;
    /**
     * @generated from protobuf field: int32 ldon_points_mmc = 89;
     */
    ldonPointsMmc: number;
    /**
     * @generated from protobuf field: int32 ldon_points_ruj = 90;
     */
    ldonPointsRuj: number;
    /**
     * @generated from protobuf field: int32 ldon_points_tak = 91;
     */
    ldonPointsTak: number;
    /**
     * @generated from protobuf field: int32 ldon_points_available = 92;
     */
    ldonPointsAvailable: number;
    /**
     * @generated from protobuf field: int32 tribute_time_remaining = 93;
     */
    tributeTimeRemaining: number;
    /**
     * @generated from protobuf field: int32 career_tribute_points = 94;
     */
    careerTributePoints: number;
    /**
     * @generated from protobuf field: int32 tribute_points = 95;
     */
    tributePoints: number;
    /**
     * @generated from protobuf field: int32 tribute_active = 96;
     */
    tributeActive: number;
    /**
     * @generated from protobuf field: repeated eq.Tribute tributes = 97;
     */
    tributes: Tribute[];
    /**
     * @generated from protobuf field: double group_leadership_exp = 98;
     */
    groupLeadershipExp: number;
    /**
     * @generated from protobuf field: double raid_leadership_exp = 99;
     */
    raidLeadershipExp: number;
    /**
     * @generated from protobuf field: int32 group_leadership_points = 100;
     */
    groupLeadershipPoints: number;
    /**
     * @generated from protobuf field: int32 raid_leadership_points = 101;
     */
    raidLeadershipPoints: number;
    /**
     * @generated from protobuf field: eq.LeadershipAA leader_abilities = 102;
     */
    leaderAbilities?: LeadershipAA;
    /**
     * @generated from protobuf field: int32 air_remaining = 103;
     */
    airRemaining: number;
    /**
     * @generated from protobuf field: int32 pvp_kills = 104;
     */
    pvpKills: number;
    /**
     * @generated from protobuf field: int32 pvp_deaths = 105;
     */
    pvpDeaths: number;
    /**
     * @generated from protobuf field: int32 pvp_current_points = 106;
     */
    pvpCurrentPoints: number;
    /**
     * @generated from protobuf field: int32 pvp_career_points = 107;
     */
    pvpCareerPoints: number;
    /**
     * @generated from protobuf field: int32 pvp_best_kill_streak = 108;
     */
    pvpBestKillStreak: number;
    /**
     * @generated from protobuf field: int32 pvp_worst_death_streak = 109;
     */
    pvpWorstDeathStreak: number;
    /**
     * @generated from protobuf field: int32 pvp_current_kill_streak = 110;
     */
    pvpCurrentKillStreak: number;
    /**
     * @generated from protobuf field: eq.PVPStatsEntry pvp_last_kill = 111;
     */
    pvpLastKill?: PVPStatsEntry;
    /**
     * @generated from protobuf field: eq.PVPStatsEntry pvp_last_death = 112;
     */
    pvpLastDeath?: PVPStatsEntry;
    /**
     * @generated from protobuf field: int32 pvp_number_of_kills_in_last__hours = 113;
     */
    pvpNumberOfKillsInLastHours: number;
    /**
     * @generated from protobuf field: repeated eq.PVPStatsEntry pvp_recent_kills = 114;
     */
    pvpRecentKills: PVPStatsEntry[];
    /**
     * @generated from protobuf field: int32 exp_aa = 115;
     */
    expAa: number;
    /**
     * @generated from protobuf field: int32 current_rad_crystals = 116;
     */
    currentRadCrystals: number;
    /**
     * @generated from protobuf field: int32 career_rad_crystals = 117;
     */
    careerRadCrystals: number;
    /**
     * @generated from protobuf field: int32 current_ebon_crystals = 118;
     */
    currentEbonCrystals: number;
    /**
     * @generated from protobuf field: int32 career_ebon_crystals = 119;
     */
    careerEbonCrystals: number;
    /**
     * @generated from protobuf field: int32 group_autoconsent = 120;
     */
    groupAutoconsent: number;
    /**
     * @generated from protobuf field: int32 raid_autoconsent = 121;
     */
    raidAutoconsent: number;
    /**
     * @generated from protobuf field: int32 guild_autoconsent = 122;
     */
    guildAutoconsent: number;
    /**
     * @generated from protobuf field: int32 level3 = 123;
     */
    level3: number;
    /**
     * @generated from protobuf field: int32 showhelm = 124;
     */
    showhelm: number;
}
/**
 * @generated from protobuf message eq.ClientTarget
 */
export interface ClientTarget {
    /**
     * @generated from protobuf field: int32 new_target = 1;
     */
    newTarget: number;
}
/**
 * @generated from protobuf message eq.TargetReject
 */
export interface TargetReject {
}
/**
 * @generated from protobuf message eq.PetCommand
 */
export interface PetCommand {
    /**
     * @generated from protobuf field: int32 command = 1;
     */
    command: number;
    /**
     * @generated from protobuf field: int32 target = 2;
     */
    target: number;
}
/**
 * @generated from protobuf message eq.DeleteSpawn
 */
export interface DeleteSpawn {
    /**
     * @generated from protobuf field: int32 spawn_id = 1;
     */
    spawnId: number;
}
/**
 * @generated from protobuf message eq.ChannelMessage
 */
export interface ChannelMessage {
    /**
     * @generated from protobuf field: string targetname = 1;
     */
    targetname: string;
    /**
     * @generated from protobuf field: string sender = 2;
     */
    sender: string;
    /**
     * @generated from protobuf field: int32 language = 3;
     */
    language: number;
    /**
     * @generated from protobuf field: int32 chan_num = 4;
     */
    chanNum: number;
    /**
     * @generated from protobuf field: int32 skill_in_language = 5;
     */
    skillInLanguage: number;
    /**
     * @generated from protobuf field: string message = 6;
     */
    message: string;
}
/**
 * @generated from protobuf message eq.SpecialMesg
 */
export interface SpecialMesg {
    /**
     * @generated from protobuf field: string header = 1;
     */
    header: string;
    /**
     * @generated from protobuf field: int32 msg_type = 2;
     */
    msgType: number;
    /**
     * @generated from protobuf field: int32 target_spawn_id = 3;
     */
    targetSpawnId: number;
    /**
     * @generated from protobuf field: string sayer = 4;
     */
    sayer: string;
    /**
     * @generated from protobuf field: string message = 5;
     */
    message: string;
}
/**
 * @generated from protobuf message eq.WearChange
 */
export interface WearChange {
    /**
     * @generated from protobuf field: int32 spawn_id = 1;
     */
    spawnId: number;
    /**
     * @generated from protobuf field: int32 material = 2;
     */
    material: number;
    /**
     * @generated from protobuf field: int32 color = 3;
     */
    color: number;
    /**
     * @generated from protobuf field: int32 wear_slot_id = 4;
     */
    wearSlotId: number;
}
/**
 * @generated from protobuf message eq.BindWound
 */
export interface BindWound {
    /**
     * @generated from protobuf field: int32 to = 1;
     */
    to: number;
    /**
     * @generated from protobuf field: int32 type = 2;
     */
    type: number;
}
/**
 * @generated from protobuf message eq.ZoneChange
 */
export interface ZoneChange {
    /**
     * @generated from protobuf field: string char_name = 1;
     */
    charName: string;
    /**
     * @generated from protobuf field: int32 zone_id = 2;
     */
    zoneId: number;
    /**
     * @generated from protobuf field: int32 instance_id = 3;
     */
    instanceId: number;
    /**
     * @generated from protobuf field: float y = 4;
     */
    y: number;
    /**
     * @generated from protobuf field: float x = 5;
     */
    x: number;
    /**
     * @generated from protobuf field: float z = 6;
     */
    z: number;
    /**
     * @generated from protobuf field: int32 zone_reason = 7;
     */
    zoneReason: number;
    /**
     * @generated from protobuf field: int32 success = 8;
     */
    success: number;
}
/**
 * @generated from protobuf message eq.RequestClientZoneChange
 */
export interface RequestClientZoneChange {
    /**
     * @generated from protobuf field: int32 zone_id = 1;
     */
    zoneId: number;
    /**
     * @generated from protobuf field: int32 instance_id = 2;
     */
    instanceId: number;
    /**
     * @generated from protobuf field: float y = 3;
     */
    y: number;
    /**
     * @generated from protobuf field: float x = 4;
     */
    x: number;
    /**
     * @generated from protobuf field: float z = 5;
     */
    z: number;
    /**
     * @generated from protobuf field: float heading = 6;
     */
    heading: number;
    /**
     * @generated from protobuf field: int32 type = 7;
     */
    type: number;
}
/**
 * @generated from protobuf message eq.Animation
 */
export interface Animation {
    /**
     * @generated from protobuf field: int32 spawnid = 1;
     */
    spawnid: number;
    /**
     * @generated from protobuf field: int32 speed = 2;
     */
    speed: number;
    /**
     * @generated from protobuf field: int32 action = 3;
     */
    action: number;
}
/**
 * @generated from protobuf message eq.Action
 */
export interface Action {
    /**
     * @generated from protobuf field: int32 target = 1;
     */
    target: number;
    /**
     * @generated from protobuf field: int32 source = 2;
     */
    source: number;
    /**
     * @generated from protobuf field: int32 level = 3;
     */
    level: number;
    /**
     * @generated from protobuf field: int32 instrument_mod = 4;
     */
    instrumentMod: number;
    /**
     * @generated from protobuf field: float force = 5;
     */
    force: number;
    /**
     * @generated from protobuf field: float hit_heading = 6;
     */
    hitHeading: number;
    /**
     * @generated from protobuf field: float hit_pitch = 7;
     */
    hitPitch: number;
    /**
     * @generated from protobuf field: int32 type = 8;
     */
    type: number;
    /**
     * @generated from protobuf field: int32 spell = 9;
     */
    spell: number;
    /**
     * @generated from protobuf field: int32 spell_level = 10;
     */
    spellLevel: number;
    /**
     * @generated from protobuf field: int32 effect_flag = 11;
     */
    effectFlag: number;
}
/**
 * @generated from protobuf message eq.CombatDamage
 */
export interface CombatDamage {
    /**
     * @generated from protobuf field: int32 target = 1;
     */
    target: number;
    /**
     * @generated from protobuf field: int32 source = 2;
     */
    source: number;
    /**
     * @generated from protobuf field: int32 type = 3;
     */
    type: number;
    /**
     * @generated from protobuf field: int32 spellid = 4;
     */
    spellid: number;
    /**
     * @generated from protobuf field: int32 damage = 5;
     */
    damage: number;
    /**
     * @generated from protobuf field: float force = 6;
     */
    force: number;
    /**
     * @generated from protobuf field: float hit_heading = 7;
     */
    hitHeading: number;
    /**
     * @generated from protobuf field: float hit_pitch = 8;
     */
    hitPitch: number;
}
/**
 * @generated from protobuf message eq.Consider
 */
export interface Consider {
    /**
     * @generated from protobuf field: int32 playerid = 1;
     */
    playerid: number;
    /**
     * @generated from protobuf field: int32 targetid = 2;
     */
    targetid: number;
    /**
     * @generated from protobuf field: int32 faction = 3;
     */
    faction: number;
    /**
     * @generated from protobuf field: int32 level = 4;
     */
    level: number;
    /**
     * @generated from protobuf field: int32 cur_hp = 5;
     */
    curHp: number;
    /**
     * @generated from protobuf field: int32 max_hp = 6;
     */
    maxHp: number;
    /**
     * @generated from protobuf field: int32 pvpcon = 7;
     */
    pvpcon: number;
}
/**
 * @generated from protobuf message eq.Death
 */
export interface Death {
    /**
     * @generated from protobuf field: int32 spawn_id = 1;
     */
    spawnId: number;
    /**
     * @generated from protobuf field: int32 killer_id = 2;
     */
    killerId: number;
    /**
     * @generated from protobuf field: int32 corpseid = 3;
     */
    corpseid: number;
    /**
     * @generated from protobuf field: int32 attack_skill = 4;
     */
    attackSkill: number;
    /**
     * @generated from protobuf field: int32 spell_id = 5;
     */
    spellId: number;
    /**
     * @generated from protobuf field: int32 bindzoneid = 6;
     */
    bindzoneid: number;
    /**
     * @generated from protobuf field: int32 damage = 7;
     */
    damage: number;
}
/**
 * @generated from protobuf message eq.BecomeCorpse
 */
export interface BecomeCorpse {
    /**
     * @generated from protobuf field: int32 spawn_id = 1;
     */
    spawnId: number;
    /**
     * @generated from protobuf field: float y = 2;
     */
    y: number;
    /**
     * @generated from protobuf field: float x = 3;
     */
    x: number;
    /**
     * @generated from protobuf field: float z = 4;
     */
    z: number;
}
/**
 * @generated from protobuf message eq.PlayerPositionUpdateServer
 */
export interface PlayerPositionUpdateServer {
    /**
     * @generated from protobuf field: int32 spawn_id = 1;
     */
    spawnId: number;
    /**
     * @generated from protobuf field: int32 delta_heading = 2;
     */
    deltaHeading: number;
    /**
     * @generated from protobuf field: int32 x_pos = 3;
     */
    xPos: number;
    /**
     * @generated from protobuf field: int32 y_pos = 4;
     */
    yPos: number;
    /**
     * @generated from protobuf field: int32 animation = 5;
     */
    animation: number;
    /**
     * @generated from protobuf field: int32 z_pos = 6;
     */
    zPos: number;
    /**
     * @generated from protobuf field: int32 delta_y = 7;
     */
    deltaY: number;
    /**
     * @generated from protobuf field: int32 delta_x = 8;
     */
    deltaX: number;
    /**
     * @generated from protobuf field: int32 heading = 9;
     */
    heading: number;
    /**
     * @generated from protobuf field: int32 delta_z = 10;
     */
    deltaZ: number;
}
/**
 * @generated from protobuf message eq.PlayerPositionUpdateClient
 */
export interface PlayerPositionUpdateClient {
    /**
     * @generated from protobuf field: int32 spawn_id = 1;
     */
    spawnId: number;
    /**
     * @generated from protobuf field: int32 sequence = 2;
     */
    sequence: number;
    /**
     * @generated from protobuf field: float y_pos = 3;
     */
    yPos: number;
    /**
     * @generated from protobuf field: float delta_z = 4;
     */
    deltaZ: number;
    /**
     * @generated from protobuf field: float delta_x = 5;
     */
    deltaX: number;
    /**
     * @generated from protobuf field: float delta_y = 6;
     */
    deltaY: number;
    /**
     * @generated from protobuf field: int32 animation = 7;
     */
    animation: number;
    /**
     * @generated from protobuf field: int32 delta_heading = 8;
     */
    deltaHeading: number;
    /**
     * @generated from protobuf field: float x_pos = 9;
     */
    xPos: number;
    /**
     * @generated from protobuf field: float z_pos = 10;
     */
    zPos: number;
    /**
     * @generated from protobuf field: int32 heading = 11;
     */
    heading: number;
}
/**
 * @generated from protobuf message eq.SpawnHPUpdate
 */
export interface SpawnHPUpdate {
    /**
     * @generated from protobuf field: int32 cur_hp = 1;
     */
    curHp: number;
    /**
     * @generated from protobuf field: int32 max_hp = 2;
     */
    maxHp: number;
    /**
     * @generated from protobuf field: int32 spawn_id = 3;
     */
    spawnId: number;
}
/**
 * @generated from protobuf message eq.SpawnHPUpdate2
 */
export interface SpawnHPUpdate2 {
    /**
     * @generated from protobuf field: int32 spawn_id = 1;
     */
    spawnId: number;
    /**
     * @generated from protobuf field: int32 hp = 2;
     */
    hp: number;
}
/**
 * @generated from protobuf message eq.Stamina
 */
export interface Stamina {
    /**
     * @generated from protobuf field: int32 food = 1;
     */
    food: number;
    /**
     * @generated from protobuf field: int32 water = 2;
     */
    water: number;
}
/**
 * @generated from protobuf message eq.LevelUpdate
 */
export interface LevelUpdate {
    /**
     * @generated from protobuf field: int32 level = 1;
     */
    level: number;
    /**
     * @generated from protobuf field: int32 level_old = 2;
     */
    levelOld: number;
    /**
     * @generated from protobuf field: int32 exp = 3;
     */
    exp: number;
}
/**
 * @generated from protobuf message eq.ExpUpdate
 */
export interface ExpUpdate {
    /**
     * @generated from protobuf field: int32 exp = 1;
     */
    exp: number;
    /**
     * @generated from protobuf field: int32 aaxp = 2;
     */
    aaxp: number;
}
/**
 * @generated from protobuf message eq.ItemPacket
 */
export interface ItemPacket {
    /**
     * @generated from protobuf field: eq.ItemPacketType packet_type = 1;
     */
    packetType: ItemPacketType;
    /**
     * @generated from protobuf field: string serialized_item = 2;
     */
    serializedItem: string;
}
/**
 * @generated from protobuf message eq.BulkItemPacket
 */
export interface BulkItemPacket {
    /**
     * @generated from protobuf field: string serialized_item = 1;
     */
    serializedItem: string;
}
/**
 * @generated from protobuf message eq.Consume
 */
export interface Consume {
    /**
     * @generated from protobuf field: int32 slot = 1;
     */
    slot: number;
    /**
     * @generated from protobuf field: int32 auto_consumed = 2;
     */
    autoConsumed: number;
    /**
     * @generated from protobuf field: int32 type = 3;
     */
    type: number;
}
/**
 * @generated from protobuf message eq.DeleteItem
 */
export interface DeleteItem {
    /**
     * @generated from protobuf field: int32 from_slot = 1;
     */
    fromSlot: number;
    /**
     * @generated from protobuf field: int32 to_slot = 2;
     */
    toSlot: number;
    /**
     * @generated from protobuf field: int32 number_in_stack = 3;
     */
    numberInStack: number;
}
/**
 * @generated from protobuf message eq.MoveItem
 */
export interface MoveItem {
    /**
     * @generated from protobuf field: int32 from_slot = 1;
     */
    fromSlot: number;
    /**
     * @generated from protobuf field: int32 to_slot = 2;
     */
    toSlot: number;
    /**
     * @generated from protobuf field: int32 number_in_stack = 3;
     */
    numberInStack: number;
}
/**
 * @generated from protobuf message eq.MultiMoveItemSub
 */
export interface MultiMoveItemSub {
    /**
     * @generated from protobuf field: eq.InventorySlot from_slot = 1;
     */
    fromSlot?: InventorySlot;
    /**
     * @generated from protobuf field: int32 number_in_stack = 2;
     */
    numberInStack: number;
    /**
     * @generated from protobuf field: eq.InventorySlot to_slot = 3;
     */
    toSlot?: InventorySlot;
}
/**
 * @generated from protobuf message eq.MultiMoveItem
 */
export interface MultiMoveItem {
    /**
     * @generated from protobuf field: int32 count = 1;
     */
    count: number;
    /**
     * @generated from protobuf field: repeated eq.MultiMoveItemSub moves = 2;
     */
    moves: MultiMoveItemSub[];
}
/**
 * @generated from protobuf message eq.MoveCoin
 */
export interface MoveCoin {
    /**
     * @generated from protobuf field: int32 from_slot = 1;
     */
    fromSlot: number;
    /**
     * @generated from protobuf field: int32 to_slot = 2;
     */
    toSlot: number;
    /**
     * @generated from protobuf field: int32 cointype1 = 3;
     */
    cointype1: number;
    /**
     * @generated from protobuf field: int32 cointype2 = 4;
     */
    cointype2: number;
    /**
     * @generated from protobuf field: int32 amount = 5;
     */
    amount: number;
}
/**
 * @generated from protobuf message eq.TradeBusy
 */
export interface TradeBusy {
    /**
     * @generated from protobuf field: int32 to_mob_id = 1;
     */
    toMobId: number;
    /**
     * @generated from protobuf field: int32 from_mob_id = 2;
     */
    fromMobId: number;
}
/**
 * @generated from protobuf message eq.TradeCoin
 */
export interface TradeCoin {
    /**
     * @generated from protobuf field: int32 trader = 1;
     */
    trader: number;
    /**
     * @generated from protobuf field: int32 slot = 2;
     */
    slot: number;
    /**
     * @generated from protobuf field: int32 amount = 3;
     */
    amount: number;
}
/**
 * @generated from protobuf message eq.TradeMoneyUpdate
 */
export interface TradeMoneyUpdate {
    /**
     * @generated from protobuf field: int32 trader = 1;
     */
    trader: number;
    /**
     * @generated from protobuf field: int32 type = 2;
     */
    type: number;
    /**
     * @generated from protobuf field: int32 amount = 3;
     */
    amount: number;
}
/**
 * @generated from protobuf message eq.Surname
 */
export interface Surname {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string lastname = 2;
     */
    lastname: string;
}
/**
 * @generated from protobuf message eq.GuildsList
 */
export interface GuildsList {
    /**
     * @generated from protobuf field: repeated eq.StringList guilds = 1;
     */
    guilds: StringList[];
}
/**
 * @generated from protobuf message eq.MoneyOnCorpse
 */
export interface MoneyOnCorpse {
    /**
     * @generated from protobuf field: int32 response = 1;
     */
    response: number;
    /**
     * @generated from protobuf field: int32 platinum = 2;
     */
    platinum: number;
    /**
     * @generated from protobuf field: int32 gold = 3;
     */
    gold: number;
    /**
     * @generated from protobuf field: int32 silver = 4;
     */
    silver: number;
    /**
     * @generated from protobuf field: int32 copper = 5;
     */
    copper: number;
}
/**
 * @generated from protobuf message eq.LootingItem
 */
export interface LootingItem {
    /**
     * @generated from protobuf field: int32 lootee = 1;
     */
    lootee: number;
    /**
     * @generated from protobuf field: int32 looter = 2;
     */
    looter: number;
    /**
     * @generated from protobuf field: int32 slot_id = 3;
     */
    slotId: number;
    /**
     * @generated from protobuf field: int32 auto_loot = 4;
     */
    autoLoot: number;
}
/**
 * @generated from protobuf message eq.GuildManageStatus
 */
export interface GuildManageStatus {
    /**
     * @generated from protobuf field: int32 guildid = 1;
     */
    guildid: number;
    /**
     * @generated from protobuf field: int32 oldrank = 2;
     */
    oldrank: number;
    /**
     * @generated from protobuf field: int32 newrank = 3;
     */
    newrank: number;
    /**
     * @generated from protobuf field: string name = 4;
     */
    name: string;
}
/**
 * @generated from protobuf message eq.GuildJoin
 */
export interface GuildJoin {
    /**
     * @generated from protobuf field: int32 guildid = 1;
     */
    guildid: number;
    /**
     * @generated from protobuf field: int32 level = 2;
     */
    level: number;
    /**
     * @generated from protobuf field: int32 char_class = 3;
     */
    charClass: number;
    /**
     * @generated from protobuf field: int32 rank = 4;
     */
    rank: number;
    /**
     * @generated from protobuf field: int32 zoneid = 5;
     */
    zoneid: number;
    /**
     * @generated from protobuf field: string name = 6;
     */
    name: string;
}
/**
 * @generated from protobuf message eq.GuildInviteAccept
 */
export interface GuildInviteAccept {
    /**
     * @generated from protobuf field: string inviter = 1;
     */
    inviter: string;
    /**
     * @generated from protobuf field: string newmember = 2;
     */
    newmember: string;
    /**
     * @generated from protobuf field: int32 response = 3;
     */
    response: number;
    /**
     * @generated from protobuf field: int32 guildeqid = 4;
     */
    guildeqid: number;
}
/**
 * @generated from protobuf message eq.GuildManageRemove
 */
export interface GuildManageRemove {
    /**
     * @generated from protobuf field: int32 guildeqid = 1;
     */
    guildeqid: number;
    /**
     * @generated from protobuf field: string member = 2;
     */
    member: string;
}
/**
 * @generated from protobuf message eq.Guildcommand
 */
export interface Guildcommand {
    /**
     * @generated from protobuf field: string othername = 1;
     */
    othername: string;
    /**
     * @generated from protobuf field: string myname = 2;
     */
    myname: string;
    /**
     * @generated from protobuf field: int32 guildeqid = 3;
     */
    guildeqid: number;
    /**
     * @generated from protobuf field: int32 officer = 4;
     */
    officer: number;
}
/**
 * @generated from protobuf message eq.OnLevelMessage
 */
export interface OnLevelMessage {
    /**
     * @generated from protobuf field: string title = 1;
     */
    title: string;
    /**
     * @generated from protobuf field: string text = 2;
     */
    text: string;
    /**
     * @generated from protobuf field: int32 buttons = 3;
     */
    buttons: number;
    /**
     * @generated from protobuf field: int32 duration = 4;
     */
    duration: number;
    /**
     * @generated from protobuf field: int32 popup_id = 5;
     */
    popupId: number;
}
/**
 * @generated from protobuf message eq.GMZoneRequest
 */
export interface GMZoneRequest {
    /**
     * @generated from protobuf field: string charname = 1;
     */
    charname: string;
    /**
     * @generated from protobuf field: int32 zone_id = 2;
     */
    zoneId: number;
    /**
     * @generated from protobuf field: float x = 3;
     */
    x: number;
    /**
     * @generated from protobuf field: float y = 4;
     */
    y: number;
    /**
     * @generated from protobuf field: float z = 5;
     */
    z: number;
    /**
     * @generated from protobuf field: float heading = 6;
     */
    heading: number;
    /**
     * @generated from protobuf field: int32 success = 7;
     */
    success: number;
}
/**
 * @generated from protobuf message eq.GMSummon
 */
export interface GMSummon {
    /**
     * @generated from protobuf field: string charname = 1;
     */
    charname: string;
    /**
     * @generated from protobuf field: string gmname = 2;
     */
    gmname: string;
    /**
     * @generated from protobuf field: int32 success = 3;
     */
    success: number;
    /**
     * @generated from protobuf field: int32 zone_id = 4;
     */
    zoneId: number;
    /**
     * @generated from protobuf field: int32 y = 5;
     */
    y: number;
    /**
     * @generated from protobuf field: int32 x = 6;
     */
    x: number;
    /**
     * @generated from protobuf field: int32 z = 7;
     */
    z: number;
}
/**
 * @generated from protobuf message eq.GMGoto
 */
export interface GMGoto {
    /**
     * @generated from protobuf field: string charname = 1;
     */
    charname: string;
    /**
     * @generated from protobuf field: string gmname = 2;
     */
    gmname: string;
    /**
     * @generated from protobuf field: int32 success = 3;
     */
    success: number;
    /**
     * @generated from protobuf field: int32 zone_id = 4;
     */
    zoneId: number;
    /**
     * @generated from protobuf field: int32 y = 5;
     */
    y: number;
    /**
     * @generated from protobuf field: int32 x = 6;
     */
    x: number;
    /**
     * @generated from protobuf field: int32 z = 7;
     */
    z: number;
}
/**
 * @generated from protobuf message eq.GMLastName
 */
export interface GMLastName {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string gmname = 2;
     */
    gmname: string;
    /**
     * @generated from protobuf field: string lastname = 3;
     */
    lastname: string;
}
/**
 * @generated from protobuf message eq.CombatAbility
 */
export interface CombatAbility {
    /**
     * @generated from protobuf field: int32 m_target = 1;
     */
    mTarget: number;
    /**
     * @generated from protobuf field: int32 m_atk = 2;
     */
    mAtk: number;
    /**
     * @generated from protobuf field: int32 m_skill = 3;
     */
    mSkill: number;
}
/**
 * @generated from protobuf message eq.Instill_Doubt
 */
export interface Instill_Doubt {
    /**
     * @generated from protobuf field: int32 i_id = 1;
     */
    iId: number;
    /**
     * @generated from protobuf field: int32 i_atk = 2;
     */
    iAtk: number;
    /**
     * @generated from protobuf field: int32 i_type = 3;
     */
    iType: number;
}
/**
 * @generated from protobuf message eq.GiveItem
 */
export interface GiveItem {
    /**
     * @generated from protobuf field: int32 to_entity = 1;
     */
    toEntity: number;
    /**
     * @generated from protobuf field: int32 to_equip_slot = 2;
     */
    toEquipSlot: number;
    /**
     * @generated from protobuf field: int32 from_entity = 3;
     */
    fromEntity: number;
    /**
     * @generated from protobuf field: int32 from_equip_slot = 4;
     */
    fromEquipSlot: number;
}
/**
 * @generated from protobuf message eq.RandomReq
 */
export interface RandomReq {
    /**
     * @generated from protobuf field: int32 low = 1;
     */
    low: number;
    /**
     * @generated from protobuf field: int32 high = 2;
     */
    high: number;
}
/**
 * @generated from protobuf message eq.RandomReply
 */
export interface RandomReply {
    /**
     * @generated from protobuf field: int32 low = 1;
     */
    low: number;
    /**
     * @generated from protobuf field: int32 high = 2;
     */
    high: number;
    /**
     * @generated from protobuf field: int32 result = 3;
     */
    result: number;
    /**
     * @generated from protobuf field: string name = 4;
     */
    name: string;
}
/**
 * @generated from protobuf message eq.LFG
 */
export interface LFG {
    /**
     * @generated from protobuf field: int32 value = 1;
     */
    value: number;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
}
/**
 * @generated from protobuf message eq.LFG_Appearance
 */
export interface LFG_Appearance {
    /**
     * @generated from protobuf field: int32 spawn_id = 1;
     */
    spawnId: number;
    /**
     * @generated from protobuf field: int32 lfg = 2;
     */
    lfg: number;
}
/**
 * @generated from protobuf message eq.TimeOfDay
 */
export interface TimeOfDay {
    /**
     * @generated from protobuf field: int32 hour = 1;
     */
    hour: number;
    /**
     * @generated from protobuf field: int32 minute = 2;
     */
    minute: number;
    /**
     * @generated from protobuf field: int32 day = 3;
     */
    day: number;
    /**
     * @generated from protobuf field: int32 month = 4;
     */
    month: number;
    /**
     * @generated from protobuf field: int32 year = 5;
     */
    year: number;
}
/**
 * @generated from protobuf message eq.Merchant_Click
 */
export interface Merchant_Click {
    /**
     * @generated from protobuf field: int32 npcid = 1;
     */
    npcid: number;
    /**
     * @generated from protobuf field: int32 playerid = 2;
     */
    playerid: number;
    /**
     * @generated from protobuf field: int32 command = 3;
     */
    command: number;
    /**
     * @generated from protobuf field: float rate = 4;
     */
    rate: number;
}
/**
 * @generated from protobuf message eq.Merchant_Sell
 */
export interface Merchant_Sell {
    /**
     * @generated from protobuf field: int32 npcid = 1;
     */
    npcid: number;
    /**
     * @generated from protobuf field: int32 playerid = 2;
     */
    playerid: number;
    /**
     * @generated from protobuf field: int32 itemslot = 3;
     */
    itemslot: number;
    /**
     * @generated from protobuf field: int32 quantity = 4;
     */
    quantity: number;
    /**
     * @generated from protobuf field: int32 price = 5;
     */
    price: number;
}
/**
 * @generated from protobuf message eq.Merchant_Purchase
 */
export interface Merchant_Purchase {
    /**
     * @generated from protobuf field: int32 npcid = 1;
     */
    npcid: number;
    /**
     * @generated from protobuf field: int32 itemslot = 2;
     */
    itemslot: number;
    /**
     * @generated from protobuf field: int32 quantity = 3;
     */
    quantity: number;
    /**
     * @generated from protobuf field: int32 price = 4;
     */
    price: number;
}
/**
 * @generated from protobuf message eq.Merchant_DelItem
 */
export interface Merchant_DelItem {
    /**
     * @generated from protobuf field: int32 npcid = 1;
     */
    npcid: number;
    /**
     * @generated from protobuf field: int32 playerid = 2;
     */
    playerid: number;
    /**
     * @generated from protobuf field: int32 itemslot = 3;
     */
    itemslot: number;
}
/**
 * @generated from protobuf message eq.Adventure_Purchase
 */
export interface Adventure_Purchase {
    /**
     * @generated from protobuf field: int32 some_flag = 1;
     */
    someFlag: number;
    /**
     * @generated from protobuf field: int32 npcid = 2;
     */
    npcid: number;
    /**
     * @generated from protobuf field: int32 itemid = 3;
     */
    itemid: number;
    /**
     * @generated from protobuf field: int32 variable = 4;
     */
    variable: number;
}
/**
 * @generated from protobuf message eq.Adventure_Sell
 */
export interface Adventure_Sell {
    /**
     * @generated from protobuf field: int32 npcid = 1;
     */
    npcid: number;
    /**
     * @generated from protobuf field: int32 slot = 2;
     */
    slot: number;
    /**
     * @generated from protobuf field: int32 charges = 3;
     */
    charges: number;
    /**
     * @generated from protobuf field: int32 sell_price = 4;
     */
    sellPrice: number;
}
/**
 * @generated from protobuf message eq.AdventurePoints_Update
 */
export interface AdventurePoints_Update {
    /**
     * @generated from protobuf field: int32 ldon_available_points = 1;
     */
    ldonAvailablePoints: number;
    /**
     * @generated from protobuf field: repeated int32 unkown_apu = 2;
     */
    unkownApu: number[];
    /**
     * @generated from protobuf field: int32 ldon_guk_points = 3;
     */
    ldonGukPoints: number;
    /**
     * @generated from protobuf field: int32 ldon_mirugal_points = 4;
     */
    ldonMirugalPoints: number;
    /**
     * @generated from protobuf field: int32 ldon_mistmoore_points = 5;
     */
    ldonMistmoorePoints: number;
    /**
     * @generated from protobuf field: int32 ldon_rujarkian_points = 6;
     */
    ldonRujarkianPoints: number;
    /**
     * @generated from protobuf field: int32 ldon_takish_points = 7;
     */
    ldonTakishPoints: number;
}
/**
 * @generated from protobuf message eq.AdventureFinish
 */
export interface AdventureFinish {
    /**
     * @generated from protobuf field: int32 win_lose = 1;
     */
    winLose: number;
    /**
     * @generated from protobuf field: int32 points = 2;
     */
    points: number;
}
/**
 * @generated from protobuf message eq.AdventureRequest
 */
export interface AdventureRequest {
    /**
     * @generated from protobuf field: int32 risk = 1;
     */
    risk: number;
    /**
     * @generated from protobuf field: int32 entity_id = 2;
     */
    entityId: number;
}
/**
 * @generated from protobuf message eq.AdventureRequestResponse
 */
export interface AdventureRequestResponse {
    /**
     * @generated from protobuf field: string text = 1;
     */
    text: string;
    /**
     * @generated from protobuf field: int32 timetoenter = 2;
     */
    timetoenter: number;
    /**
     * @generated from protobuf field: int32 timeleft = 3;
     */
    timeleft: number;
    /**
     * @generated from protobuf field: int32 risk = 4;
     */
    risk: number;
    /**
     * @generated from protobuf field: float x = 5;
     */
    x: number;
    /**
     * @generated from protobuf field: float y = 6;
     */
    y: number;
    /**
     * @generated from protobuf field: float z = 7;
     */
    z: number;
    /**
     * @generated from protobuf field: int32 showcompass = 8;
     */
    showcompass: number;
}
/**
 * @generated from protobuf message eq.Illusion
 */
export interface Illusion {
    /**
     * @generated from protobuf field: int32 spawnid = 1;
     */
    spawnid: number;
    /**
     * @generated from protobuf field: string charname = 2;
     */
    charname: string;
    /**
     * @generated from protobuf field: int32 race = 3;
     */
    race: number;
    /**
     * @generated from protobuf field: int32 gender = 4;
     */
    gender: number;
    /**
     * @generated from protobuf field: int32 texture = 5;
     */
    texture: number;
    /**
     * @generated from protobuf field: int32 helmtexture = 6;
     */
    helmtexture: number;
    /**
     * @generated from protobuf field: int32 face = 7;
     */
    face: number;
    /**
     * @generated from protobuf field: int32 hairstyle = 8;
     */
    hairstyle: number;
    /**
     * @generated from protobuf field: int32 haircolor = 9;
     */
    haircolor: number;
    /**
     * @generated from protobuf field: int32 beard = 10;
     */
    beard: number;
    /**
     * @generated from protobuf field: int32 beardcolor = 11;
     */
    beardcolor: number;
    /**
     * @generated from protobuf field: float size = 12;
     */
    size: number;
}
/**
 * @generated from protobuf message eq.ZonePoint_Entry
 */
export interface ZonePoint_Entry {
    /**
     * @generated from protobuf field: int32 iterator = 1;
     */
    iterator: number;
    /**
     * @generated from protobuf field: float y = 2;
     */
    y: number;
    /**
     * @generated from protobuf field: float x = 3;
     */
    x: number;
    /**
     * @generated from protobuf field: float z = 4;
     */
    z: number;
    /**
     * @generated from protobuf field: float heading = 5;
     */
    heading: number;
    /**
     * @generated from protobuf field: int32 zoneid = 6;
     */
    zoneid: number;
    /**
     * @generated from protobuf field: int32 zoneinstance = 7;
     */
    zoneinstance: number;
}
/**
 * @generated from protobuf message eq.ZonePoints
 */
export interface ZonePoints {
    /**
     * @generated from protobuf field: int32 count = 1;
     */
    count: number;
    /**
     * @generated from protobuf field: repeated eq.ZonePoint_Entry zpe = 2;
     */
    zpe: ZonePoint_Entry[];
}
/**
 * @generated from protobuf message eq.SkillUpdate
 */
export interface SkillUpdate {
    /**
     * @generated from protobuf field: int32 skill_id = 1;
     */
    skillId: number;
    /**
     * @generated from protobuf field: int32 value = 2;
     */
    value: number;
}
/**
 * @generated from protobuf message eq.ZoneUnavail
 */
export interface ZoneUnavail {
    /**
     * @generated from protobuf field: string zonename = 1;
     */
    zonename: string;
}
/**
 * @generated from protobuf message eq.GroupGeneric
 */
export interface GroupGeneric {
    /**
     * @generated from protobuf field: string name1 = 1;
     */
    name1: string;
    /**
     * @generated from protobuf field: string name2 = 2;
     */
    name2: string;
}
/**
 * @generated from protobuf message eq.GroupCancel
 */
export interface GroupCancel {
    /**
     * @generated from protobuf field: string name1 = 1;
     */
    name1: string;
    /**
     * @generated from protobuf field: string name2 = 2;
     */
    name2: string;
    /**
     * @generated from protobuf field: int32 toggle = 3;
     */
    toggle: number;
}
/**
 * @generated from protobuf message eq.GroupUpdate
 */
export interface GroupUpdate {
    /**
     * @generated from protobuf field: int32 action = 1;
     */
    action: number;
    /**
     * @generated from protobuf field: string yourname = 2;
     */
    yourname: string;
    /**
     * @generated from protobuf field: repeated eq.StringList membername = 3;
     */
    membername: StringList[];
    /**
     * @generated from protobuf field: string leadersname = 4;
     */
    leadersname: string;
}
/**
 * @generated from protobuf message eq.GroupUpdate2
 */
export interface GroupUpdate2 {
    /**
     * @generated from protobuf field: int32 action = 1;
     */
    action: number;
    /**
     * @generated from protobuf field: string yourname = 2;
     */
    yourname: string;
    /**
     * @generated from protobuf field: repeated eq.StringList membername = 3;
     */
    membername: StringList[];
    /**
     * @generated from protobuf field: string leadersname = 4;
     */
    leadersname: string;
    /**
     * @generated from protobuf field: eq.GroupLeadershipAA leader_aas = 5;
     */
    leaderAas?: GroupLeadershipAA;
}
/**
 * @generated from protobuf message eq.GroupJoin
 */
export interface GroupJoin {
    /**
     * @generated from protobuf field: int32 action = 1;
     */
    action: number;
    /**
     * @generated from protobuf field: string yourname = 2;
     */
    yourname: string;
    /**
     * @generated from protobuf field: string membername = 3;
     */
    membername: string;
}
/**
 * @generated from protobuf message eq.FaceChange
 */
export interface FaceChange {
    /**
     * @generated from protobuf field: int32 haircolor = 1;
     */
    haircolor: number;
    /**
     * @generated from protobuf field: int32 beardcolor = 2;
     */
    beardcolor: number;
    /**
     * @generated from protobuf field: int32 eyecolor1 = 3;
     */
    eyecolor1: number;
    /**
     * @generated from protobuf field: int32 eyecolor2 = 4;
     */
    eyecolor2: number;
    /**
     * @generated from protobuf field: int32 hairstyle = 5;
     */
    hairstyle: number;
    /**
     * @generated from protobuf field: int32 beard = 6;
     */
    beard: number;
    /**
     * @generated from protobuf field: int32 face = 7;
     */
    face: number;
}
/**
 * @generated from protobuf message eq.TradeRequest
 */
export interface TradeRequest {
    /**
     * @generated from protobuf field: int32 to_mob_id = 1;
     */
    toMobId: number;
    /**
     * @generated from protobuf field: int32 from_mob_id = 2;
     */
    fromMobId: number;
}
/**
 * @generated from protobuf message eq.TradeAccept
 */
export interface TradeAccept {
    /**
     * @generated from protobuf field: int32 from_mob_id = 1;
     */
    fromMobId: number;
}
/**
 * @generated from protobuf message eq.CancelTrade
 */
export interface CancelTrade {
    /**
     * @generated from protobuf field: int32 fromid = 1;
     */
    fromid: number;
    /**
     * @generated from protobuf field: int32 action = 2;
     */
    action: number;
}
/**
 * @generated from protobuf message eq.PetitionUpdate
 */
export interface PetitionUpdate {
    /**
     * @generated from protobuf field: int32 petnumber = 1;
     */
    petnumber: number;
    /**
     * @generated from protobuf field: int32 color = 2;
     */
    color: number;
    /**
     * @generated from protobuf field: int32 status = 3;
     */
    status: number;
    /**
     * @generated from protobuf field: int32 senttime = 4;
     */
    senttime: number;
    /**
     * @generated from protobuf field: string accountid = 5;
     */
    accountid: string;
    /**
     * @generated from protobuf field: string gmsenttoo = 6;
     */
    gmsenttoo: string;
    /**
     * @generated from protobuf field: int32 quetotal = 7;
     */
    quetotal: number;
    /**
     * @generated from protobuf field: string charname = 8;
     */
    charname: string;
}
/**
 * @generated from protobuf message eq.Petition
 */
export interface Petition {
    /**
     * @generated from protobuf field: int32 petnumber = 1;
     */
    petnumber: number;
    /**
     * @generated from protobuf field: int32 urgency = 2;
     */
    urgency: number;
    /**
     * @generated from protobuf field: string accountid = 3;
     */
    accountid: string;
    /**
     * @generated from protobuf field: string lastgm = 4;
     */
    lastgm: string;
    /**
     * @generated from protobuf field: int32 zone = 5;
     */
    zone: number;
    /**
     * @generated from protobuf field: string charname = 6;
     */
    charname: string;
    /**
     * @generated from protobuf field: int32 charlevel = 7;
     */
    charlevel: number;
    /**
     * @generated from protobuf field: int32 charclass = 8;
     */
    charclass: number;
    /**
     * @generated from protobuf field: int32 charrace = 9;
     */
    charrace: number;
    /**
     * @generated from protobuf field: int32 checkouts = 10;
     */
    checkouts: number;
    /**
     * @generated from protobuf field: int32 unavail = 11;
     */
    unavail: number;
    /**
     * @generated from protobuf field: int32 senttime = 12;
     */
    senttime: number;
    /**
     * @generated from protobuf field: string petitiontext = 13;
     */
    petitiontext: string;
    /**
     * @generated from protobuf field: string gmtext = 14;
     */
    gmtext: string;
}
/**
 * @generated from protobuf message eq.Who_All
 */
export interface Who_All {
    /**
     * @generated from protobuf field: string whom = 1;
     */
    whom: string;
    /**
     * @generated from protobuf field: int32 wrace = 2;
     */
    wrace: number;
    /**
     * @generated from protobuf field: int32 wclass = 3;
     */
    wclass: number;
    /**
     * @generated from protobuf field: int32 lvllow = 4;
     */
    lvllow: number;
    /**
     * @generated from protobuf field: int32 lvlhigh = 5;
     */
    lvlhigh: number;
    /**
     * @generated from protobuf field: int32 gmlookup = 6;
     */
    gmlookup: number;
}
/**
 * @generated from protobuf message eq.Stun
 */
export interface Stun {
    /**
     * @generated from protobuf field: int32 duration = 1;
     */
    duration: number;
}
/**
 * @generated from protobuf message eq.AugmentItem
 */
export interface AugmentItem {
    /**
     * @generated from protobuf field: int32 container_slot = 1;
     */
    containerSlot: number;
    /**
     * @generated from protobuf field: int32 augment_slot = 2;
     */
    augmentSlot: number;
}
/**
 * @generated from protobuf message eq.Emote
 */
export interface Emote {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
}
/**
 * @generated from protobuf message eq.Inspect
 */
export interface Inspect {
    /**
     * @generated from protobuf field: int32 target_id = 1;
     */
    targetId: number;
    /**
     * @generated from protobuf field: int32 player_id = 2;
     */
    playerId: number;
}
/**
 * @generated from protobuf message eq.InspectResponse
 */
export interface InspectResponse {
    /**
     * @generated from protobuf field: int32 target_id = 1;
     */
    targetId: number;
    /**
     * @generated from protobuf field: int32 playerid = 2;
     */
    playerid: number;
    /**
     * @generated from protobuf field: repeated eq.StringList itemnames = 3;
     */
    itemnames: StringList[];
    /**
     * @generated from protobuf field: repeated int32 itemicons = 4;
     */
    itemicons: number[];
    /**
     * @generated from protobuf field: string text = 5;
     */
    text: string;
}
/**
 * @generated from protobuf message eq.SetDataRate
 */
export interface SetDataRate {
    /**
     * @generated from protobuf field: float newdatarate = 1;
     */
    newdatarate: number;
}
/**
 * @generated from protobuf message eq.SetServerFilter
 */
export interface SetServerFilter {
    /**
     * @generated from protobuf field: repeated int32 filters = 1;
     */
    filters: number[];
}
/**
 * @generated from protobuf message eq.SetServerFilterAck
 */
export interface SetServerFilterAck {
    /**
     * @generated from protobuf field: repeated int32 blank = 1;
     */
    blank: number[];
}
/**
 * @generated from protobuf message eq.IncreaseStat
 */
export interface IncreaseStat {
    /**
     * @generated from protobuf field: int32 str = 1;
     */
    str: number;
    /**
     * @generated from protobuf field: int32 sta = 2;
     */
    sta: number;
    /**
     * @generated from protobuf field: int32 agi = 3;
     */
    agi: number;
    /**
     * @generated from protobuf field: int32 dex = 4;
     */
    dex: number;
    /**
     * @generated from protobuf field: int32 int_ = 5;
     */
    int: number;
    /**
     * @generated from protobuf field: int32 wis = 6;
     */
    wis: number;
    /**
     * @generated from protobuf field: int32 cha = 7;
     */
    cha: number;
    /**
     * @generated from protobuf field: int32 fire = 8;
     */
    fire: number;
    /**
     * @generated from protobuf field: int32 cold = 9;
     */
    cold: number;
    /**
     * @generated from protobuf field: int32 magic = 10;
     */
    magic: number;
    /**
     * @generated from protobuf field: int32 poison = 11;
     */
    poison: number;
    /**
     * @generated from protobuf field: int32 disease = 12;
     */
    disease: number;
    /**
     * @generated from protobuf field: int32 str2 = 13;
     */
    str2: number;
    /**
     * @generated from protobuf field: int32 sta2 = 14;
     */
    sta2: number;
    /**
     * @generated from protobuf field: int32 agi2 = 15;
     */
    agi2: number;
    /**
     * @generated from protobuf field: int32 dex2 = 16;
     */
    dex2: number;
    /**
     * @generated from protobuf field: int32 int2_ = 17;
     */
    int2: number;
    /**
     * @generated from protobuf field: int32 wis2 = 18;
     */
    wis2: number;
    /**
     * @generated from protobuf field: int32 cha2 = 19;
     */
    cha2: number;
    /**
     * @generated from protobuf field: int32 fire2 = 20;
     */
    fire2: number;
    /**
     * @generated from protobuf field: int32 cold2 = 21;
     */
    cold2: number;
    /**
     * @generated from protobuf field: int32 magic2 = 22;
     */
    magic2: number;
    /**
     * @generated from protobuf field: int32 poison2 = 23;
     */
    poison2: number;
    /**
     * @generated from protobuf field: int32 disease2 = 24;
     */
    disease2: number;
}
/**
 * @generated from protobuf message eq.GMName
 */
export interface GMName {
    /**
     * @generated from protobuf field: string oldname = 1;
     */
    oldname: string;
    /**
     * @generated from protobuf field: string gmname = 2;
     */
    gmname: string;
    /**
     * @generated from protobuf field: string newname = 3;
     */
    newname: string;
    /**
     * @generated from protobuf field: int32 badname = 4;
     */
    badname: number;
}
/**
 * @generated from protobuf message eq.GMDelCorpse
 */
export interface GMDelCorpse {
    /**
     * @generated from protobuf field: string corpsename = 1;
     */
    corpsename: string;
    /**
     * @generated from protobuf field: string gmname = 2;
     */
    gmname: string;
}
/**
 * @generated from protobuf message eq.GMKick
 */
export interface GMKick {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string gmname = 2;
     */
    gmname: string;
}
/**
 * @generated from protobuf message eq.GMKill
 */
export interface GMKill {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string gmname = 2;
     */
    gmname: string;
}
/**
 * @generated from protobuf message eq.GMEmoteZone
 */
export interface GMEmoteZone {
    /**
     * @generated from protobuf field: string text = 1;
     */
    text: string;
}
/**
 * @generated from protobuf message eq.BookText
 */
export interface BookText {
    /**
     * @generated from protobuf field: int32 window = 1;
     */
    window: number;
    /**
     * @generated from protobuf field: int32 type = 2;
     */
    type: number;
    /**
     * @generated from protobuf field: string booktext = 3;
     */
    booktext: string;
}
/**
 * @generated from protobuf message eq.BookRequest
 */
export interface BookRequest {
    /**
     * @generated from protobuf field: int32 window = 1;
     */
    window: number;
    /**
     * @generated from protobuf field: int32 type = 2;
     */
    type: number;
    /**
     * @generated from protobuf field: string txtfile = 3;
     */
    txtfile: string;
}
/**
 * @generated from protobuf message eq.Object
 */
export interface Object {
    /**
     * @generated from protobuf field: repeated int32 linked_list_addr = 1;
     */
    linkedListAddr: number[];
    /**
     * @generated from protobuf field: int32 drop_id = 2;
     */
    dropId: number;
    /**
     * @generated from protobuf field: int32 zone_id = 3;
     */
    zoneId: number;
    /**
     * @generated from protobuf field: int32 zone_instance = 4;
     */
    zoneInstance: number;
    /**
     * @generated from protobuf field: float heading = 5;
     */
    heading: number;
    /**
     * @generated from protobuf field: float z = 6;
     */
    z: number;
    /**
     * @generated from protobuf field: float x = 7;
     */
    x: number;
    /**
     * @generated from protobuf field: float y = 8;
     */
    y: number;
    /**
     * @generated from protobuf field: string object_name = 9;
     */
    objectName: string;
    /**
     * @generated from protobuf field: int32 object_type = 10;
     */
    objectType: number;
    /**
     * @generated from protobuf field: int32 spawn_id = 11;
     */
    spawnId: number;
}
/**
 * @generated from protobuf message eq.ClickObject
 */
export interface ClickObject {
    /**
     * @generated from protobuf field: int32 drop_id = 1;
     */
    dropId: number;
    /**
     * @generated from protobuf field: int32 player_id = 2;
     */
    playerId: number;
}
/**
 * @generated from protobuf message eq.ClickObjectAction
 */
export interface ClickObjectAction {
    /**
     * @generated from protobuf field: int32 player_id = 1;
     */
    playerId: number;
    /**
     * @generated from protobuf field: int32 drop_id = 2;
     */
    dropId: number;
    /**
     * @generated from protobuf field: int32 open = 3;
     */
    open: number;
    /**
     * @generated from protobuf field: int32 type = 4;
     */
    type: number;
    /**
     * @generated from protobuf field: int32 icon = 5;
     */
    icon: number;
    /**
     * @generated from protobuf field: string object_name = 6;
     */
    objectName: string;
}
/**
 * @generated from protobuf message eq.Shielding
 */
export interface Shielding {
    /**
     * @generated from protobuf field: int32 target_id = 1;
     */
    targetId: number;
}
/**
 * @generated from protobuf message eq.ClickObjectAck
 */
export interface ClickObjectAck {
    /**
     * @generated from protobuf field: int32 player_id = 1;
     */
    playerId: number;
    /**
     * @generated from protobuf field: int32 drop_id = 2;
     */
    dropId: number;
    /**
     * @generated from protobuf field: int32 open = 3;
     */
    open: number;
    /**
     * @generated from protobuf field: int32 type = 4;
     */
    type: number;
    /**
     * @generated from protobuf field: int32 icon = 5;
     */
    icon: number;
    /**
     * @generated from protobuf field: string object_name = 6;
     */
    objectName: string;
}
/**
 * @generated from protobuf message eq.CloseContainer
 */
export interface CloseContainer {
    /**
     * @generated from protobuf field: int32 player_id = 1;
     */
    playerId: number;
    /**
     * @generated from protobuf field: int32 drop_id = 2;
     */
    dropId: number;
    /**
     * @generated from protobuf field: int32 open = 3;
     */
    open: number;
}
/**
 * @generated from protobuf message eq.Door
 */
export interface Door {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: float y_pos = 2;
     */
    yPos: number;
    /**
     * @generated from protobuf field: float x_pos = 3;
     */
    xPos: number;
    /**
     * @generated from protobuf field: float z_pos = 4;
     */
    zPos: number;
    /**
     * @generated from protobuf field: float heading = 5;
     */
    heading: number;
    /**
     * @generated from protobuf field: int32 incline = 6;
     */
    incline: number;
    /**
     * @generated from protobuf field: int32 size = 7;
     */
    size: number;
    /**
     * @generated from protobuf field: int32 door_id = 8;
     */
    doorId: number;
    /**
     * @generated from protobuf field: int32 opentype = 9;
     */
    opentype: number;
    /**
     * @generated from protobuf field: int32 state_at_spawn = 10;
     */
    stateAtSpawn: number;
    /**
     * @generated from protobuf field: int32 invert_state = 11;
     */
    invertState: number;
    /**
     * @generated from protobuf field: int32 door_param = 12;
     */
    doorParam: number;
}
/**
 * @generated from protobuf message eq.DoorSpawns
 */
export interface DoorSpawns {
    /**
     * @generated from protobuf field: int32 count = 1;
     */
    count: number;
    /**
     * @generated from protobuf field: repeated eq.Door doors = 2;
     */
    doors: Door[];
}
/**
 * @generated from protobuf message eq.ClickDoor
 */
export interface ClickDoor {
    /**
     * @generated from protobuf field: int32 doorid = 1;
     */
    doorid: number;
    /**
     * @generated from protobuf field: int32 picklockskill = 2;
     */
    picklockskill: number;
    /**
     * @generated from protobuf field: int32 item_id = 3;
     */
    itemId: number;
    /**
     * @generated from protobuf field: int32 player_id = 4;
     */
    playerId: number;
}
/**
 * @generated from protobuf message eq.MoveDoor
 */
export interface MoveDoor {
    /**
     * @generated from protobuf field: int32 doorid = 1;
     */
    doorid: number;
    /**
     * @generated from protobuf field: int32 action = 2;
     */
    action: number;
}
/**
 * @generated from protobuf message eq.ControlBoat
 */
export interface ControlBoat {
    /**
     * @generated from protobuf field: int32 boat_id = 1;
     */
    boatId: number;
    /**
     * @generated from protobuf field: bool take_control = 2;
     */
    takeControl: boolean;
}
/**
 * @generated from protobuf message eq.BecomeNPC
 */
export interface BecomeNPC {
    /**
     * @generated from protobuf field: int32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: int32 maxlevel = 2;
     */
    maxlevel: number;
}
/**
 * @generated from protobuf message eq.Underworld
 */
export interface Underworld {
    /**
     * @generated from protobuf field: float speed = 1;
     */
    speed: number;
    /**
     * @generated from protobuf field: float y = 2;
     */
    y: number;
    /**
     * @generated from protobuf field: float x = 3;
     */
    x: number;
    /**
     * @generated from protobuf field: float z = 4;
     */
    z: number;
}
/**
 * @generated from protobuf message eq.Resurrect
 */
export interface Resurrect {
    /**
     * @generated from protobuf field: int32 zone_id = 1;
     */
    zoneId: number;
    /**
     * @generated from protobuf field: int32 instance_id = 2;
     */
    instanceId: number;
    /**
     * @generated from protobuf field: float y = 3;
     */
    y: number;
    /**
     * @generated from protobuf field: float x = 4;
     */
    x: number;
    /**
     * @generated from protobuf field: float z = 5;
     */
    z: number;
    /**
     * @generated from protobuf field: string your_name = 6;
     */
    yourName: string;
    /**
     * @generated from protobuf field: string rezzer_name = 7;
     */
    rezzerName: string;
    /**
     * @generated from protobuf field: int32 spellid = 8;
     */
    spellid: number;
    /**
     * @generated from protobuf field: string corpse_name = 9;
     */
    corpseName: string;
    /**
     * @generated from protobuf field: int32 action = 10;
     */
    action: number;
}
/**
 * @generated from protobuf message eq.SetRunMode
 */
export interface SetRunMode {
    /**
     * @generated from protobuf field: int32 mode = 1;
     */
    mode: number;
}
/**
 * @generated from protobuf message eq.EnvDamage2
 */
export interface EnvDamage2 {
    /**
     * @generated from protobuf field: int32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: int32 damage = 2;
     */
    damage: number;
    /**
     * @generated from protobuf field: int32 dmgtype = 3;
     */
    dmgtype: number;
    /**
     * @generated from protobuf field: int32 constant = 4;
     */
    constant: number;
}
/**
 * @generated from protobuf message eq.BazaarWindowStart
 */
export interface BazaarWindowStart {
    /**
     * @generated from protobuf field: int32 action = 1;
     */
    action: number;
}
/**
 * @generated from protobuf message eq.BazaarWelcome
 */
export interface BazaarWelcome {
    /**
     * @generated from protobuf field: eq.BazaarWindowStart beginning = 1;
     */
    beginning?: BazaarWindowStart;
    /**
     * @generated from protobuf field: int32 traders = 2;
     */
    traders: number;
    /**
     * @generated from protobuf field: int32 items = 3;
     */
    items: number;
}
/**
 * @generated from protobuf message eq.BazaarSearch
 */
export interface BazaarSearch {
    /**
     * @generated from protobuf field: eq.BazaarWindowStart beginning = 1;
     */
    beginning?: BazaarWindowStart;
    /**
     * @generated from protobuf field: int32 traderid = 2;
     */
    traderid: number;
    /**
     * @generated from protobuf field: int32 char_class = 3;
     */
    charClass: number;
    /**
     * @generated from protobuf field: int32 race = 4;
     */
    race: number;
    /**
     * @generated from protobuf field: int32 stat = 5;
     */
    stat: number;
    /**
     * @generated from protobuf field: int32 slot = 6;
     */
    slot: number;
    /**
     * @generated from protobuf field: int32 type = 7;
     */
    type: number;
    /**
     * @generated from protobuf field: string name = 8;
     */
    name: string;
    /**
     * @generated from protobuf field: int32 minprice = 9;
     */
    minprice: number;
    /**
     * @generated from protobuf field: int32 maxprice = 10;
     */
    maxprice: number;
    /**
     * @generated from protobuf field: int32 minlevel = 11;
     */
    minlevel: number;
    /**
     * @generated from protobuf field: int32 maxlevel = 12;
     */
    maxlevel: number;
}
/**
 * @generated from protobuf message eq.BazaarInspect
 */
export interface BazaarInspect {
    /**
     * @generated from protobuf field: int32 item_id = 1;
     */
    itemId: number;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
}
/**
 * @generated from protobuf message eq.BazaarReturnDone
 */
export interface BazaarReturnDone {
    /**
     * @generated from protobuf field: int32 type = 1;
     */
    type: number;
    /**
     * @generated from protobuf field: int32 traderid = 2;
     */
    traderid: number;
}
/**
 * @generated from protobuf message eq.BazaarSearchResults
 */
export interface BazaarSearchResults {
    /**
     * @generated from protobuf field: eq.BazaarWindowStart beginning = 1;
     */
    beginning?: BazaarWindowStart;
    /**
     * @generated from protobuf field: int32 seller_id = 2;
     */
    sellerId: number;
    /**
     * @generated from protobuf field: int32 num_items = 3;
     */
    numItems: number;
    /**
     * @generated from protobuf field: int32 serial_number = 4;
     */
    serialNumber: number;
    /**
     * @generated from protobuf field: string item_name = 5;
     */
    itemName: string;
    /**
     * @generated from protobuf field: int32 cost = 6;
     */
    cost: number;
    /**
     * @generated from protobuf field: int32 item_stat = 7;
     */
    itemStat: number;
}
/**
 * @generated from protobuf message eq.ServerSideFilters
 */
export interface ServerSideFilters {
    /**
     * @generated from protobuf field: int32 clientattackfilters = 1;
     */
    clientattackfilters: number;
    /**
     * @generated from protobuf field: int32 npcattackfilters = 2;
     */
    npcattackfilters: number;
    /**
     * @generated from protobuf field: int32 clientcastfilters = 3;
     */
    clientcastfilters: number;
    /**
     * @generated from protobuf field: int32 npccastfilters = 4;
     */
    npccastfilters: number;
}
/**
 * @generated from protobuf message eq.ItemViewRequest
 */
export interface ItemViewRequest {
    /**
     * @generated from protobuf field: int32 item_id = 1;
     */
    itemId: number;
    /**
     * @generated from protobuf field: repeated int32 augments = 2;
     */
    augments: number[];
    /**
     * @generated from protobuf field: int32 link_hash = 3;
     */
    linkHash: number;
}
/**
 * @generated from protobuf message eq.ItemVerifyRequest
 */
export interface ItemVerifyRequest {
    /**
     * @generated from protobuf field: int32 slot = 1;
     */
    slot: number;
    /**
     * @generated from protobuf field: int32 target = 2;
     */
    target: number;
}
/**
 * @generated from protobuf message eq.PickPocket
 */
export interface PickPocket {
    /**
     * @generated from protobuf field: int32 to = 1;
     */
    to: number;
    /**
     * @generated from protobuf field: int32 from = 2;
     */
    from: number;
    /**
     * @generated from protobuf field: int32 myskill = 3;
     */
    myskill: number;
    /**
     * @generated from protobuf field: int32 type = 4;
     */
    type: number;
    /**
     * @generated from protobuf field: int32 coin = 5;
     */
    coin: number;
    /**
     * @generated from protobuf field: repeated int32 lastsix = 6;
     */
    lastsix: number[];
}
/**
 * @generated from protobuf message eq.sPickPocket
 */
export interface sPickPocket {
    /**
     * @generated from protobuf field: int32 to = 1;
     */
    to: number;
    /**
     * @generated from protobuf field: int32 from = 2;
     */
    from: number;
    /**
     * @generated from protobuf field: int32 myskill = 3;
     */
    myskill: number;
    /**
     * @generated from protobuf field: int32 type = 4;
     */
    type: number;
    /**
     * @generated from protobuf field: int32 coin = 5;
     */
    coin: number;
    /**
     * @generated from protobuf field: string itemname = 6;
     */
    itemname: string;
}
/**
 * @generated from protobuf message eq.LogServer
 */
export interface LogServer {
    /**
     * @generated from protobuf field: string worldshortname = 1;
     */
    worldshortname: string;
}
/**
 * @generated from protobuf message eq.ApproveWorld
 */
export interface ApproveWorld {
}
/**
 * @generated from protobuf message eq.ClientError
 */
export interface ClientError {
    /**
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * @generated from protobuf field: string character_name = 2;
     */
    characterName: string;
    /**
     * @generated from protobuf field: string message = 3;
     */
    message: string;
}
/**
 * @generated from protobuf message eq.MobHealth
 */
export interface MobHealth {
    /**
     * @generated from protobuf field: int32 hp = 1;
     */
    hp: number;
    /**
     * @generated from protobuf field: int32 id = 2;
     */
    id: number;
}
/**
 * @generated from protobuf message eq.Track
 */
export interface Track {
    /**
     * @generated from protobuf field: int32 entityid = 1;
     */
    entityid: number;
    /**
     * @generated from protobuf field: float distance = 2;
     */
    distance: number;
}
/**
 * @generated from protobuf message eq.TrackTarget
 */
export interface TrackTarget {
    /**
     * @generated from protobuf field: int32 entityid = 1;
     */
    entityid: number;
}
/**
 * @generated from protobuf message eq.Tracking
 */
export interface Tracking {
    /**
     * @generated from protobuf field: int32 count = 1;
     */
    count: number;
    /**
     * @generated from protobuf field: repeated eq.Track entries = 2;
     */
    entries: Track[];
}
/**
 * @generated from protobuf message eq.ZoneServerInfo
 */
export interface ZoneServerInfo {
    /**
     * @generated from protobuf field: string ip = 1;
     */
    ip: string;
    /**
     * @generated from protobuf field: int32 port = 2;
     */
    port: number;
}
/**
 * @generated from protobuf message eq.WhoAllPlayer
 */
export interface WhoAllPlayer {
    /**
     * @generated from protobuf field: int32 formatstring = 1;
     */
    formatstring: number;
    /**
     * @generated from protobuf field: int32 pidstring = 2;
     */
    pidstring: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: int32 rankstring = 4;
     */
    rankstring: number;
    /**
     * @generated from protobuf field: string guild = 5;
     */
    guild: string;
    /**
     * @generated from protobuf field: int32 zonestring = 6;
     */
    zonestring: number;
    /**
     * @generated from protobuf field: int32 zone = 7;
     */
    zone: number;
    /**
     * @generated from protobuf field: int32 char_class = 8;
     */
    charClass: number;
    /**
     * @generated from protobuf field: int32 level = 9;
     */
    level: number;
    /**
     * @generated from protobuf field: int32 race = 10;
     */
    race: number;
    /**
     * @generated from protobuf field: string account = 11;
     */
    account: string;
}
/**
 * @generated from protobuf message eq.WhoAllReturn
 */
export interface WhoAllReturn {
    /**
     * @generated from protobuf field: int32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: int32 playerineqstring = 2;
     */
    playerineqstring: number;
    /**
     * @generated from protobuf field: string line = 3;
     */
    line: string;
    /**
     * @generated from protobuf field: int32 playersinzonestring = 4;
     */
    playersinzonestring: number;
    /**
     * @generated from protobuf field: int32 count = 5;
     */
    count: number;
    /**
     * @generated from protobuf field: repeated eq.WhoAllPlayer player = 6;
     */
    player: WhoAllPlayer[];
}
/**
 * @generated from protobuf message eq.Trader
 */
export interface Trader {
    /**
     * @generated from protobuf field: int32 code = 1;
     */
    code: number;
    /**
     * @generated from protobuf field: repeated int32 itemid = 2;
     */
    itemid: number[];
    /**
     * @generated from protobuf field: repeated int32 itemcost = 3;
     */
    itemcost: number[];
}
/**
 * @generated from protobuf message eq.ClickTrader
 */
export interface ClickTrader {
    /**
     * @generated from protobuf field: int32 code = 1;
     */
    code: number;
    /**
     * @generated from protobuf field: repeated int32 itemcost = 2;
     */
    itemcost: number[];
}
/**
 * @generated from protobuf message eq.GetItems
 */
export interface GetItems {
    /**
     * @generated from protobuf field: repeated int32 items = 1;
     */
    items: number[];
}
/**
 * @generated from protobuf message eq.BecomeTrader
 */
export interface BecomeTrader {
    /**
     * @generated from protobuf field: int32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message eq.Trader_ShowItems
 */
export interface Trader_ShowItems {
    /**
     * @generated from protobuf field: int32 code = 1;
     */
    code: number;
    /**
     * @generated from protobuf field: int32 trader_id = 2;
     */
    traderId: number;
}
/**
 * @generated from protobuf message eq.TraderBuy
 */
export interface TraderBuy {
    /**
     * @generated from protobuf field: int32 action = 1;
     */
    action: number;
    /**
     * @generated from protobuf field: int32 price = 2;
     */
    price: number;
    /**
     * @generated from protobuf field: int32 trader_id = 3;
     */
    traderId: number;
    /**
     * @generated from protobuf field: string item_name = 4;
     */
    itemName: string;
    /**
     * @generated from protobuf field: int32 item_id = 5;
     */
    itemId: number;
    /**
     * @generated from protobuf field: int32 already_sold = 6;
     */
    alreadySold: number;
    /**
     * @generated from protobuf field: int32 quantity = 7;
     */
    quantity: number;
}
/**
 * @generated from protobuf message eq.TraderItemUpdate
 */
export interface TraderItemUpdate {
    /**
     * @generated from protobuf field: int32 traderid = 1;
     */
    traderid: number;
    /**
     * @generated from protobuf field: int32 fromslot = 2;
     */
    fromslot: number;
    /**
     * @generated from protobuf field: int32 toslot = 3;
     */
    toslot: number;
    /**
     * @generated from protobuf field: int32 charges = 4;
     */
    charges: number;
}
/**
 * @generated from protobuf message eq.MoneyUpdate
 */
export interface MoneyUpdate {
    /**
     * @generated from protobuf field: int32 platinum = 1;
     */
    platinum: number;
    /**
     * @generated from protobuf field: int32 gold = 2;
     */
    gold: number;
    /**
     * @generated from protobuf field: int32 silver = 3;
     */
    silver: number;
    /**
     * @generated from protobuf field: int32 copper = 4;
     */
    copper: number;
}
/**
 * @generated from protobuf message eq.TraderDelItem
 */
export interface TraderDelItem {
    /**
     * @generated from protobuf field: int32 slotid = 1;
     */
    slotid: number;
    /**
     * @generated from protobuf field: int32 quantity = 2;
     */
    quantity: number;
}
/**
 * @generated from protobuf message eq.TraderClick
 */
export interface TraderClick {
    /**
     * @generated from protobuf field: int32 traderid = 1;
     */
    traderid: number;
    /**
     * @generated from protobuf field: int32 approval = 2;
     */
    approval: number;
}
/**
 * @generated from protobuf message eq.FormattedMessage
 */
export interface FormattedMessage {
    /**
     * @generated from protobuf field: int32 string_id = 1;
     */
    stringId: number;
    /**
     * @generated from protobuf field: int32 type = 2;
     */
    type: number;
    /**
     * @generated from protobuf field: string message = 3;
     */
    message: string;
}
/**
 * @generated from protobuf message eq.SimpleMessage
 */
export interface SimpleMessage {
    /**
     * @generated from protobuf field: int32 string_id = 1;
     */
    stringId: number;
    /**
     * @generated from protobuf field: int32 color = 2;
     */
    color: number;
}
/**
 * @generated from protobuf message eq.GuildMemberEntry
 */
export interface GuildMemberEntry {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: int32 level = 2;
     */
    level: number;
    /**
     * @generated from protobuf field: int32 banker = 3;
     */
    banker: number;
    /**
     * @generated from protobuf field: int32 char_class = 4;
     */
    charClass: number;
    /**
     * @generated from protobuf field: int32 rank = 5;
     */
    rank: number;
    /**
     * @generated from protobuf field: int32 time_last_on = 6;
     */
    timeLastOn: number;
    /**
     * @generated from protobuf field: int32 tribute_enable = 7;
     */
    tributeEnable: number;
    /**
     * @generated from protobuf field: int32 total_tribute = 8;
     */
    totalTribute: number;
    /**
     * @generated from protobuf field: int32 last_tribute = 9;
     */
    lastTribute: number;
    /**
     * @generated from protobuf field: string public_note = 10;
     */
    publicNote: string;
    /**
     * @generated from protobuf field: int32 zoneinstance = 11;
     */
    zoneinstance: number;
    /**
     * @generated from protobuf field: int32 zone_id = 12;
     */
    zoneId: number;
}
/**
 * @generated from protobuf message eq.GuildMembers
 */
export interface GuildMembers {
    /**
     * @generated from protobuf field: string player_name = 1;
     */
    playerName: string;
    /**
     * @generated from protobuf field: int32 count = 2;
     */
    count: number;
    /**
     * @generated from protobuf field: repeated eq.GuildMemberEntry member = 3;
     */
    member: GuildMemberEntry[];
}
/**
 * @generated from protobuf message eq.GuildMOTD
 */
export interface GuildMOTD {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string setby_name = 2;
     */
    setbyName: string;
    /**
     * @generated from protobuf field: string motd = 3;
     */
    motd: string;
}
/**
 * @generated from protobuf message eq.GuildUpdate_PublicNote
 */
export interface GuildUpdate_PublicNote {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string target = 2;
     */
    target: string;
    /**
     * @generated from protobuf field: string note = 3;
     */
    note: string;
}
/**
 * @generated from protobuf message eq.GuildDemote
 */
export interface GuildDemote {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string target = 2;
     */
    target: string;
}
/**
 * @generated from protobuf message eq.GuildRemove
 */
export interface GuildRemove {
    /**
     * @generated from protobuf field: string target = 1;
     */
    target: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: int32 leaderstatus = 3;
     */
    leaderstatus: number;
}
/**
 * @generated from protobuf message eq.GuildMakeLeader
 */
export interface GuildMakeLeader {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string target = 2;
     */
    target: string;
}
/**
 * @generated from protobuf message eq.Make_Pet
 */
export interface Make_Pet {
    /**
     * @generated from protobuf field: int32 level = 1;
     */
    level: number;
    /**
     * @generated from protobuf field: int32 char_class = 2;
     */
    charClass: number;
    /**
     * @generated from protobuf field: int32 race = 3;
     */
    race: number;
    /**
     * @generated from protobuf field: int32 texture = 4;
     */
    texture: number;
    /**
     * @generated from protobuf field: int32 pettype = 5;
     */
    pettype: number;
    /**
     * @generated from protobuf field: float size = 6;
     */
    size: number;
    /**
     * @generated from protobuf field: int32 type = 7;
     */
    type: number;
    /**
     * @generated from protobuf field: int32 min_dmg = 8;
     */
    minDmg: number;
    /**
     * @generated from protobuf field: int32 max_dmg = 9;
     */
    maxDmg: number;
}
/**
 * @generated from protobuf message eq.Ground_Spawn
 */
export interface Ground_Spawn {
    /**
     * @generated from protobuf field: float max_x = 1;
     */
    maxX: number;
    /**
     * @generated from protobuf field: float max_y = 2;
     */
    maxY: number;
    /**
     * @generated from protobuf field: float min_x = 3;
     */
    minX: number;
    /**
     * @generated from protobuf field: float min_y = 4;
     */
    minY: number;
    /**
     * @generated from protobuf field: float max_z = 5;
     */
    maxZ: number;
    /**
     * @generated from protobuf field: float heading = 6;
     */
    heading: number;
    /**
     * @generated from protobuf field: string name = 7;
     */
    name: string;
    /**
     * @generated from protobuf field: int32 item = 8;
     */
    item: number;
    /**
     * @generated from protobuf field: int32 max_allowed = 9;
     */
    maxAllowed: number;
    /**
     * @generated from protobuf field: int32 respawntimer = 10;
     */
    respawntimer: number;
}
/**
 * @generated from protobuf message eq.Ground_Spawns
 */
export interface Ground_Spawns {
    /**
     * @generated from protobuf field: repeated eq.Ground_Spawn spawn = 1;
     */
    spawn: Ground_Spawn[];
}
/**
 * @generated from protobuf message eq.ApproveZone
 */
export interface ApproveZone {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: int32 zoneid = 2;
     */
    zoneid: number;
    /**
     * @generated from protobuf field: int32 approve = 3;
     */
    approve: number;
}
/**
 * @generated from protobuf message eq.ZoneInSendName
 */
export interface ZoneInSendName {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string name2 = 2;
     */
    name2: string;
}
/**
 * @generated from protobuf message eq.ZoneInSendName2
 */
export interface ZoneInSendName2 {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * @generated from protobuf message eq.StartTribute
 */
export interface StartTribute {
    /**
     * @generated from protobuf field: int32 client_id = 1;
     */
    clientId: number;
    /**
     * @generated from protobuf field: int32 tribute_master_id = 2;
     */
    tributeMasterId: number;
    /**
     * @generated from protobuf field: int32 response = 3;
     */
    response: number;
}
/**
 * @generated from protobuf message eq.TributeLevel
 */
export interface TributeLevel {
    /**
     * @generated from protobuf field: int32 level = 1;
     */
    level: number;
    /**
     * @generated from protobuf field: int32 tribute_item_id = 2;
     */
    tributeItemId: number;
    /**
     * @generated from protobuf field: int32 cost = 3;
     */
    cost: number;
}
/**
 * @generated from protobuf message eq.TributeAbility
 */
export interface TributeAbility {
    /**
     * @generated from protobuf field: int32 tribute_id = 1;
     */
    tributeId: number;
    /**
     * @generated from protobuf field: int32 tier_count = 2;
     */
    tierCount: number;
    /**
     * @generated from protobuf field: repeated eq.TributeLevel tiers = 3;
     */
    tiers: TributeLevel[];
    /**
     * @generated from protobuf field: string name = 4;
     */
    name: string;
}
/**
 * @generated from protobuf message eq.GuildTributeAbility
 */
export interface GuildTributeAbility {
    /**
     * @generated from protobuf field: int32 guild_id = 1;
     */
    guildId: number;
    /**
     * @generated from protobuf field: eq.TributeAbility ability = 2;
     */
    ability?: TributeAbility;
}
/**
 * @generated from protobuf message eq.SelectTributeReq
 */
export interface SelectTributeReq {
    /**
     * @generated from protobuf field: int32 client_id = 1;
     */
    clientId: number;
    /**
     * @generated from protobuf field: int32 tribute_id = 2;
     */
    tributeId: number;
}
/**
 * @generated from protobuf message eq.SelectTributeReply
 */
export interface SelectTributeReply {
    /**
     * @generated from protobuf field: int32 client_id = 1;
     */
    clientId: number;
    /**
     * @generated from protobuf field: int32 tribute_id = 2;
     */
    tributeId: number;
    /**
     * @generated from protobuf field: string desc = 3;
     */
    desc: string;
}
/**
 * @generated from protobuf message eq.TributeInfo
 */
export interface TributeInfo {
    /**
     * @generated from protobuf field: int32 active = 1;
     */
    active: number;
    /**
     * @generated from protobuf field: repeated int32 tributes = 2;
     */
    tributes: number[];
    /**
     * @generated from protobuf field: repeated int32 tiers = 3;
     */
    tiers: number[];
    /**
     * @generated from protobuf field: int32 tribute_master_id = 4;
     */
    tributeMasterId: number;
}
/**
 * @generated from protobuf message eq.TributeItem
 */
export interface TributeItem {
    /**
     * @generated from protobuf field: int32 slot = 1;
     */
    slot: number;
    /**
     * @generated from protobuf field: int32 quantity = 2;
     */
    quantity: number;
    /**
     * @generated from protobuf field: int32 tribute_master_id = 3;
     */
    tributeMasterId: number;
    /**
     * @generated from protobuf field: int32 tribute_points = 4;
     */
    tributePoints: number;
}
/**
 * @generated from protobuf message eq.TributePoint
 */
export interface TributePoint {
    /**
     * @generated from protobuf field: int32 tribute_points = 1;
     */
    tributePoints: number;
    /**
     * @generated from protobuf field: int32 career_tribute_points = 2;
     */
    careerTributePoints: number;
}
/**
 * @generated from protobuf message eq.TributeMoney
 */
export interface TributeMoney {
    /**
     * @generated from protobuf field: int32 platinum = 1;
     */
    platinum: number;
    /**
     * @generated from protobuf field: int32 tribute_master_id = 2;
     */
    tributeMasterId: number;
    /**
     * @generated from protobuf field: int32 tribute_points = 3;
     */
    tributePoints: number;
}
/**
 * @generated from protobuf message eq.Split
 */
export interface Split {
    /**
     * @generated from protobuf field: int32 platinum = 1;
     */
    platinum: number;
    /**
     * @generated from protobuf field: int32 gold = 2;
     */
    gold: number;
    /**
     * @generated from protobuf field: int32 silver = 3;
     */
    silver: number;
    /**
     * @generated from protobuf field: int32 copper = 4;
     */
    copper: number;
}
/**
 * @generated from protobuf message eq.NewCombine
 */
export interface NewCombine {
    /**
     * @generated from protobuf field: int32 container_slot = 1;
     */
    containerSlot: number;
    /**
     * @generated from protobuf field: int32 guildtribute_slot = 2;
     */
    guildtributeSlot: number;
}
/**
 * @generated from protobuf message eq.TradeskillFavorites
 */
export interface TradeskillFavorites {
    /**
     * @generated from protobuf field: int32 object_type = 1;
     */
    objectType: number;
    /**
     * @generated from protobuf field: int32 some_id = 2;
     */
    someId: number;
    /**
     * @generated from protobuf field: repeated int32 favorite_recipes = 3;
     */
    favoriteRecipes: number[];
}
/**
 * @generated from protobuf message eq.RecipesSearch
 */
export interface RecipesSearch {
    /**
     * @generated from protobuf field: int32 object_type = 1;
     */
    objectType: number;
    /**
     * @generated from protobuf field: int32 some_id = 2;
     */
    someId: number;
    /**
     * @generated from protobuf field: int32 mintrivial = 3;
     */
    mintrivial: number;
    /**
     * @generated from protobuf field: int32 maxtrivial = 4;
     */
    maxtrivial: number;
    /**
     * @generated from protobuf field: string query = 5;
     */
    query: string;
}
/**
 * @generated from protobuf message eq.RecipeReply
 */
export interface RecipeReply {
    /**
     * @generated from protobuf field: int32 object_type = 1;
     */
    objectType: number;
    /**
     * @generated from protobuf field: int32 some_id = 2;
     */
    someId: number;
    /**
     * @generated from protobuf field: int32 component_count = 3;
     */
    componentCount: number;
    /**
     * @generated from protobuf field: int32 recipe_id = 4;
     */
    recipeId: number;
    /**
     * @generated from protobuf field: int32 trivial = 5;
     */
    trivial: number;
    /**
     * @generated from protobuf field: string recipe_name = 6;
     */
    recipeName: string;
}
/**
 * @generated from protobuf message eq.RecipeAutoCombine
 */
export interface RecipeAutoCombine {
    /**
     * @generated from protobuf field: int32 object_type = 1;
     */
    objectType: number;
    /**
     * @generated from protobuf field: int32 some_id = 2;
     */
    someId: number;
    /**
     * @generated from protobuf field: int32 recipe_id = 3;
     */
    recipeId: number;
    /**
     * @generated from protobuf field: int32 reply_code = 4;
     */
    replyCode: number;
}
/**
 * @generated from protobuf message eq.LevelAppearance
 */
export interface LevelAppearance {
    /**
     * @generated from protobuf field: int32 spawn_id = 1;
     */
    spawnId: number;
    /**
     * @generated from protobuf field: int32 parm1 = 2;
     */
    parm1: number;
    /**
     * @generated from protobuf field: int32 value1a = 3 [json_name = "value1a"];
     */
    value1A: number;
    /**
     * @generated from protobuf field: int32 value1b = 4 [json_name = "value1b"];
     */
    value1B: number;
    /**
     * @generated from protobuf field: int32 parm2 = 5;
     */
    parm2: number;
    /**
     * @generated from protobuf field: int32 value2a = 6 [json_name = "value2a"];
     */
    value2A: number;
    /**
     * @generated from protobuf field: int32 value2b = 7 [json_name = "value2b"];
     */
    value2B: number;
    /**
     * @generated from protobuf field: int32 parm3 = 8;
     */
    parm3: number;
    /**
     * @generated from protobuf field: int32 value3a = 9 [json_name = "value3a"];
     */
    value3A: number;
    /**
     * @generated from protobuf field: int32 value3b = 10 [json_name = "value3b"];
     */
    value3B: number;
    /**
     * @generated from protobuf field: int32 parm4 = 11;
     */
    parm4: number;
    /**
     * @generated from protobuf field: int32 value4a = 12 [json_name = "value4a"];
     */
    value4A: number;
    /**
     * @generated from protobuf field: int32 value4b = 13 [json_name = "value4b"];
     */
    value4B: number;
    /**
     * @generated from protobuf field: int32 parm5 = 14;
     */
    parm5: number;
    /**
     * @generated from protobuf field: int32 value5a = 15 [json_name = "value5a"];
     */
    value5A: number;
    /**
     * @generated from protobuf field: int32 value5b = 16 [json_name = "value5b"];
     */
    value5B: number;
}
/**
 * @generated from protobuf message eq.MerchantList
 */
export interface MerchantList {
    /**
     * @generated from protobuf field: int32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: int32 slot = 2;
     */
    slot: number;
    /**
     * @generated from protobuf field: int32 item = 3;
     */
    item: number;
}
/**
 * @generated from protobuf message eq.TempMerchantList
 */
export interface TempMerchantList {
    /**
     * @generated from protobuf field: int32 npcid = 1;
     */
    npcid: number;
    /**
     * @generated from protobuf field: int32 slot = 2;
     */
    slot: number;
    /**
     * @generated from protobuf field: int32 item = 3;
     */
    item: number;
    /**
     * @generated from protobuf field: int32 charges = 4;
     */
    charges: number;
    /**
     * @generated from protobuf field: int32 origslot = 5;
     */
    origslot: number;
}
/**
 * @generated from protobuf message eq.FindPerson_Point
 */
export interface FindPerson_Point {
    /**
     * @generated from protobuf field: float y = 1;
     */
    y: number;
    /**
     * @generated from protobuf field: float x = 2;
     */
    x: number;
    /**
     * @generated from protobuf field: float z = 3;
     */
    z: number;
}
/**
 * @generated from protobuf message eq.FindPersonRequest
 */
export interface FindPersonRequest {
    /**
     * @generated from protobuf field: int32 npc_id = 1;
     */
    npcId: number;
    /**
     * @generated from protobuf field: int32 client_pos = 2;
     */
    clientPos: number;
}
/**
 * @generated from protobuf message eq.FindPersonResult
 */
export interface FindPersonResult {
    /**
     * @generated from protobuf field: int32 dest = 1;
     */
    dest: number;
    /**
     * @generated from protobuf field: repeated int32 path = 2;
     */
    path: number[];
}
/**
 * @generated from protobuf message eq.MobRename
 */
export interface MobRename {
    /**
     * @generated from protobuf field: string old_name = 1;
     */
    oldName: string;
    /**
     * @generated from protobuf field: string old_name_again = 2;
     */
    oldNameAgain: string;
    /**
     * @generated from protobuf field: string new_name = 3;
     */
    newName: string;
}
/**
 * @generated from protobuf message eq.PlayMP3
 */
export interface PlayMP3 {
    /**
     * @generated from protobuf field: string filename = 1;
     */
    filename: string;
}
/**
 * @generated from protobuf message eq.TitleEntry
 */
export interface TitleEntry {
    /**
     * @generated from protobuf field: int32 skill_id = 1;
     */
    skillId: number;
    /**
     * @generated from protobuf field: int32 skill_value = 2;
     */
    skillValue: number;
    /**
     * @generated from protobuf field: string title = 3;
     */
    title: string;
}
/**
 * @generated from protobuf message eq.Titles
 */
export interface Titles {
    /**
     * @generated from protobuf field: int32 count = 1;
     */
    count: number;
    /**
     * @generated from protobuf field: repeated eq.TitleEntry titles = 2;
     */
    titles: TitleEntry[];
}
/**
 * @generated from protobuf message eq.TitleListEntry
 */
export interface TitleListEntry {
    /**
     * @generated from protobuf field: string prefix = 1;
     */
    prefix: string;
    /**
     * @generated from protobuf field: string postfix = 2;
     */
    postfix: string;
}
/**
 * @generated from protobuf message eq.TitleList
 */
export interface TitleList {
    /**
     * @generated from protobuf field: int32 count = 1;
     */
    count: number;
    /**
     * @generated from protobuf field: repeated eq.TitleListEntry titles = 2;
     */
    titles: TitleListEntry[];
}
/**
 * @generated from protobuf message eq.SetTitle
 */
export interface SetTitle {
    /**
     * @generated from protobuf field: int32 is_suffix = 1;
     */
    isSuffix: number;
    /**
     * @generated from protobuf field: int32 title_id = 2;
     */
    titleId: number;
}
/**
 * @generated from protobuf message eq.SetTitleReply
 */
export interface SetTitleReply {
    /**
     * @generated from protobuf field: int32 is_suffix = 1;
     */
    isSuffix: number;
    /**
     * @generated from protobuf field: string title = 2;
     */
    title: string;
    /**
     * @generated from protobuf field: int32 entity_id = 3;
     */
    entityId: number;
}
/**
 * @generated from protobuf message eq.TaskDescription
 */
export interface TaskDescription {
    /**
     * @generated from protobuf field: int32 activity_count = 1;
     */
    activityCount: number;
    /**
     * @generated from protobuf field: int32 taskid = 2;
     */
    taskid: number;
    /**
     * @generated from protobuf field: int32 unk = 3;
     */
    unk: number;
    /**
     * @generated from protobuf field: int32 id = 4;
     */
    id: number;
    /**
     * @generated from protobuf field: string name = 5;
     */
    name: string;
    /**
     * @generated from protobuf field: string desc = 6;
     */
    desc: string;
    /**
     * @generated from protobuf field: int32 reward_count = 7;
     */
    rewardCount: number;
    /**
     * @generated from protobuf field: string reward_link = 8;
     */
    rewardLink: string;
}
/**
 * @generated from protobuf message eq.TaskMemberList
 */
export interface TaskMemberList {
    /**
     * @generated from protobuf field: int32 gopher_id = 1;
     */
    gopherId: number;
    /**
     * @generated from protobuf field: int32 member_count = 2;
     */
    memberCount: number;
    /**
     * @generated from protobuf field: string list_pointer = 3;
     */
    listPointer: string;
}
/**
 * @generated from protobuf message eq.TaskActivity
 */
export interface TaskActivity {
    /**
     * @generated from protobuf field: int32 activity_count = 1;
     */
    activityCount: number;
    /**
     * @generated from protobuf field: int32 id = 2;
     */
    id: number;
    /**
     * @generated from protobuf field: int32 taskid = 3;
     */
    taskid: number;
    /**
     * @generated from protobuf field: int32 activity_id = 4;
     */
    activityId: number;
    /**
     * @generated from protobuf field: int32 activity_type = 5;
     */
    activityType: number;
    /**
     * @generated from protobuf field: string mob_name = 6;
     */
    mobName: string;
    /**
     * @generated from protobuf field: string item_name = 7;
     */
    itemName: string;
    /**
     * @generated from protobuf field: int32 goal_count = 8;
     */
    goalCount: number;
    /**
     * @generated from protobuf field: string activity_name = 9;
     */
    activityName: string;
    /**
     * @generated from protobuf field: int32 done_count = 10;
     */
    doneCount: number;
}
/**
 * @generated from protobuf message eq.TaskHistoryEntry
 */
export interface TaskHistoryEntry {
    /**
     * @generated from protobuf field: int32 task_id = 1;
     */
    taskId: number;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: int32 completed_time = 3;
     */
    completedTime: number;
}
/**
 * @generated from protobuf message eq.TaskHistory
 */
export interface TaskHistory {
    /**
     * @generated from protobuf field: int32 count = 1;
     */
    count: number;
    /**
     * @generated from protobuf field: repeated eq.TaskHistoryEntry entries = 2;
     */
    entries: TaskHistoryEntry[];
}
/**
 * @generated from protobuf message eq.AcceptNewTask
 */
export interface AcceptNewTask {
    /**
     * @generated from protobuf field: int32 task_id = 1;
     */
    taskId: number;
    /**
     * @generated from protobuf field: int32 task_master_id = 2;
     */
    taskMasterId: number;
}
/**
 * @generated from protobuf message eq.CancelTask
 */
export interface CancelTask {
}
/**
 * @generated from protobuf message eq.AvaliableTask
 */
export interface AvaliableTask {
    /**
     * @generated from protobuf field: int32 task_index = 1;
     */
    taskIndex: number;
    /**
     * @generated from protobuf field: int32 task_master_id = 2;
     */
    taskMasterId: number;
    /**
     * @generated from protobuf field: int32 task_id = 3;
     */
    taskId: number;
    /**
     * @generated from protobuf field: int32 activity_count = 4;
     */
    activityCount: number;
    /**
     * @generated from protobuf field: string desc = 5;
     */
    desc: string;
    /**
     * @generated from protobuf field: int32 reward_platinum = 6;
     */
    rewardPlatinum: number;
    /**
     * @generated from protobuf field: int32 reward_gold = 7;
     */
    rewardGold: number;
    /**
     * @generated from protobuf field: int32 reward_silver = 8;
     */
    rewardSilver: number;
    /**
     * @generated from protobuf field: int32 reward_copper = 9;
     */
    rewardCopper: number;
    /**
     * @generated from protobuf field: string some_name = 10;
     */
    someName: string;
}
/**
 * @generated from protobuf message eq.BankerChange
 */
export interface BankerChange {
    /**
     * @generated from protobuf field: int32 platinum = 1;
     */
    platinum: number;
    /**
     * @generated from protobuf field: int32 gold = 2;
     */
    gold: number;
    /**
     * @generated from protobuf field: int32 silver = 3;
     */
    silver: number;
    /**
     * @generated from protobuf field: int32 copper = 4;
     */
    copper: number;
    /**
     * @generated from protobuf field: int32 platinum_bank = 5;
     */
    platinumBank: number;
    /**
     * @generated from protobuf field: int32 gold_bank = 6;
     */
    goldBank: number;
    /**
     * @generated from protobuf field: int32 silver_bank = 7;
     */
    silverBank: number;
    /**
     * @generated from protobuf field: int32 copper_bank = 8;
     */
    copperBank: number;
}
/**
 * @generated from protobuf message eq.LeadershipExpUpdate
 */
export interface LeadershipExpUpdate {
    /**
     * @generated from protobuf field: double group_leadership_exp = 1;
     */
    groupLeadershipExp: number;
    /**
     * @generated from protobuf field: int32 group_leadership_points = 2;
     */
    groupLeadershipPoints: number;
    /**
     * @generated from protobuf field: double raid_leadership_exp = 3;
     */
    raidLeadershipExp: number;
    /**
     * @generated from protobuf field: int32 raid_leadership_points = 4;
     */
    raidLeadershipPoints: number;
}
/**
 * @generated from protobuf message eq.UpdateLeadershipAA
 */
export interface UpdateLeadershipAA {
    /**
     * @generated from protobuf field: int32 ability_id = 1;
     */
    abilityId: number;
    /**
     * @generated from protobuf field: int32 new_rank = 2;
     */
    newRank: number;
    /**
     * @generated from protobuf field: int32 pointsleft = 3;
     */
    pointsleft: number;
}
/**
 * @generated from protobuf message eq.LeadExpUpdate
 */
export interface LeadExpUpdate {
    /**
     * @generated from protobuf field: int32 group_leadership_exp = 1;
     */
    groupLeadershipExp: number;
    /**
     * @generated from protobuf field: int32 group_leadership_points = 2;
     */
    groupLeadershipPoints: number;
    /**
     * @generated from protobuf field: int32 raid_leadership_exp = 3;
     */
    raidLeadershipExp: number;
    /**
     * @generated from protobuf field: int32 raid_leadership_points = 4;
     */
    raidLeadershipPoints: number;
}
/**
 * @generated from protobuf message eq.RaidGeneral
 */
export interface RaidGeneral {
    /**
     * @generated from protobuf field: int32 action = 1;
     */
    action: number;
    /**
     * @generated from protobuf field: string player_name = 2;
     */
    playerName: string;
    /**
     * @generated from protobuf field: string leader_name = 3;
     */
    leaderName: string;
    /**
     * @generated from protobuf field: int32 parameter = 4;
     */
    parameter: number;
}
/**
 * @generated from protobuf message eq.RaidAddMember
 */
export interface RaidAddMember {
    /**
     * @generated from protobuf field: eq.RaidGeneral raid_gen = 1;
     */
    raidGen?: RaidGeneral;
    /**
     * @generated from protobuf field: int32 char_class = 2;
     */
    charClass: number;
    /**
     * @generated from protobuf field: int32 level = 3;
     */
    level: number;
    /**
     * @generated from protobuf field: int32 is_group_leader = 4;
     */
    isGroupLeader: number;
}
/**
 * @generated from protobuf message eq.RaidNote
 */
export interface RaidNote {
    /**
     * @generated from protobuf field: eq.RaidGeneral general = 1;
     */
    general?: RaidGeneral;
    /**
     * @generated from protobuf field: string note = 2;
     */
    note: string;
}
/**
 * @generated from protobuf message eq.RaidMOTD
 */
export interface RaidMOTD {
    /**
     * @generated from protobuf field: eq.RaidGeneral general = 1;
     */
    general?: RaidGeneral;
    /**
     * @generated from protobuf field: string motd = 2;
     */
    motd: string;
}
/**
 * @generated from protobuf message eq.RaidLeadershipUpdate
 */
export interface RaidLeadershipUpdate {
    /**
     * @generated from protobuf field: int32 action = 1;
     */
    action: number;
    /**
     * @generated from protobuf field: string player_name = 2;
     */
    playerName: string;
    /**
     * @generated from protobuf field: string leader_name = 3;
     */
    leaderName: string;
    /**
     * @generated from protobuf field: eq.GroupLeadershipAA group = 4;
     */
    group?: GroupLeadershipAA;
    /**
     * @generated from protobuf field: eq.RaidLeadershipAA raid = 5;
     */
    raid?: RaidLeadershipAA;
}
/**
 * @generated from protobuf message eq.RaidCreate
 */
export interface RaidCreate {
    /**
     * @generated from protobuf field: int32 action = 1;
     */
    action: number;
    /**
     * @generated from protobuf field: string leader_name = 2;
     */
    leaderName: string;
    /**
     * @generated from protobuf field: int32 leader_id = 3;
     */
    leaderId: number;
}
/**
 * @generated from protobuf message eq.RaidMemberInfo
 */
export interface RaidMemberInfo {
    /**
     * @generated from protobuf field: int32 group_number = 1;
     */
    groupNumber: number;
    /**
     * @generated from protobuf field: string member_name = 2;
     */
    memberName: string;
    /**
     * @generated from protobuf field: int32 char_class = 3;
     */
    charClass: number;
    /**
     * @generated from protobuf field: int32 level = 4;
     */
    level: number;
    /**
     * @generated from protobuf field: int32 is_raid_leader = 5;
     */
    isRaidLeader: number;
    /**
     * @generated from protobuf field: int32 is_group_leader = 6;
     */
    isGroupLeader: number;
    /**
     * @generated from protobuf field: int32 main_tank = 7;
     */
    mainTank: number;
}
/**
 * @generated from protobuf message eq.RaidDetails
 */
export interface RaidDetails {
    /**
     * @generated from protobuf field: int32 action = 1;
     */
    action: number;
    /**
     * @generated from protobuf field: string leader_name = 2;
     */
    leaderName: string;
    /**
     * @generated from protobuf field: eq.LeadershipAA abilities = 3;
     */
    abilities?: LeadershipAA;
    /**
     * @generated from protobuf field: int32 leader_id = 4;
     */
    leaderId: number;
}
/**
 * @generated from protobuf message eq.RaidMembers
 */
export interface RaidMembers {
    /**
     * @generated from protobuf field: eq.RaidDetails details = 1;
     */
    details?: RaidDetails;
    /**
     * @generated from protobuf field: int32 member_count = 2;
     */
    memberCount: number;
    /**
     * @generated from protobuf field: repeated eq.RaidMemberInfo members = 3;
     */
    members: RaidMemberInfo[];
    /**
     * @generated from protobuf field: eq.RaidMemberInfo empty = 4;
     */
    empty?: RaidMemberInfo;
}
/**
 * @generated from protobuf message eq.DynamicWall
 */
export interface DynamicWall {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: float y = 2;
     */
    y: number;
    /**
     * @generated from protobuf field: float x = 3;
     */
    x: number;
    /**
     * @generated from protobuf field: float z = 4;
     */
    z: number;
    /**
     * @generated from protobuf field: int32 one_hundred = 5;
     */
    oneHundred: number;
}
/**
 * @generated from protobuf message eq.BandolierCreate
 */
export interface BandolierCreate {
    /**
     * @generated from protobuf field: int32 action = 1;
     */
    action: number;
    /**
     * @generated from protobuf field: int32 number = 2;
     */
    number: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
}
/**
 * @generated from protobuf message eq.BandolierDelete
 */
export interface BandolierDelete {
    /**
     * @generated from protobuf field: int32 action = 1;
     */
    action: number;
    /**
     * @generated from protobuf field: int32 number = 2;
     */
    number: number;
}
/**
 * @generated from protobuf message eq.BandolierSet
 */
export interface BandolierSet {
    /**
     * @generated from protobuf field: int32 action = 1;
     */
    action: number;
    /**
     * @generated from protobuf field: int32 number = 2;
     */
    number: number;
}
/**
 * @generated from protobuf message eq.Arrow
 */
export interface Arrow {
    /**
     * @generated from protobuf field: int32 type = 1;
     */
    type: number;
    /**
     * @generated from protobuf field: float src_y = 2;
     */
    srcY: number;
    /**
     * @generated from protobuf field: float src_x = 3;
     */
    srcX: number;
    /**
     * @generated from protobuf field: float src_z = 4;
     */
    srcZ: number;
    /**
     * @generated from protobuf field: float velocity = 5;
     */
    velocity: number;
    /**
     * @generated from protobuf field: float launch_angle = 6;
     */
    launchAngle: number;
    /**
     * @generated from protobuf field: float tilt = 7;
     */
    tilt: number;
    /**
     * @generated from protobuf field: float arc = 8;
     */
    arc: number;
    /**
     * @generated from protobuf field: int32 source_id = 9;
     */
    sourceId: number;
    /**
     * @generated from protobuf field: int32 target_id = 10;
     */
    targetId: number;
    /**
     * @generated from protobuf field: int32 item_id = 11;
     */
    itemId: number;
    /**
     * @generated from protobuf field: string model_name = 12;
     */
    modelName: string;
}
/**
 * @generated from protobuf message eq.Consent
 */
export interface Consent {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * @generated from protobuf message eq.AdventureMerchant
 */
export interface AdventureMerchant {
    /**
     * @generated from protobuf field: int32 entity_id = 1;
     */
    entityId: number;
}
/**
 * @generated from protobuf message eq.Save
 */
export interface Save {
}
/**
 * @generated from protobuf message eq.GMtoggle
 */
export interface GMtoggle {
    /**
     * @generated from protobuf field: int32 toggle = 1;
     */
    toggle: number;
}
/**
 * @generated from protobuf message eq.GroupInvite
 */
export interface GroupInvite {
    /**
     * @generated from protobuf field: string invitee_name = 1;
     */
    inviteeName: string;
    /**
     * @generated from protobuf field: string inviter_name = 2;
     */
    inviterName: string;
}
/**
 * @generated from protobuf message eq.ColoredText
 */
export interface ColoredText {
    /**
     * @generated from protobuf field: int32 color = 1;
     */
    color: number;
    /**
     * @generated from protobuf field: string msg = 2;
     */
    msg: string;
}
/**
 * @generated from protobuf message eq.UseAA
 */
export interface UseAA {
    /**
     * @generated from protobuf field: int32 begin = 1;
     */
    begin: number;
    /**
     * @generated from protobuf field: int32 ability = 2;
     */
    ability: number;
    /**
     * @generated from protobuf field: int32 end = 3;
     */
    end: number;
}
/**
 * @generated from protobuf message eq.AA_Ability
 */
export interface AA_Ability {
    /**
     * @generated from protobuf field: int32 skill_id = 1;
     */
    skillId: number;
    /**
     * @generated from protobuf field: int32 base_value = 2;
     */
    baseValue: number;
    /**
     * @generated from protobuf field: int32 limit_value = 3;
     */
    limitValue: number;
    /**
     * @generated from protobuf field: int32 slot = 4;
     */
    slot: number;
}
/**
 * @generated from protobuf message eq.SendAA
 */
export interface SendAA {
    /**
     * @generated from protobuf field: int32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: int32 hotkey_sid = 2;
     */
    hotkeySid: number;
    /**
     * @generated from protobuf field: int32 hotkey_sid2 = 3;
     */
    hotkeySid2: number;
    /**
     * @generated from protobuf field: int32 title_sid = 4;
     */
    titleSid: number;
    /**
     * @generated from protobuf field: int32 desc_sid = 5;
     */
    descSid: number;
    /**
     * @generated from protobuf field: int32 class_type = 6;
     */
    classType: number;
    /**
     * @generated from protobuf field: int32 cost = 7;
     */
    cost: number;
    /**
     * @generated from protobuf field: int32 seq = 8;
     */
    seq: number;
    /**
     * @generated from protobuf field: int32 current_level = 9;
     */
    currentLevel: number;
    /**
     * @generated from protobuf field: int32 prereq_skill = 10;
     */
    prereqSkill: number;
    /**
     * @generated from protobuf field: int32 prereq_minpoints = 11;
     */
    prereqMinpoints: number;
    /**
     * @generated from protobuf field: int32 type = 12;
     */
    type: number;
    /**
     * @generated from protobuf field: int32 spellid = 13;
     */
    spellid: number;
    /**
     * @generated from protobuf field: int32 spell_type = 14;
     */
    spellType: number;
    /**
     * @generated from protobuf field: int32 spell_refresh = 15;
     */
    spellRefresh: number;
    /**
     * @generated from protobuf field: int32 classes = 16;
     */
    classes: number;
    /**
     * @generated from protobuf field: int32 max_level = 17;
     */
    maxLevel: number;
    /**
     * @generated from protobuf field: int32 last_id = 18;
     */
    lastId: number;
    /**
     * @generated from protobuf field: int32 next_id = 19;
     */
    nextId: number;
    /**
     * @generated from protobuf field: int32 cost2 = 20;
     */
    cost2: number;
    /**
     * @generated from protobuf field: int32 count = 21;
     */
    count: number;
    /**
     * @generated from protobuf field: repeated eq.AA_Ability abilities = 22;
     */
    abilities: AA_Ability[];
}
/**
 * @generated from protobuf message eq.AA_List
 */
export interface AA_List {
    /**
     * @generated from protobuf field: int32 count = 1;
     */
    count: number;
    /**
     * @generated from protobuf field: repeated eq.SendAA aa = 2;
     */
    aa: SendAA[];
}
/**
 * @generated from protobuf message eq.AA_Action
 */
export interface AA_Action {
    /**
     * @generated from protobuf field: int32 action = 1;
     */
    action: number;
    /**
     * @generated from protobuf field: int32 ability = 2;
     */
    ability: number;
    /**
     * @generated from protobuf field: int32 target_id = 3;
     */
    targetId: number;
    /**
     * @generated from protobuf field: int32 exp_value = 4;
     */
    expValue: number;
}
/**
 * @generated from protobuf message eq.AAExpUpdate
 */
export interface AAExpUpdate {
    /**
     * @generated from protobuf field: int32 aapoints_unspent = 1;
     */
    aapointsUnspent: number;
    /**
     * @generated from protobuf field: int32 aaxp_percent = 2;
     */
    aaxpPercent: number;
}
/**
 * @generated from protobuf message eq.AltAdvStats
 */
export interface AltAdvStats {
    /**
     * @generated from protobuf field: int32 experience = 1;
     */
    experience: number;
    /**
     * @generated from protobuf field: int32 unspent = 2;
     */
    unspent: number;
    /**
     * @generated from protobuf field: int32 percentage = 3;
     */
    percentage: number;
}
/**
 * @generated from protobuf message eq.PlayerAA
 */
export interface PlayerAA {
    /**
     * @generated from protobuf field: repeated eq.AA_Array aa_list = 1;
     */
    aaList: AA_Array[];
}
/**
 * @generated from protobuf message eq.AATable
 */
export interface AATable {
    /**
     * @generated from protobuf field: repeated eq.AA_Array aa_list = 1;
     */
    aaList: AA_Array[];
}
/**
 * @generated from protobuf message eq.Weather
 */
export interface Weather {
    /**
     * @generated from protobuf field: int32 val = 1;
     */
    val: number;
    /**
     * @generated from protobuf field: int32 type = 2;
     */
    type: number;
    /**
     * @generated from protobuf field: int32 mode = 3;
     */
    mode: number;
}
/**
 * @generated from protobuf message eq.LoadSpellSet
 */
export interface LoadSpellSet {
    /**
     * @generated from protobuf field: repeated int32 spell = 1;
     */
    spell: number[];
}
/**
 * @generated from protobuf message eq.ApplyPoison
 */
export interface ApplyPoison {
    /**
     * @generated from protobuf field: int32 inventory_slot = 1;
     */
    inventorySlot: number;
    /**
     * @generated from protobuf field: int32 success = 2;
     */
    success: number;
}
/**
 * @generated from protobuf message eq.GuildMemberUpdate
 */
export interface GuildMemberUpdate {
    /**
     * @generated from protobuf field: int32 guild_id = 1;
     */
    guildId: number;
    /**
     * @generated from protobuf field: string member_name = 2;
     */
    memberName: string;
    /**
     * @generated from protobuf field: int32 zone_id = 3;
     */
    zoneId: number;
    /**
     * @generated from protobuf field: int32 instance_id = 4;
     */
    instanceId: number;
}
/**
 * @generated from protobuf message eq.VeteranRewardItem
 */
export interface VeteranRewardItem {
    /**
     * @generated from protobuf field: int32 item_id = 1;
     */
    itemId: number;
    /**
     * @generated from protobuf field: string item_name = 2;
     */
    itemName: string;
}
/**
 * @generated from protobuf message eq.VeteranReward
 */
export interface VeteranReward {
    /**
     * @generated from protobuf field: int32 claim_id = 1;
     */
    claimId: number;
    /**
     * @generated from protobuf field: eq.VeteranRewardItem item = 2;
     */
    item?: VeteranRewardItem;
}
/**
 * @generated from protobuf message eq.ExpeditionInvite
 */
export interface ExpeditionInvite {
    /**
     * @generated from protobuf field: int32 client_id = 1;
     */
    clientId: number;
    /**
     * @generated from protobuf field: string inviter_name = 2;
     */
    inviterName: string;
    /**
     * @generated from protobuf field: string expedition_name = 3;
     */
    expeditionName: string;
    /**
     * @generated from protobuf field: int32 swapping = 4;
     */
    swapping: number;
    /**
     * @generated from protobuf field: string swap_name = 5;
     */
    swapName: string;
    /**
     * @generated from protobuf field: repeated int32 padding = 6;
     */
    padding: number[];
    /**
     * @generated from protobuf field: int32 dz_zone_id = 7;
     */
    dzZoneId: number;
    /**
     * @generated from protobuf field: int32 dz_instance_id = 8;
     */
    dzInstanceId: number;
}
/**
 * @generated from protobuf message eq.ExpeditionInviteResponse
 */
export interface ExpeditionInviteResponse {
    /**
     * @generated from protobuf field: int32 dz_zone_id = 1;
     */
    dzZoneId: number;
    /**
     * @generated from protobuf field: int32 dz_instance_id = 2;
     */
    dzInstanceId: number;
    /**
     * @generated from protobuf field: int32 accepted = 3;
     */
    accepted: number;
    /**
     * @generated from protobuf field: int32 swapping = 4;
     */
    swapping: number;
    /**
     * @generated from protobuf field: string swap_name = 5;
     */
    swapName: string;
}
/**
 * @generated from protobuf message eq.DynamicZoneInfo
 */
export interface DynamicZoneInfo {
    /**
     * @generated from protobuf field: int32 client_id = 1;
     */
    clientId: number;
    /**
     * @generated from protobuf field: int32 assigned = 2;
     */
    assigned: number;
    /**
     * @generated from protobuf field: int32 max_players = 3;
     */
    maxPlayers: number;
    /**
     * @generated from protobuf field: string dz_name = 4;
     */
    dzName: string;
    /**
     * @generated from protobuf field: string leader_name = 5;
     */
    leaderName: string;
}
/**
 * @generated from protobuf message eq.DynamicZoneMemberEntry
 */
export interface DynamicZoneMemberEntry {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: int32 online_status = 2;
     */
    onlineStatus: number;
}
/**
 * @generated from protobuf message eq.DynamicZoneMemberList
 */
export interface DynamicZoneMemberList {
    /**
     * @generated from protobuf field: int32 client_id = 1;
     */
    clientId: number;
    /**
     * @generated from protobuf field: int32 count = 2;
     */
    count: number;
    /**
     * @generated from protobuf field: repeated eq.DynamicZoneMemberEntry members = 3;
     */
    members: DynamicZoneMemberEntry[];
}
/**
 * @generated from protobuf message eq.DynamicZoneMemberListName
 */
export interface DynamicZoneMemberListName {
    /**
     * @generated from protobuf field: int32 client_id = 1;
     */
    clientId: number;
    /**
     * @generated from protobuf field: int32 add_name = 2;
     */
    addName: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
}
/**
 * @generated from protobuf message eq.ExpeditionLockoutTimerEntry
 */
export interface ExpeditionLockoutTimerEntry {
    /**
     * @generated from protobuf field: string expedition_name = 1;
     */
    expeditionName: string;
    /**
     * @generated from protobuf field: int32 seconds_remaining = 2;
     */
    secondsRemaining: number;
    /**
     * @generated from protobuf field: int32 event_type = 3;
     */
    eventType: number;
    /**
     * @generated from protobuf field: string event_name = 4;
     */
    eventName: string;
}
/**
 * @generated from protobuf message eq.ExpeditionLockoutTimers
 */
export interface ExpeditionLockoutTimers {
    /**
     * @generated from protobuf field: int32 client_id = 1;
     */
    clientId: number;
    /**
     * @generated from protobuf field: int32 count = 2;
     */
    count: number;
    /**
     * @generated from protobuf field: repeated eq.ExpeditionLockoutTimerEntry timers = 3;
     */
    timers: ExpeditionLockoutTimerEntry[];
}
/**
 * @generated from protobuf message eq.DynamicZoneLeaderName
 */
export interface DynamicZoneLeaderName {
    /**
     * @generated from protobuf field: int32 client_id = 1;
     */
    clientId: number;
    /**
     * @generated from protobuf field: string leader_name = 2;
     */
    leaderName: string;
}
/**
 * @generated from protobuf message eq.ExpeditionCommand
 */
export interface ExpeditionCommand {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * @generated from protobuf message eq.ExpeditionCommandSwap
 */
export interface ExpeditionCommandSwap {
    /**
     * @generated from protobuf field: string add_player_name = 1;
     */
    addPlayerName: string;
    /**
     * @generated from protobuf field: string rem_player_name = 2;
     */
    remPlayerName: string;
}
/**
 * @generated from protobuf message eq.ExpeditionExpireWarning
 */
export interface ExpeditionExpireWarning {
    /**
     * @generated from protobuf field: int32 client_id = 1;
     */
    clientId: number;
    /**
     * @generated from protobuf field: int32 minutes_remaining = 2;
     */
    minutesRemaining: number;
}
/**
 * @generated from protobuf message eq.DynamicZoneCompassEntry
 */
export interface DynamicZoneCompassEntry {
    /**
     * @generated from protobuf field: int32 dz_zone_id = 1;
     */
    dzZoneId: number;
    /**
     * @generated from protobuf field: int32 dz_instance_id = 2;
     */
    dzInstanceId: number;
    /**
     * @generated from protobuf field: int32 dz_type = 3;
     */
    dzType: number;
    /**
     * @generated from protobuf field: int32 dz_switch_id = 4;
     */
    dzSwitchId: number;
    /**
     * @generated from protobuf field: float y = 5;
     */
    y: number;
    /**
     * @generated from protobuf field: float x = 6;
     */
    x: number;
    /**
     * @generated from protobuf field: float z = 7;
     */
    z: number;
}
/**
 * @generated from protobuf message eq.DynamicZoneCompass
 */
export interface DynamicZoneCompass {
    /**
     * @generated from protobuf field: int32 client_id = 1;
     */
    clientId: number;
    /**
     * @generated from protobuf field: int32 count = 2;
     */
    count: number;
    /**
     * @generated from protobuf field: repeated eq.DynamicZoneCompassEntry entries = 3;
     */
    entries: DynamicZoneCompassEntry[];
}
/**
 * @generated from protobuf message eq.DynamicZoneChooseZoneEntry
 */
export interface DynamicZoneChooseZoneEntry {
    /**
     * @generated from protobuf field: int32 dz_zone_id = 1;
     */
    dzZoneId: number;
    /**
     * @generated from protobuf field: int32 dz_instance_id = 2;
     */
    dzInstanceId: number;
    /**
     * @generated from protobuf field: int32 dz_type = 3;
     */
    dzType: number;
    /**
     * @generated from protobuf field: string description = 4;
     */
    description: string;
    /**
     * @generated from protobuf field: string leader_name = 5;
     */
    leaderName: string;
}
/**
 * @generated from protobuf message eq.DynamicZoneChooseZone
 */
export interface DynamicZoneChooseZone {
    /**
     * @generated from protobuf field: int32 client_id = 1;
     */
    clientId: number;
    /**
     * @generated from protobuf field: int32 count = 2;
     */
    count: number;
    /**
     * @generated from protobuf field: repeated eq.DynamicZoneChooseZoneEntry choices = 3;
     */
    choices: DynamicZoneChooseZoneEntry[];
}
/**
 * @generated from protobuf message eq.DynamicZoneChooseZoneReply
 */
export interface DynamicZoneChooseZoneReply {
    /**
     * @generated from protobuf field: int32 dz_zone_id = 1;
     */
    dzZoneId: number;
    /**
     * @generated from protobuf field: int32 dz_instance_id = 2;
     */
    dzInstanceId: number;
    /**
     * @generated from protobuf field: int32 dz_type = 3;
     */
    dzType: number;
}
/**
 * @generated from protobuf message eq.LFGuild_SearchPlayer
 */
export interface LFGuild_SearchPlayer {
    /**
     * @generated from protobuf field: int32 command = 1;
     */
    command: number;
    /**
     * @generated from protobuf field: int32 from_level = 2;
     */
    fromLevel: number;
    /**
     * @generated from protobuf field: int32 to_level = 3;
     */
    toLevel: number;
    /**
     * @generated from protobuf field: int32 min_aa = 4;
     */
    minAa: number;
    /**
     * @generated from protobuf field: int32 time_zone = 5;
     */
    timeZone: number;
    /**
     * @generated from protobuf field: int32 classes = 6;
     */
    classes: number;
}
/**
 * @generated from protobuf message eq.LFGuild_SearchGuild
 */
export interface LFGuild_SearchGuild {
    /**
     * @generated from protobuf field: int32 command = 1;
     */
    command: number;
    /**
     * @generated from protobuf field: int32 level = 2;
     */
    level: number;
    /**
     * @generated from protobuf field: int32 aa_points = 3;
     */
    aaPoints: number;
    /**
     * @generated from protobuf field: int32 time_zone = 4;
     */
    timeZone: number;
    /**
     * @generated from protobuf field: int32 char_class = 5;
     */
    charClass: number;
}
/**
 * @generated from protobuf message eq.LFGuild_Playertoggle
 */
export interface LFGuild_Playertoggle {
    /**
     * @generated from protobuf field: int32 command = 1;
     */
    command: number;
    /**
     * @generated from protobuf field: string comment = 2;
     */
    comment: string;
    /**
     * @generated from protobuf field: int32 time_zone = 3;
     */
    timeZone: number;
    /**
     * @generated from protobuf field: int32 toggle = 4;
     */
    toggle: number;
    /**
     * @generated from protobuf field: int32 expires = 5;
     */
    expires: number;
}
/**
 * @generated from protobuf message eq.LFGuild_Guildtoggle
 */
export interface LFGuild_Guildtoggle {
    /**
     * @generated from protobuf field: int32 command = 1;
     */
    command: number;
    /**
     * @generated from protobuf field: string comment = 2;
     */
    comment: string;
    /**
     * @generated from protobuf field: int32 from_level = 3;
     */
    fromLevel: number;
    /**
     * @generated from protobuf field: int32 to_level = 4;
     */
    toLevel: number;
    /**
     * @generated from protobuf field: int32 classes = 5;
     */
    classes: number;
    /**
     * @generated from protobuf field: int32 aa_count = 6;
     */
    aaCount: number;
    /**
     * @generated from protobuf field: int32 time_zone = 7;
     */
    timeZone: number;
    /**
     * @generated from protobuf field: int32 toggle = 8;
     */
    toggle: number;
    /**
     * @generated from protobuf field: int32 expires = 9;
     */
    expires: number;
    /**
     * @generated from protobuf field: string name = 10;
     */
    name: string;
}
/**
 * @generated from protobuf message eq.SayLinkBodyFrame
 */
export interface SayLinkBodyFrame {
    /**
     * @generated from protobuf field: string action_id = 1;
     */
    actionId: string;
    /**
     * @generated from protobuf field: string item_id = 2;
     */
    itemId: string;
    /**
     * @generated from protobuf field: string augment1 = 3;
     */
    augment1: string;
    /**
     * @generated from protobuf field: string augment2 = 4;
     */
    augment2: string;
    /**
     * @generated from protobuf field: string augment3 = 5;
     */
    augment3: string;
    /**
     * @generated from protobuf field: string augment4 = 6;
     */
    augment4: string;
    /**
     * @generated from protobuf field: string augment5 = 7;
     */
    augment5: string;
    /**
     * @generated from protobuf field: string is_evolving = 8;
     */
    isEvolving: string;
    /**
     * @generated from protobuf field: string evolve_group = 9;
     */
    evolveGroup: string;
    /**
     * @generated from protobuf field: string evolve_level = 10;
     */
    evolveLevel: string;
    /**
     * @generated from protobuf field: string hash = 11;
     */
    hash: string;
}
/**
 * @generated from protobuf message eq.WebLogin
 */
export interface WebLogin {
    /**
     * @generated from protobuf field: string username = 1;
     */
    username: string;
    /**
     * @generated from protobuf field: string password = 2;
     */
    password: string;
}
/**
 * @generated from protobuf message eq.WebLoginServerRequest
 */
export interface WebLoginServerRequest {
    /**
     * @generated from protobuf field: int32 sequence = 1;
     */
    sequence: number;
}
/**
 * @generated from protobuf message eq.WebLoginReply
 */
export interface WebLoginReply {
    /**
     * @generated from protobuf field: string key = 1;
     */
    key: string;
    /**
     * @generated from protobuf field: int32 error_str_id = 2;
     */
    errorStrId: number;
    /**
     * @generated from protobuf field: int32 failed_attempts = 3;
     */
    failedAttempts: number;
    /**
     * @generated from protobuf field: int32 lsid = 4;
     */
    lsid: number;
    /**
     * @generated from protobuf field: bool success = 5;
     */
    success: boolean;
    /**
     * @generated from protobuf field: bool show_player_count = 6;
     */
    showPlayerCount: boolean;
}
/**
 * @generated from protobuf message eq.WebLoginWorldServer
 */
export interface WebLoginWorldServer {
    /**
     * @generated from protobuf field: string buffer = 1;
     */
    buffer: string;
    /**
     * @generated from protobuf field: string ip = 2;
     */
    ip: string;
    /**
     * @generated from protobuf field: string long_name = 3;
     */
    longName: string;
    /**
     * @generated from protobuf field: string country_code = 4;
     */
    countryCode: string;
    /**
     * @generated from protobuf field: string language_code = 5;
     */
    languageCode: string;
    /**
     * @generated from protobuf field: int32 server_type = 6;
     */
    serverType: number;
    /**
     * @generated from protobuf field: int32 server_id = 7;
     */
    serverId: number;
    /**
     * @generated from protobuf field: int32 status = 8;
     */
    status: number;
    /**
     * @generated from protobuf field: int32 players_online = 9;
     */
    playersOnline: number;
}
/**
 * @generated from protobuf message eq.WebLoginServerResponse
 */
export interface WebLoginServerResponse {
    /**
     * @generated from protobuf field: int32 server_count = 1;
     */
    serverCount: number;
    /**
     * @generated from protobuf field: repeated eq.WebLoginWorldServer servers = 2;
     */
    servers: WebLoginWorldServer[];
}
/**
 * @generated from protobuf message eq.WebPlayEverquestRequest
 */
export interface WebPlayEverquestRequest {
    /**
     * @generated from protobuf field: int32 server_id = 1;
     */
    serverId: number;
}
/**
 * @generated from protobuf message eq.WebPlayEverquestResponse
 */
export interface WebPlayEverquestResponse {
    /**
     * @generated from protobuf field: int32 server_id = 1;
     */
    serverId: number;
    /**
     * @generated from protobuf field: bool success = 2;
     */
    success: boolean;
    /**
     * @generated from protobuf field: int32 error_str_id = 3;
     */
    errorStrId: number;
}
/**
 * @generated from protobuf message eq.WebSession
 */
export interface WebSession {
    /**
     * @generated from protobuf field: string remote_addr = 1;
     */
    remoteAddr: string;
    /**
     * @generated from protobuf field: int32 remote_ip = 2;
     */
    remoteIp: number;
    /**
     * @generated from protobuf field: int32 remote_port = 3;
     */
    remotePort: number;
}
/**
 * @generated from protobuf message eq.Zero
 */
export interface Zero {
}
/**
 * @generated from protobuf message eq.Int
 */
export interface Int {
    /**
     * @generated from protobuf field: int32 value = 1;
     */
    value: number;
}
/**
 * @generated from protobuf message eq.Bool
 */
export interface Bool {
    /**
     * @generated from protobuf field: bool value = 1;
     */
    value: boolean;
}
/**
 * @generated from protobuf message eq.String
 */
export interface String$ {
    /**
     * @generated from protobuf field: string value = 1;
     */
    value: string;
}
// OpCodes

/**
 * @generated from protobuf enum eq.ItemPacketType
 */
export enum ItemPacketType {
    /**
     * @generated from protobuf enum value: ItemPacketViewLink = 0;
     */
    ItemPacketViewLink = 0,
    /**
     * @generated from protobuf enum value: ItemPacketTradeView = 101;
     */
    ItemPacketTradeView = 101,
    /**
     * @generated from protobuf enum value: ItemPacketLoot = 102;
     */
    ItemPacketLoot = 102,
    /**
     * @generated from protobuf enum value: ItemPacketTrade = 103;
     */
    ItemPacketTrade = 103,
    /**
     * @generated from protobuf enum value: ItemPacketCharInventory = 105;
     */
    ItemPacketCharInventory = 105,
    /**
     * @generated from protobuf enum value: ItemPacketSummonItem = 106;
     */
    ItemPacketSummonItem = 106,
    /**
     * @generated from protobuf enum value: ItemPacketTributeItem = 108;
     */
    ItemPacketTributeItem = 108,
    /**
     * @generated from protobuf enum value: ItemPacketMerchant = 100;
     */
    ItemPacketMerchant = 100,
    /**
     * @generated from protobuf enum value: ItemPacketWorldContainer = 6;
     */
    ItemPacketWorldContainer = 6
}
/**
 * @generated from protobuf enum eq.OpCodes
 */
export enum OpCodes {
    /**
     * @generated from protobuf enum value: OP_Unknown = 0;
     */
    OP_Unknown = 0,
    /**
     * JWT
     *
     * @generated from protobuf enum value: OP_JWTLogin = 629;
     */
    OP_JWTLogin = 629,
    /**
     * @generated from protobuf enum value: OP_JWTResponse = 801;
     */
    OP_JWTResponse = 801,
    /**
     * Login
     *
     * @generated from protobuf enum value: OP_LoginAccepted = 331;
     */
    OP_LoginAccepted = 331,
    /**
     * @generated from protobuf enum value: OP_PlayEverquestRequest = 413;
     */
    OP_PlayEverquestRequest = 413,
    /**
     * @generated from protobuf enum value: OP_PlayEverquestResponse = 414;
     */
    OP_PlayEverquestResponse = 414,
    /**
     * @generated from protobuf enum value: OP_ServerListRequest = 487;
     */
    OP_ServerListRequest = 487,
    /**
     * @generated from protobuf enum value: OP_ServerListResponse = 488;
     */
    OP_ServerListResponse = 488,
    /**
     * World
     *
     * @generated from protobuf enum value: OP_ApproveName = 40;
     */
    OP_ApproveName = 40,
    /**
     * @generated from protobuf enum value: OP_CharacterCreate = 79;
     */
    OP_CharacterCreate = 79,
    /**
     * @generated from protobuf enum value: OP_DeleteCharacter = 121;
     */
    OP_DeleteCharacter = 121,
    /**
     * @generated from protobuf enum value: OP_ApproveName_Server = 5040;
     */
    OP_ApproveName_Server = 5040,
    /**
     * @generated from protobuf enum value: OP_EnterWorld = 162;
     */
    OP_EnterWorld = 162,
    /**
     * @generated from protobuf enum value: OP_ExpansionInfo = 165;
     */
    OP_ExpansionInfo = 165,
    /**
     * @generated from protobuf enum value: OP_GuildsList = 265;
     */
    OP_GuildsList = 265,
    /**
     * @generated from protobuf enum value: OP_PostEnterWorld = 419;
     */
    OP_PostEnterWorld = 419,
    /**
     * @generated from protobuf enum value: OP_SendCharInfo = 473;
     */
    OP_SendCharInfo = 473,
    /**
     * @generated from protobuf enum value: OP_SendLoginInfo = 477;
     */
    OP_SendLoginInfo = 477,
    /**
     * @generated from protobuf enum value: OP_SendMaxCharacters = 478;
     */
    OP_SendMaxCharacters = 478,
    /**
     * @generated from protobuf enum value: OP_SendMembership = 479;
     */
    OP_SendMembership = 479,
    /**
     * @generated from protobuf enum value: OP_SendMembershipDetails = 480;
     */
    OP_SendMembershipDetails = 480,
    /**
     * @generated from protobuf enum value: OP_ZoneServerInfo = 622;
     */
    OP_ZoneServerInfo = 622,
    /**
     * @generated from protobuf enum value: OP_WebInitiateConnection = 628;
     */
    OP_WebInitiateConnection = 628,
    /**
     * Zone
     *
     * @generated from protobuf enum value: OP_ZoneEntry = 618;
     */
    OP_ZoneEntry = 618,
    /**
     * @generated from protobuf enum value: OP_SetServerFilter = 497;
     */
    OP_SetServerFilter = 497,
    /**
     * @generated from protobuf enum value: OP_SendAATable = 472;
     */
    OP_SendAATable = 472,
    /**
     * @generated from protobuf enum value: OP_SendTributes = 483;
     */
    OP_SendTributes = 483,
    /**
     * @generated from protobuf enum value: OP_SendGuildTributes = 476;
     */
    OP_SendGuildTributes = 476,
    /**
     * @generated from protobuf enum value: OP_SendAAStats = 471;
     */
    OP_SendAAStats = 471,
    /**
     * @generated from protobuf enum value: OP_ReqClientSpawn = 451;
     */
    OP_ReqClientSpawn = 451,
    /**
     * @generated from protobuf enum value: OP_ReqNewZone = 452;
     */
    OP_ReqNewZone = 452,
    /**
     * @generated from protobuf enum value: OP_SendExpZonein = 474;
     */
    OP_SendExpZonein = 474,
    /**
     * @generated from protobuf enum value: OP_ClientReady = 94;
     */
    OP_ClientReady = 94,
    /**
     * @generated from protobuf enum value: OP_ClientError = 93;
     */
    OP_ClientError = 93,
    /**
     * @generated from protobuf enum value: OP_ApproveZone = 42;
     */
    OP_ApproveZone = 42,
    /**
     * @generated from protobuf enum value: OP_TGB = 559;
     */
    OP_TGB = 559,
    /**
     * @generated from protobuf enum value: OP_AckPacket = 7;
     */
    OP_AckPacket = 7,
    /**
     * @generated from protobuf enum value: OP_ClientUpdate = 96;
     */
    OP_ClientUpdate = 96,
    /**
     * @generated from protobuf enum value: OP_AutoAttack = 47;
     */
    OP_AutoAttack = 47,
    /**
     * @generated from protobuf enum value: OP_AutoAttack2 = 48;
     */
    OP_AutoAttack2 = 48,
    /**
     * @generated from protobuf enum value: OP_Consent = 104;
     */
    OP_Consent = 104,
    /**
     * @generated from protobuf enum value: OP_ConsentDeny = 105;
     */
    OP_ConsentDeny = 105,
    /**
     * @generated from protobuf enum value: OP_TargetMouse = 548;
     */
    OP_TargetMouse = 548,
    /**
     * @generated from protobuf enum value: OP_TargetCommand = 546;
     */
    OP_TargetCommand = 546,
    /**
     * @generated from protobuf enum value: OP_Shielding = 514;
     */
    OP_Shielding = 514,
    /**
     * @generated from protobuf enum value: OP_Jump = 301;
     */
    OP_Jump = 301,
    /**
     * @generated from protobuf enum value: OP_AdventureInfoRequest = 15;
     */
    OP_AdventureInfoRequest = 15,
    /**
     * @generated from protobuf enum value: OP_AdventureRequest = 23;
     */
    OP_AdventureRequest = 23,
    /**
     * @generated from protobuf enum value: OP_LDoNButton = 305;
     */
    OP_LDoNButton = 305,
    /**
     * @generated from protobuf enum value: OP_LeaveAdventure = 313;
     */
    OP_LeaveAdventure = 313,
    /**
     * @generated from protobuf enum value: OP_Consume = 109;
     */
    OP_Consume = 109,
    /**
     * @generated from protobuf enum value: OP_AdventureMerchantRequest = 19;
     */
    OP_AdventureMerchantRequest = 19,
    /**
     * @generated from protobuf enum value: OP_AdventureMerchantPurchase = 18;
     */
    OP_AdventureMerchantPurchase = 18,
    /**
     * @generated from protobuf enum value: OP_ConsiderCorpse = 108;
     */
    OP_ConsiderCorpse = 108,
    /**
     * @generated from protobuf enum value: OP_Consider = 107;
     */
    OP_Consider = 107,
    /**
     * @generated from protobuf enum value: OP_Begging = 58;
     */
    OP_Begging = 58,
    /**
     * @generated from protobuf enum value: OP_TestBuff = 558;
     */
    OP_TestBuff = 558,
    /**
     * @generated from protobuf enum value: OP_Surname = 542;
     */
    OP_Surname = 542,
    /**
     * @generated from protobuf enum value: OP_YellForHelp = 615;
     */
    OP_YellForHelp = 615,
    /**
     * @generated from protobuf enum value: OP_Assist = 43;
     */
    OP_Assist = 43,
    /**
     * @generated from protobuf enum value: OP_GMTraining = 204;
     */
    OP_GMTraining = 204,
    /**
     * @generated from protobuf enum value: OP_GMEndTraining = 191;
     */
    OP_GMEndTraining = 191,
    /**
     * @generated from protobuf enum value: OP_GMTrainSkill = 205;
     */
    OP_GMTrainSkill = 205,
    /**
     * @generated from protobuf enum value: OP_RequestDuel = 454;
     */
    OP_RequestDuel = 454,
    /**
     * @generated from protobuf enum value: OP_DuelDecline = 134;
     */
    OP_DuelDecline = 134,
    /**
     * @generated from protobuf enum value: OP_DuelAccept = 135;
     */
    OP_DuelAccept = 135,
    /**
     * @generated from protobuf enum value: OP_SpawnAppearance = 534;
     */
    OP_SpawnAppearance = 534,
    /**
     * @generated from protobuf enum value: OP_BazaarInspect = 54;
     */
    OP_BazaarInspect = 54,
    /**
     * @generated from protobuf enum value: OP_Death = 119;
     */
    OP_Death = 119,
    /**
     * @generated from protobuf enum value: OP_MoveCoin = 372;
     */
    OP_MoveCoin = 372,
    /**
     * @generated from protobuf enum value: OP_ItemLinkClick = 290;
     */
    OP_ItemLinkClick = 290,
    /**
     * @generated from protobuf enum value: OP_MoveItem = 374;
     */
    OP_MoveItem = 374,
    /**
     * @generated from protobuf enum value: OP_Camp = 70;
     */
    OP_Camp = 70,
    /**
     * @generated from protobuf enum value: OP_Logout = 336;
     */
    OP_Logout = 336,
    /**
     * @generated from protobuf enum value: OP_SenseHeading = 485;
     */
    OP_SenseHeading = 485,
    /**
     * @generated from protobuf enum value: OP_FeignDeath = 169;
     */
    OP_FeignDeath = 169,
    /**
     * @generated from protobuf enum value: OP_Sneak = 529;
     */
    OP_Sneak = 529,
    /**
     * @generated from protobuf enum value: OP_Hide = 273;
     */
    OP_Hide = 273,
    /**
     * @generated from protobuf enum value: OP_ChannelMessage = 77;
     */
    OP_ChannelMessage = 77,
    /**
     * @generated from protobuf enum value: OP_WearChange = 597;
     */
    OP_WearChange = 597,
    /**
     * @generated from protobuf enum value: OP_DeleteSpawn = 125;
     */
    OP_DeleteSpawn = 125,
    /**
     * @generated from protobuf enum value: OP_SaveOnZoneReq = 469;
     */
    OP_SaveOnZoneReq = 469,
    /**
     * @generated from protobuf enum value: OP_Save = 468;
     */
    OP_Save = 468,
    /**
     * @generated from protobuf enum value: OP_WhoAllRequest = 600;
     */
    OP_WhoAllRequest = 600,
    /**
     * @generated from protobuf enum value: OP_GMZoneRequest = 207;
     */
    OP_GMZoneRequest = 207,
    /**
     * @generated from protobuf enum value: OP_GMZoneRequest2 = 208;
     */
    OP_GMZoneRequest2 = 208,
    /**
     * @generated from protobuf enum value: OP_EndLootRequest = 159;
     */
    OP_EndLootRequest = 159,
    /**
     * @generated from protobuf enum value: OP_LootRequest = 341;
     */
    OP_LootRequest = 341,
    /**
     * @generated from protobuf enum value: OP_Dye = 137;
     */
    OP_Dye = 137,
    /**
     * @generated from protobuf enum value: OP_ConfirmDelete = 103;
     */
    OP_ConfirmDelete = 103,
    /**
     * @generated from protobuf enum value: OP_LootItem = 340;
     */
    OP_LootItem = 340,
    /**
     * @generated from protobuf enum value: OP_GuildDelete = 231;
     */
    OP_GuildDelete = 231,
    /**
     * @generated from protobuf enum value: OP_GuildPublicNote = 255;
     */
    OP_GuildPublicNote = 255,
    /**
     * @generated from protobuf enum value: OP_GetGuildsList = 185;
     */
    OP_GetGuildsList = 185,
    /**
     * @generated from protobuf enum value: OP_SetGuildMOTD = 494;
     */
    OP_SetGuildMOTD = 494,
    /**
     * @generated from protobuf enum value: OP_SetRunMode = 496;
     */
    OP_SetRunMode = 496,
    /**
     * @generated from protobuf enum value: OP_GuildPeace = 253;
     */
    OP_GuildPeace = 253,
    /**
     * @generated from protobuf enum value: OP_GuildWar = 271;
     */
    OP_GuildWar = 271,
    /**
     * @generated from protobuf enum value: OP_GuildLeader = 236;
     */
    OP_GuildLeader = 236,
    /**
     * @generated from protobuf enum value: OP_GuildDemote = 233;
     */
    OP_GuildDemote = 233,
    /**
     * @generated from protobuf enum value: OP_GuildInvite = 234;
     */
    OP_GuildInvite = 234,
    /**
     * @generated from protobuf enum value: OP_GuildRemove = 256;
     */
    OP_GuildRemove = 256,
    /**
     * @generated from protobuf enum value: OP_GuildInviteAccept = 235;
     */
    OP_GuildInviteAccept = 235,
    /**
     * @generated from protobuf enum value: OP_ManaChange = 342;
     */
    OP_ManaChange = 342,
    /**
     * @generated from protobuf enum value: OP_MemorizeSpell = 347;
     */
    OP_MemorizeSpell = 347,
    /**
     * @generated from protobuf enum value: OP_SwapSpell = 543;
     */
    OP_SwapSpell = 543,
    /**
     * @generated from protobuf enum value: OP_CastSpell = 75;
     */
    OP_CastSpell = 75,
    /**
     * @generated from protobuf enum value: OP_DeleteItem = 123;
     */
    OP_DeleteItem = 123,
    /**
     * @generated from protobuf enum value: OP_CombatAbility = 100;
     */
    OP_CombatAbility = 100,
    /**
     * @generated from protobuf enum value: OP_Taunt = 557;
     */
    OP_Taunt = 557,
    /**
     * @generated from protobuf enum value: OP_InstillDoubt = 284;
     */
    OP_InstillDoubt = 284,
    /**
     * @generated from protobuf enum value: OP_RezzAnswer = 462;
     */
    OP_RezzAnswer = 462,
    /**
     * @generated from protobuf enum value: OP_GMSummon = 202;
     */
    OP_GMSummon = 202,
    /**
     * @generated from protobuf enum value: OP_TradeBusy = 565;
     */
    OP_TradeBusy = 565,
    /**
     * @generated from protobuf enum value: OP_TradeRequest = 572;
     */
    OP_TradeRequest = 572,
    /**
     * @generated from protobuf enum value: OP_TradeRequestAck = 573;
     */
    OP_TradeRequestAck = 573,
    /**
     * @generated from protobuf enum value: OP_CancelTrade = 73;
     */
    OP_CancelTrade = 73,
    /**
     * @generated from protobuf enum value: OP_TradeAcceptClick = 564;
     */
    OP_TradeAcceptClick = 564,
    /**
     * @generated from protobuf enum value: OP_BoardBoat = 62;
     */
    OP_BoardBoat = 62,
    /**
     * @generated from protobuf enum value: OP_LeaveBoat = 314;
     */
    OP_LeaveBoat = 314,
    /**
     * @generated from protobuf enum value: OP_RandomReq = 437;
     */
    OP_RandomReq = 437,
    /**
     * @generated from protobuf enum value: OP_Buff = 64;
     */
    OP_Buff = 64,
    /**
     * @generated from protobuf enum value: OP_GMHideMe = 195;
     */
    OP_GMHideMe = 195,
    /**
     * @generated from protobuf enum value: OP_GMNameChange = 199;
     */
    OP_GMNameChange = 199,
    /**
     * @generated from protobuf enum value: OP_GMKill = 197;
     */
    OP_GMKill = 197,
    /**
     * @generated from protobuf enum value: OP_GMLastName = 198;
     */
    OP_GMLastName = 198,
    /**
     * @generated from protobuf enum value: OP_GMToggle = 203;
     */
    OP_GMToggle = 203,
    /**
     * @generated from protobuf enum value: OP_LFGCommand = 318;
     */
    OP_LFGCommand = 318,
    /**
     * @generated from protobuf enum value: OP_GMGoto = 194;
     */
    OP_GMGoto = 194,
    /**
     * @generated from protobuf enum value: OP_TraderShop = 575;
     */
    OP_TraderShop = 575,
    /**
     * @generated from protobuf enum value: OP_ShopRequest = 526;
     */
    OP_ShopRequest = 526,
    /**
     * @generated from protobuf enum value: OP_Bazaar = 53;
     */
    OP_Bazaar = 53,
    /**
     * @generated from protobuf enum value: OP_ShopPlayerBuy = 519;
     */
    OP_ShopPlayerBuy = 519,
    /**
     * @generated from protobuf enum value: OP_ShopPlayerSell = 520;
     */
    OP_ShopPlayerSell = 520,
    /**
     * @generated from protobuf enum value: OP_ShopEnd = 516;
     */
    OP_ShopEnd = 516,
    /**
     * @generated from protobuf enum value: OP_CloseContainer = 97;
     */
    OP_CloseContainer = 97,
    /**
     * @generated from protobuf enum value: OP_ClickObjectAction = 92;
     */
    OP_ClickObjectAction = 92,
    /**
     * @generated from protobuf enum value: OP_ClickObject = 91;
     */
    OP_ClickObject = 91,
    /**
     * @generated from protobuf enum value: OP_RecipesFavorite = 442;
     */
    OP_RecipesFavorite = 442,
    /**
     * @generated from protobuf enum value: OP_RecipesSearch = 443;
     */
    OP_RecipesSearch = 443,
    /**
     * @generated from protobuf enum value: OP_RecipeDetails = 440;
     */
    OP_RecipeDetails = 440,
    /**
     * @generated from protobuf enum value: OP_RecipeAutoCombine = 439;
     */
    OP_RecipeAutoCombine = 439,
    /**
     * @generated from protobuf enum value: OP_TradeSkillCombine = 576;
     */
    OP_TradeSkillCombine = 576,
    /**
     * @generated from protobuf enum value: OP_ItemName = 293;
     */
    OP_ItemName = 293,
    /**
     * @generated from protobuf enum value: OP_AugmentItem = 46;
     */
    OP_AugmentItem = 46,
    /**
     * @generated from protobuf enum value: OP_ClickDoor = 90;
     */
    OP_ClickDoor = 90,
    /**
     * @generated from protobuf enum value: OP_FaceChange = 167;
     */
    OP_FaceChange = 167,
    /**
     * @generated from protobuf enum value: OP_GroupInvite = 218;
     */
    OP_GroupInvite = 218,
    /**
     * @generated from protobuf enum value: OP_GroupInvite2 = 219;
     */
    OP_GroupInvite2 = 219,
    /**
     * @generated from protobuf enum value: OP_GroupFollow = 216;
     */
    OP_GroupFollow = 216,
    /**
     * @generated from protobuf enum value: OP_GroupFollow2 = 217;
     */
    OP_GroupFollow2 = 217,
    /**
     * @generated from protobuf enum value: OP_GroupAcknowledge = 210;
     */
    OP_GroupAcknowledge = 210,
    /**
     * @generated from protobuf enum value: OP_GroupCancelInvite = 211;
     */
    OP_GroupCancelInvite = 211,
    /**
     * @generated from protobuf enum value: OP_GroupDisband = 213;
     */
    OP_GroupDisband = 213,
    /**
     * @generated from protobuf enum value: OP_GroupDelete = 212;
     */
    OP_GroupDelete = 212,
    /**
     * @generated from protobuf enum value: OP_GMEmoteZone = 190;
     */
    OP_GMEmoteZone = 190,
    /**
     * @generated from protobuf enum value: OP_InspectRequest = 283;
     */
    OP_InspectRequest = 283,
    /**
     * @generated from protobuf enum value: OP_InspectAnswer = 280;
     */
    OP_InspectAnswer = 280,
    /**
     * @generated from protobuf enum value: OP_DeleteSpell = 126;
     */
    OP_DeleteSpell = 126,
    /**
     * @generated from protobuf enum value: OP_PetitionBug = 394;
     */
    OP_PetitionBug = 394,
    /**
     * @generated from protobuf enum value: OP_Bug = 67;
     */
    OP_Bug = 67,
    /**
     * @generated from protobuf enum value: OP_Petition = 393;
     */
    OP_Petition = 393,
    /**
     * @generated from protobuf enum value: OP_PetitionCheckIn = 395;
     */
    OP_PetitionCheckIn = 395,
    /**
     * @generated from protobuf enum value: OP_PetitionResolve = 401;
     */
    OP_PetitionResolve = 401,
    /**
     * @generated from protobuf enum value: OP_PetitionDelete = 398;
     */
    OP_PetitionDelete = 398,
    /**
     * @generated from protobuf enum value: OP_PetitionUnCheckout = 405;
     */
    OP_PetitionUnCheckout = 405,
    /**
     * @generated from protobuf enum value: OP_PetitionQue = 399;
     */
    OP_PetitionQue = 399,
    /**
     * @generated from protobuf enum value: OP_PDeletePetition = 388;
     */
    OP_PDeletePetition = 388,
    /**
     * @generated from protobuf enum value: OP_PetitionCheckout = 396;
     */
    OP_PetitionCheckout = 396,
    /**
     * @generated from protobuf enum value: OP_PetitionRefresh = 400;
     */
    OP_PetitionRefresh = 400,
    /**
     * @generated from protobuf enum value: OP_PetCommands = 390;
     */
    OP_PetCommands = 390,
    /**
     * @generated from protobuf enum value: OP_ReadBook = 438;
     */
    OP_ReadBook = 438,
    /**
     * @generated from protobuf enum value: OP_Emote = 158;
     */
    OP_Emote = 158,
    /**
     * @generated from protobuf enum value: OP_GMDelCorpse = 189;
     */
    OP_GMDelCorpse = 189,
    /**
     * @generated from protobuf enum value: OP_GMKick = 196;
     */
    OP_GMKick = 196,
    /**
     * @generated from protobuf enum value: OP_GMServers = 201;
     */
    OP_GMServers = 201,
    /**
     * @generated from protobuf enum value: OP_Illusion = 276;
     */
    OP_Illusion = 276,
    /**
     * @generated from protobuf enum value: OP_GMBecomeNPC = 188;
     */
    OP_GMBecomeNPC = 188,
    /**
     * @generated from protobuf enum value: OP_Fishing = 176;
     */
    OP_Fishing = 176,
    /**
     * @generated from protobuf enum value: OP_Forage = 179;
     */
    OP_Forage = 179,
    /**
     * @generated from protobuf enum value: OP_Mend = 348;
     */
    OP_Mend = 348,
    /**
     * @generated from protobuf enum value: OP_EnvDamage = 163;
     */
    OP_EnvDamage = 163,
    /**
     * @generated from protobuf enum value: OP_Damage = 118;
     */
    OP_Damage = 118,
    /**
     * @generated from protobuf enum value: OP_AAAction = 4;
     */
    OP_AAAction = 4,
    /**
     * @generated from protobuf enum value: OP_TraderBuy = 570;
     */
    OP_TraderBuy = 570,
    /**
     * @generated from protobuf enum value: OP_Trader = 568;
     */
    OP_Trader = 568,
    /**
     * @generated from protobuf enum value: OP_GMFind = 193;
     */
    OP_GMFind = 193,
    /**
     * @generated from protobuf enum value: OP_PickPocket = 407;
     */
    OP_PickPocket = 407,
    /**
     * @generated from protobuf enum value: OP_Bind_Wound = 60;
     */
    OP_Bind_Wound = 60,
    /**
     * @generated from protobuf enum value: OP_TrackTarget = 562;
     */
    OP_TrackTarget = 562,
    /**
     * @generated from protobuf enum value: OP_Track = 561;
     */
    OP_Track = 561,
    /**
     * @generated from protobuf enum value: OP_TrackUnknown = 563;
     */
    OP_TrackUnknown = 563,
    /**
     * @generated from protobuf enum value: OP_ReloadUI = 445;
     */
    OP_ReloadUI = 445,
    /**
     * @generated from protobuf enum value: OP_Split = 539;
     */
    OP_Split = 539,
    /**
     * @generated from protobuf enum value: OP_SenseTraps = 486;
     */
    OP_SenseTraps = 486,
    /**
     * @generated from protobuf enum value: OP_DisarmTraps = 129;
     */
    OP_DisarmTraps = 129,
    /**
     * @generated from protobuf enum value: OP_OpenTributeMaster = 387;
     */
    OP_OpenTributeMaster = 387,
    /**
     * @generated from protobuf enum value: OP_OpenGuildTributeMaster = 385;
     */
    OP_OpenGuildTributeMaster = 385,
    /**
     * @generated from protobuf enum value: OP_TributeItem = 580;
     */
    OP_TributeItem = 580,
    /**
     * @generated from protobuf enum value: OP_TributeMoney = 581;
     */
    OP_TributeMoney = 581,
    /**
     * @generated from protobuf enum value: OP_SelectTribute = 470;
     */
    OP_SelectTribute = 470,
    /**
     * @generated from protobuf enum value: OP_TributeUpdate = 586;
     */
    OP_TributeUpdate = 586,
    /**
     * @generated from protobuf enum value: OP_TributeToggle = 585;
     */
    OP_TributeToggle = 585,
    /**
     * @generated from protobuf enum value: OP_TributeNPC = 582;
     */
    OP_TributeNPC = 582,
    /**
     * @generated from protobuf enum value: OP_CrashDump = 113;
     */
    OP_CrashDump = 113,
    /**
     * @generated from protobuf enum value: OP_ControlBoat = 110;
     */
    OP_ControlBoat = 110,
    /**
     * @generated from protobuf enum value: OP_DumpName = 136;
     */
    OP_DumpName = 136,
    /**
     * @generated from protobuf enum value: OP_SafeFallSuccess = 466;
     */
    OP_SafeFallSuccess = 466,
    /**
     * @generated from protobuf enum value: OP_Heartbeat = 272;
     */
    OP_Heartbeat = 272,
    /**
     * @generated from protobuf enum value: OP_SafePoint = 467;
     */
    OP_SafePoint = 467,
    /**
     * @generated from protobuf enum value: OP_FindPersonRequest = 172;
     */
    OP_FindPersonRequest = 172,
    /**
     * @generated from protobuf enum value: OP_LeadershipExpToggle = 311;
     */
    OP_LeadershipExpToggle = 311,
    /**
     * @generated from protobuf enum value: OP_PurchaseLeadershipAA = 422;
     */
    OP_PurchaseLeadershipAA = 422,
    /**
     * @generated from protobuf enum value: OP_BankerChange = 51;
     */
    OP_BankerChange = 51,
    /**
     * @generated from protobuf enum value: OP_SetTitle = 499;
     */
    OP_SetTitle = 499,
    /**
     * @generated from protobuf enum value: OP_RequestTitles = 457;
     */
    OP_RequestTitles = 457,
    /**
     * @generated from protobuf enum value: OP_ItemVerifyRequest = 299;
     */
    OP_ItemVerifyRequest = 299,
    /**
     * @generated from protobuf enum value: OP_ClearObject = 88;
     */
    OP_ClearObject = 88,
    /**
     * @generated from protobuf enum value: OP_FinishTrade = 173;
     */
    OP_FinishTrade = 173,
    /**
     * @generated from protobuf enum value: OP_GMEndTrainingResponse = 192;
     */
    OP_GMEndTrainingResponse = 192,
    /**
     * @generated from protobuf enum value: OP_LootComplete = 339;
     */
    OP_LootComplete = 339,
    /**
     * @generated from protobuf enum value: OP_WorldObjectsSent = 608;
     */
    OP_WorldObjectsSent = 608,
    /**
     * @generated from protobuf enum value: OP_FinishWindow = 174;
     */
    OP_FinishWindow = 174,
    /**
     * @generated from protobuf enum value: OP_FinishWindow2 = 175;
     */
    OP_FinishWindow2 = 175,
    /**
     * @generated from protobuf enum value: OP_ItemPacket = 294;
     */
    OP_ItemPacket = 294,
    /**
     * @generated from protobuf enum value: OP_ColoredText = 99;
     */
    OP_ColoredText = 99,
    /**
     * @generated from protobuf enum value: OP_ItemRecastDelay = 297;
     */
    OP_ItemRecastDelay = 297,
    /**
     * @generated from protobuf enum value: OP_FormattedMessage = 181;
     */
    OP_FormattedMessage = 181,
    /**
     * @generated from protobuf enum value: OP_GuildMemberList = 242;
     */
    OP_GuildMemberList = 242,
    /**
     * @generated from protobuf enum value: OP_InterruptCast = 285;
     */
    OP_InterruptCast = 285,
    /**
     * @generated from protobuf enum value: OP_ItemLinkResponse = 291;
     */
    OP_ItemLinkResponse = 291,
    /**
     * @generated from protobuf enum value: OP_ZoneSpawns = 624;
     */
    OP_ZoneSpawns = 624,
    /**
     * @generated from protobuf enum value: OP_CompletedTasks = 102;
     */
    OP_CompletedTasks = 102,
    /**
     * @generated from protobuf enum value: OP_CharInventory = 81;
     */
    OP_CharInventory = 81,
    /**
     * @generated from protobuf enum value: OP_CustomTitles = 117;
     */
    OP_CustomTitles = 117,
    /**
     * @generated from protobuf enum value: OP_SpawnDoor = 535;
     */
    OP_SpawnDoor = 535,
    /**
     * @generated from protobuf enum value: OP_SendZonepoints = 484;
     */
    OP_SendZonepoints = 484,
    /**
     * @generated from protobuf enum value: OP_TributeInfo = 579;
     */
    OP_TributeInfo = 579,
    /**
     * @generated from protobuf enum value: OP_GuildTributeInfo = 267;
     */
    OP_GuildTributeInfo = 267,
    /**
     * @generated from protobuf enum value: OP_SendTitleList = 482;
     */
    OP_SendTitleList = 482,
    /**
     * @generated from protobuf enum value: OP_AAExpUpdate = 5;
     */
    OP_AAExpUpdate = 5,
    /**
     * @generated from protobuf enum value: OP_Action = 8;
     */
    OP_Action = 8,
    /**
     * @generated from protobuf enum value: OP_AdventureData = 11;
     */
    OP_AdventureData = 11,
    /**
     * @generated from protobuf enum value: OP_AdventureFinish = 13;
     */
    OP_AdventureFinish = 13,
    /**
     * @generated from protobuf enum value: OP_AdventurePointsUpdate = 22;
     */
    OP_AdventurePointsUpdate = 22,
    /**
     * @generated from protobuf enum value: OP_Animation = 37;
     */
    OP_Animation = 37,
    /**
     * @generated from protobuf enum value: OP_AnnoyingZoneUnknown = 38;
     */
    OP_AnnoyingZoneUnknown = 38,
    /**
     * @generated from protobuf enum value: OP_BecomeTrader = 57;
     */
    OP_BecomeTrader = 57,
    /**
     * @generated from protobuf enum value: OP_BeginCast = 59;
     */
    OP_BeginCast = 59,
    /**
     * @generated from protobuf enum value: OP_Charm = 82;
     */
    OP_Charm = 82,
    /**
     * @generated from protobuf enum value: OP_CameraEffect = 69;
     */
    OP_CameraEffect = 69,
    /**
     * @generated from protobuf enum value: OP_ConsentResponse = 106;
     */
    OP_ConsentResponse = 106,
    /**
     * @generated from protobuf enum value: OP_EnduranceUpdate = 160;
     */
    OP_EnduranceUpdate = 160,
    /**
     * @generated from protobuf enum value: OP_ExpUpdate = 166;
     */
    OP_ExpUpdate = 166,
    /**
     * @generated from protobuf enum value: OP_GroundSpawn = 209;
     */
    OP_GroundSpawn = 209,
    /**
     * @generated from protobuf enum value: OP_GroupUpdate = 225;
     */
    OP_GroupUpdate = 225,
    /**
     * @generated from protobuf enum value: OP_GuildMOTD = 252;
     */
    OP_GuildMOTD = 252,
    /**
     * @generated from protobuf enum value: OP_GuildManageAdd = 237;
     */
    OP_GuildManageAdd = 237,
    /**
     * @generated from protobuf enum value: OP_GuildManageRemove = 239;
     */
    OP_GuildManageRemove = 239,
    /**
     * @generated from protobuf enum value: OP_GuildManageStatus = 240;
     */
    OP_GuildManageStatus = 240,
    /**
     * @generated from protobuf enum value: OP_GuildMemberUpdate = 243;
     */
    OP_GuildMemberUpdate = 243,
    /**
     * @generated from protobuf enum value: OP_HPUpdate = 275;
     */
    OP_HPUpdate = 275,
    /**
     * @generated from protobuf enum value: OP_IncreaseStats = 277;
     */
    OP_IncreaseStats = 277,
    /**
     * @generated from protobuf enum value: OP_ItemVerifyReply = 298;
     */
    OP_ItemVerifyReply = 298,
    /**
     * @generated from protobuf enum value: OP_LFGAppearance = 317;
     */
    OP_LFGAppearance = 317,
    /**
     * @generated from protobuf enum value: OP_LeadershipExpUpdate = 312;
     */
    OP_LeadershipExpUpdate = 312,
    /**
     * @generated from protobuf enum value: OP_LevelAppearance = 315;
     */
    OP_LevelAppearance = 315,
    /**
     * @generated from protobuf enum value: OP_LevelUpdate = 316;
     */
    OP_LevelUpdate = 316,
    /**
     * @generated from protobuf enum value: OP_ManaUpdate = 343;
     */
    OP_ManaUpdate = 343,
    /**
     * @generated from protobuf enum value: OP_MobEnduranceUpdate = 364;
     */
    OP_MobEnduranceUpdate = 364,
    /**
     * @generated from protobuf enum value: OP_MobHealth = 365;
     */
    OP_MobHealth = 365,
    /**
     * @generated from protobuf enum value: OP_MobManaUpdate = 366;
     */
    OP_MobManaUpdate = 366,
    /**
     * @generated from protobuf enum value: OP_MobRename = 367;
     */
    OP_MobRename = 367,
    /**
     * @generated from protobuf enum value: OP_MoneyOnCorpse = 369;
     */
    OP_MoneyOnCorpse = 369,
    /**
     * @generated from protobuf enum value: OP_MoneyUpdate = 370;
     */
    OP_MoneyUpdate = 370,
    /**
     * @generated from protobuf enum value: OP_MoveDoor = 373;
     */
    OP_MoveDoor = 373,
    /**
     * @generated from protobuf enum value: OP_NewSpawn = 379;
     */
    OP_NewSpawn = 379,
    /**
     * @generated from protobuf enum value: OP_NewZone = 381;
     */
    OP_NewZone = 381,
    /**
     * @generated from protobuf enum value: OP_PetitionUpdate = 406;
     */
    OP_PetitionUpdate = 406,
    /**
     * @generated from protobuf enum value: OP_PlayerProfile = 410;
     */
    OP_PlayerProfile = 410,
    /**
     * @generated from protobuf enum value: OP_RaidUpdate = 434;
     */
    OP_RaidUpdate = 434,
    /**
     * @generated from protobuf enum value: OP_RandomReply = 436;
     */
    OP_RandomReply = 436,
    /**
     * @generated from protobuf enum value: OP_RecipeReply = 441;
     */
    OP_RecipeReply = 441,
    /**
     * @generated from protobuf enum value: OP_RequestClientZoneChange = 453;
     */
    OP_RequestClientZoneChange = 453,
    /**
     * @generated from protobuf enum value: OP_RespondAA = 459;
     */
    OP_RespondAA = 459,
    /**
     * @generated from protobuf enum value: OP_RezzRequest = 464;
     */
    OP_RezzRequest = 464,
    /**
     * @generated from protobuf enum value: OP_SetTitleReply = 500;
     */
    OP_SetTitleReply = 500,
    /**
     * @generated from protobuf enum value: OP_ShopDelItem = 515;
     */
    OP_ShopDelItem = 515,
    /**
     * @generated from protobuf enum value: OP_SimpleMessage = 527;
     */
    OP_SimpleMessage = 527,
    /**
     * @generated from protobuf enum value: OP_SkillUpdate = 528;
     */
    OP_SkillUpdate = 528,
    /**
     * @generated from protobuf enum value: OP_SomeItemPacketMaybe = 532;
     */
    OP_SomeItemPacketMaybe = 532,
    /**
     * @generated from protobuf enum value: OP_SpellEffect = 538;
     */
    OP_SpellEffect = 538,
    /**
     * @generated from protobuf enum value: OP_Stamina = 540;
     */
    OP_Stamina = 540,
    /**
     * @generated from protobuf enum value: OP_Stun = 541;
     */
    OP_Stun = 541,
    /**
     * @generated from protobuf enum value: OP_TargetReject = 549;
     */
    OP_TargetReject = 549,
    /**
     * @generated from protobuf enum value: OP_TimeOfDay = 560;
     */
    OP_TimeOfDay = 560,
    /**
     * @generated from protobuf enum value: OP_TradeCoins = 566;
     */
    OP_TradeCoins = 566,
    /**
     * @generated from protobuf enum value: OP_TradeMoneyUpdate = 567;
     */
    OP_TradeMoneyUpdate = 567,
    /**
     * @generated from protobuf enum value: OP_TraderDelItem = 571;
     */
    OP_TraderDelItem = 571,
    /**
     * @generated from protobuf enum value: OP_TraderItemUpdate = 574;
     */
    OP_TraderItemUpdate = 574,
    /**
     * @generated from protobuf enum value: OP_TributeTimer = 584;
     */
    OP_TributeTimer = 584,
    /**
     * @generated from protobuf enum value: OP_UpdateLeadershipAA = 590;
     */
    OP_UpdateLeadershipAA = 590,
    /**
     * @generated from protobuf enum value: OP_Weather = 598;
     */
    OP_Weather = 598,
    /**
     * @generated from protobuf enum value: OP_ZoneChange = 616;
     */
    OP_ZoneChange = 616,
    /**
     * @generated from protobuf enum value: OP_ZoneInUnknown = 620;
     */
    OP_ZoneInUnknown = 620,
    /**
     * @generated from protobuf enum value: OP_AcceptNewTask = 6;
     */
    OP_AcceptNewTask = 6,
    /**
     * @generated from protobuf enum value: OP_AdventureInfo = 14;
     */
    OP_AdventureInfo = 14,
    /**
     * @generated from protobuf enum value: OP_ApplyPoison = 39;
     */
    OP_ApplyPoison = 39,
    /**
     * @generated from protobuf enum value: OP_ApproveWorld = 41;
     */
    OP_ApproveWorld = 41,
    /**
     * @generated from protobuf enum value: OP_Bandolier = 50;
     */
    OP_Bandolier = 50,
    /**
     * @generated from protobuf enum value: OP_BazaarSearch = 55;
     */
    OP_BazaarSearch = 55,
    /**
     * @generated from protobuf enum value: OP_BecomeCorpse = 56;
     */
    OP_BecomeCorpse = 56,
    /**
     * @generated from protobuf enum value: OP_CancelTask = 72;
     */
    OP_CancelTask = 72,
    /**
     * @generated from protobuf enum value: OP_Command = 101;
     */
    OP_Command = 101,
    /**
     * @generated from protobuf enum value: OP_DynamicWall = 138;
     */
    OP_DynamicWall = 138,
    /**
     * @generated from protobuf enum value: OP_LFGuild = 322;
     */
    OP_LFGuild = 322,
    /**
     * @generated from protobuf enum value: OP_LoadSpellSet = 327;
     */
    OP_LoadSpellSet = 327,
    /**
     * @generated from protobuf enum value: OP_LogServer = 338;
     */
    OP_LogServer = 338,
    /**
     * @generated from protobuf enum value: OP_MOTD = 371;
     */
    OP_MOTD = 371,
    /**
     * @generated from protobuf enum value: OP_OnLevelMessage = 382;
     */
    OP_OnLevelMessage = 382,
    /**
     * @generated from protobuf enum value: OP_PlayMP3 = 415;
     */
    OP_PlayMP3 = 415,
    /**
     * @generated from protobuf enum value: OP_PotionBelt = 420;
     */
    OP_PotionBelt = 420,
    /**
     * @generated from protobuf enum value: OP_PVPStats = 427;
     */
    OP_PVPStats = 427,
    /**
     * @generated from protobuf enum value: OP_Report = 450;
     */
    OP_Report = 450,
    /**
     * @generated from protobuf enum value: OP_SpecialMesg = 537;
     */
    OP_SpecialMesg = 537,
    /**
     * @generated from protobuf enum value: OP_TaskActivity = 550;
     */
    OP_TaskActivity = 550,
    /**
     * @generated from protobuf enum value: OP_TaskDescription = 552;
     */
    OP_TaskDescription = 552,
    /**
     * @generated from protobuf enum value: OP_ZoneUnavail = 625;
     */
    OP_ZoneUnavail = 625,
    /**
     * World
     *
     * @generated from protobuf enum value: Nested_WorldServer = 1000;
     */
    Nested_WorldServer = 1000,
    /**
     * @generated from protobuf enum value: Nested_CharacterSelectEntry = 1001;
     */
    Nested_CharacterSelectEntry = 1001,
    /**
     * @generated from protobuf enum value: Nested_CharSelectEquip = 1002;
     */
    Nested_CharSelectEquip = 1002,
    /**
     * @generated from protobuf enum value: Nested_Tint = 1003;
     */
    Nested_Tint = 1003,
    /**
     * @generated from protobuf enum value: Nested_StringList = 1004;
     */
    Nested_StringList = 1004,
    /**
     * EQEmu OP Codes Unhandled
     *
     * @generated from protobuf enum value: OP_ExploreUnknown = 1;
     */
    OP_ExploreUnknown = 1,
    /**
     * @generated from protobuf enum value: OP_0x0193 = 2;
     */
    OP_0x0193 = 2,
    /**
     * @generated from protobuf enum value: OP_0x0347 = 3;
     */
    OP_0x0347 = 3,
    /**
     * @generated from protobuf enum value: OP_Action2 = 9;
     */
    OP_Action2 = 9,
    /**
     * @generated from protobuf enum value: OP_AddNimbusEffect = 10;
     */
    OP_AddNimbusEffect = 10,
    /**
     * @generated from protobuf enum value: OP_AdventureDetails = 12;
     */
    OP_AdventureDetails = 12,
    /**
     * @generated from protobuf enum value: OP_AdventureLeaderboardReply = 16;
     */
    OP_AdventureLeaderboardReply = 16,
    /**
     * @generated from protobuf enum value: OP_AdventureLeaderboardRequest = 17;
     */
    OP_AdventureLeaderboardRequest = 17,
    /**
     * @generated from protobuf enum value: OP_AdventureMerchantResponse = 20;
     */
    OP_AdventureMerchantResponse = 20,
    /**
     * @generated from protobuf enum value: OP_AdventureMerchantSell = 21;
     */
    OP_AdventureMerchantSell = 21,
    /**
     * @generated from protobuf enum value: OP_AdventureStatsReply = 24;
     */
    OP_AdventureStatsReply = 24,
    /**
     * @generated from protobuf enum value: OP_AdventureStatsRequest = 25;
     */
    OP_AdventureStatsRequest = 25,
    /**
     * @generated from protobuf enum value: OP_AdventureUpdate = 26;
     */
    OP_AdventureUpdate = 26,
    /**
     * @generated from protobuf enum value: OP_AggroMeterLockTarget = 27;
     */
    OP_AggroMeterLockTarget = 27,
    /**
     * @generated from protobuf enum value: OP_AggroMeterTargetInfo = 28;
     */
    OP_AggroMeterTargetInfo = 28,
    /**
     * @generated from protobuf enum value: OP_AggroMeterUpdate = 29;
     */
    OP_AggroMeterUpdate = 29,
    /**
     * @generated from protobuf enum value: OP_AltCurrency = 30;
     */
    OP_AltCurrency = 30,
    /**
     * @generated from protobuf enum value: OP_AltCurrencyMerchantReply = 31;
     */
    OP_AltCurrencyMerchantReply = 31,
    /**
     * @generated from protobuf enum value: OP_AltCurrencyMerchantRequest = 32;
     */
    OP_AltCurrencyMerchantRequest = 32,
    /**
     * @generated from protobuf enum value: OP_AltCurrencyPurchase = 33;
     */
    OP_AltCurrencyPurchase = 33,
    /**
     * @generated from protobuf enum value: OP_AltCurrencyReclaim = 34;
     */
    OP_AltCurrencyReclaim = 34,
    /**
     * @generated from protobuf enum value: OP_AltCurrencySell = 35;
     */
    OP_AltCurrencySell = 35,
    /**
     * @generated from protobuf enum value: OP_AltCurrencySellSelection = 36;
     */
    OP_AltCurrencySellSelection = 36,
    /**
     * @generated from protobuf enum value: OP_AssistGroup = 44;
     */
    OP_AssistGroup = 44,
    /**
     * @generated from protobuf enum value: OP_AugmentInfo = 45;
     */
    OP_AugmentInfo = 45,
    /**
     * @generated from protobuf enum value: OP_AutoFire = 49;
     */
    OP_AutoFire = 49,
    /**
     * @generated from protobuf enum value: OP_Barter = 52;
     */
    OP_Barter = 52,
    /**
     * @generated from protobuf enum value: OP_BlockedBuffs = 61;
     */
    OP_BlockedBuffs = 61,
    /**
     * @generated from protobuf enum value: OP_BookButton = 63;
     */
    OP_BookButton = 63,
    /**
     * @generated from protobuf enum value: OP_BuffCreate = 65;
     */
    OP_BuffCreate = 65,
    /**
     * @generated from protobuf enum value: OP_BuffRemoveRequest = 66;
     */
    OP_BuffRemoveRequest = 66,
    /**
     * @generated from protobuf enum value: OP_CancelSneakHide = 71;
     */
    OP_CancelSneakHide = 71,
    /**
     * @generated from protobuf enum value: OP_CashReward = 74;
     */
    OP_CashReward = 74,
    /**
     * @generated from protobuf enum value: OP_ChangeSize = 76;
     */
    OP_ChangeSize = 76,
    /**
     * @generated from protobuf enum value: OP_CharacterCreateRequest = 80;
     */
    OP_CharacterCreateRequest = 80,
    /**
     * @generated from protobuf enum value: OP_ChatMessage = 83;
     */
    OP_ChatMessage = 83,
    /**
     * @generated from protobuf enum value: OP_ClearAA = 84;
     */
    OP_ClearAA = 84,
    /**
     * @generated from protobuf enum value: OP_ClearBlockedBuffs = 85;
     */
    OP_ClearBlockedBuffs = 85,
    /**
     * @generated from protobuf enum value: OP_ClearLeadershipAbilities = 86;
     */
    OP_ClearLeadershipAbilities = 86,
    /**
     * @generated from protobuf enum value: OP_ClearNPCMarks = 87;
     */
    OP_ClearNPCMarks = 87,
    /**
     * @generated from protobuf enum value: OP_ClearSurname = 89;
     */
    OP_ClearSurname = 89,
    /**
     * @generated from protobuf enum value: OP_ClientTimeStamp = 95;
     */
    OP_ClientTimeStamp = 95,
    /**
     * @generated from protobuf enum value: OP_CloseTributeMaster = 98;
     */
    OP_CloseTributeMaster = 98,
    /**
     * @generated from protobuf enum value: OP_CorpseDrag = 111;
     */
    OP_CorpseDrag = 111,
    /**
     * @generated from protobuf enum value: OP_CorpseDrop = 112;
     */
    OP_CorpseDrop = 112,
    /**
     * @generated from protobuf enum value: OP_CrystalCountUpdate = 114;
     */
    OP_CrystalCountUpdate = 114,
    /**
     * @generated from protobuf enum value: OP_CrystalCreate = 115;
     */
    OP_CrystalCreate = 115,
    /**
     * @generated from protobuf enum value: OP_CrystalReclaim = 116;
     */
    OP_CrystalReclaim = 116,
    /**
     * @generated from protobuf enum value: OP_DelegateAbility = 120;
     */
    OP_DelegateAbility = 120,
    /**
     * @generated from protobuf enum value: OP_DeleteCharge = 122;
     */
    OP_DeleteCharge = 122,
    /**
     * @generated from protobuf enum value: OP_DeletePetition = 124;
     */
    OP_DeletePetition = 124,
    /**
     * @generated from protobuf enum value: OP_DenyResponse = 127;
     */
    OP_DenyResponse = 127,
    /**
     * @generated from protobuf enum value: OP_Disarm = 128;
     */
    OP_Disarm = 128,
    /**
     * @generated from protobuf enum value: OP_DisciplineTimer = 130;
     */
    OP_DisciplineTimer = 130,
    /**
     * @generated from protobuf enum value: OP_DisciplineUpdate = 131;
     */
    OP_DisciplineUpdate = 131,
    /**
     * @generated from protobuf enum value: OP_DiscordMerchantInventory = 132;
     */
    OP_DiscordMerchantInventory = 132,
    /**
     * @generated from protobuf enum value: OP_DoGroupLeadershipAbility = 133;
     */
    OP_DoGroupLeadershipAbility = 133,
    /**
     * @generated from protobuf enum value: OP_DzAddPlayer = 139;
     */
    OP_DzAddPlayer = 139,
    /**
     * @generated from protobuf enum value: OP_DzChooseZone = 140;
     */
    OP_DzChooseZone = 140,
    /**
     * @generated from protobuf enum value: OP_DzChooseZoneReply = 141;
     */
    OP_DzChooseZoneReply = 141,
    /**
     * @generated from protobuf enum value: OP_DzCompass = 142;
     */
    OP_DzCompass = 142,
    /**
     * @generated from protobuf enum value: OP_DzExpeditionEndsWarning = 143;
     */
    OP_DzExpeditionEndsWarning = 143,
    /**
     * @generated from protobuf enum value: OP_DzExpeditionInfo = 144;
     */
    OP_DzExpeditionInfo = 144,
    /**
     * @generated from protobuf enum value: OP_DzExpeditionInvite = 145;
     */
    OP_DzExpeditionInvite = 145,
    /**
     * @generated from protobuf enum value: OP_DzExpeditionInviteResponse = 146;
     */
    OP_DzExpeditionInviteResponse = 146,
    /**
     * @generated from protobuf enum value: OP_DzExpeditionLockoutTimers = 147;
     */
    OP_DzExpeditionLockoutTimers = 147,
    /**
     * @generated from protobuf enum value: OP_DzListTimers = 148;
     */
    OP_DzListTimers = 148,
    /**
     * @generated from protobuf enum value: OP_DzMakeLeader = 149;
     */
    OP_DzMakeLeader = 149,
    /**
     * @generated from protobuf enum value: OP_DzMemberList = 150;
     */
    OP_DzMemberList = 150,
    /**
     * @generated from protobuf enum value: OP_DzMemberListName = 151;
     */
    OP_DzMemberListName = 151,
    /**
     * @generated from protobuf enum value: OP_DzMemberListStatus = 152;
     */
    OP_DzMemberListStatus = 152,
    /**
     * @generated from protobuf enum value: OP_DzPlayerList = 153;
     */
    OP_DzPlayerList = 153,
    /**
     * @generated from protobuf enum value: OP_DzQuit = 154;
     */
    OP_DzQuit = 154,
    /**
     * @generated from protobuf enum value: OP_DzRemovePlayer = 155;
     */
    OP_DzRemovePlayer = 155,
    /**
     * @generated from protobuf enum value: OP_DzSetLeaderName = 156;
     */
    OP_DzSetLeaderName = 156,
    /**
     * @generated from protobuf enum value: OP_DzSwapPlayer = 157;
     */
    OP_DzSwapPlayer = 157,
    /**
     * @generated from protobuf enum value: OP_EnterChat = 161;
     */
    OP_EnterChat = 161,
    /**
     * @generated from protobuf enum value: OP_Feedback = 168;
     */
    OP_Feedback = 168,
    /**
     * @generated from protobuf enum value: OP_FellowshipUpdate = 170;
     */
    OP_FellowshipUpdate = 170,
    /**
     * @generated from protobuf enum value: OP_FindPersonReply = 171;
     */
    OP_FindPersonReply = 171,
    /**
     * @generated from protobuf enum value: OP_Fling = 177;
     */
    OP_Fling = 177,
    /**
     * @generated from protobuf enum value: OP_FloatListThing = 178;
     */
    OP_FloatListThing = 178,
    /**
     * @generated from protobuf enum value: OP_ForceFindPerson = 180;
     */
    OP_ForceFindPerson = 180,
    /**
     * @generated from protobuf enum value: OP_FriendsWho = 182;
     */
    OP_FriendsWho = 182,
    /**
     * @generated from protobuf enum value: OP_GetGuildMOTD = 183;
     */
    OP_GetGuildMOTD = 183,
    /**
     * @generated from protobuf enum value: OP_GetGuildMOTDReply = 184;
     */
    OP_GetGuildMOTDReply = 184,
    /**
     * @generated from protobuf enum value: OP_GiveMoney = 186;
     */
    OP_GiveMoney = 186,
    /**
     * @generated from protobuf enum value: OP_GMApproval = 187;
     */
    OP_GMApproval = 187,
    /**
     * @generated from protobuf enum value: OP_GMTrainSkillConfirm = 206;
     */
    OP_GMTrainSkillConfirm = 206,
    /**
     * @generated from protobuf enum value: OP_GroupDisbandOther = 214;
     */
    OP_GroupDisbandOther = 214,
    /**
     * @generated from protobuf enum value: OP_GroupDisbandYou = 215;
     */
    OP_GroupDisbandYou = 215,
    /**
     * @generated from protobuf enum value: OP_GroupLeaderChange = 220;
     */
    OP_GroupLeaderChange = 220,
    /**
     * @generated from protobuf enum value: OP_GroupLeadershipAAUpdate = 221;
     */
    OP_GroupLeadershipAAUpdate = 221,
    /**
     * @generated from protobuf enum value: OP_GroupMakeLeader = 222;
     */
    OP_GroupMakeLeader = 222,
    /**
     * @generated from protobuf enum value: OP_GroupMentor = 223;
     */
    OP_GroupMentor = 223,
    /**
     * @generated from protobuf enum value: OP_GroupRoles = 224;
     */
    OP_GroupRoles = 224,
    /**
     * @generated from protobuf enum value: OP_GroupUpdateB = 226;
     */
    OP_GroupUpdateB = 226,
    /**
     * @generated from protobuf enum value: OP_GroupUpdateLeaderAA = 227;
     */
    OP_GroupUpdateLeaderAA = 227,
    /**
     * @generated from protobuf enum value: OP_GuildBank = 228;
     */
    OP_GuildBank = 228,
    /**
     * @generated from protobuf enum value: OP_GuildBankItemList = 229;
     */
    OP_GuildBankItemList = 229,
    /**
     * @generated from protobuf enum value: OP_GuildCreate = 230;
     */
    OP_GuildCreate = 230,
    /**
     * @generated from protobuf enum value: OP_GuildManageBanker = 238;
     */
    OP_GuildManageBanker = 238,
    /**
     * @generated from protobuf enum value: OP_GuildMemberLevelUpdate = 241;
     */
    OP_GuildMemberLevelUpdate = 241,
    /**
     * @generated from protobuf enum value: OP_GuildPromote = 254;
     */
    OP_GuildPromote = 254,
    /**
     * @generated from protobuf enum value: OP_GuildStatus = 266;
     */
    OP_GuildStatus = 266,
    /**
     * @generated from protobuf enum value: OP_GuildUpdateURLAndChannel = 268;
     */
    OP_GuildUpdateURLAndChannel = 268,
    /**
     * @generated from protobuf enum value: OP_HideCorpse = 274;
     */
    OP_HideCorpse = 274,
    /**
     * @generated from protobuf enum value: OP_InitialHPUpdate = 278;
     */
    OP_InitialHPUpdate = 278,
    /**
     * @generated from protobuf enum value: OP_InitialMobHealth = 279;
     */
    OP_InitialMobHealth = 279,
    /**
     * @generated from protobuf enum value: OP_InspectBuffs = 281;
     */
    OP_InspectBuffs = 281,
    /**
     * @generated from protobuf enum value: OP_InspectMessageUpdate = 282;
     */
    OP_InspectMessageUpdate = 282,
    /**
     * @generated from protobuf enum value: OP_ItemLinkText = 292;
     */
    OP_ItemLinkText = 292,
    /**
     * @generated from protobuf enum value: OP_ItemPreview = 295;
     */
    OP_ItemPreview = 295,
    /**
     * @generated from protobuf enum value: OP_ItemViewUnknown = 300;
     */
    OP_ItemViewUnknown = 300,
    /**
     * @generated from protobuf enum value: OP_KeyRing = 302;
     */
    OP_KeyRing = 302,
    /**
     * @generated from protobuf enum value: OP_KickPlayers = 303;
     */
    OP_KickPlayers = 303,
    /**
     * @generated from protobuf enum value: OP_KnowledgeBase = 304;
     */
    OP_KnowledgeBase = 304,
    /**
     * @generated from protobuf enum value: OP_LDoNDisarmTraps = 306;
     */
    OP_LDoNDisarmTraps = 306,
    /**
     * @generated from protobuf enum value: OP_LDoNInspect = 307;
     */
    OP_LDoNInspect = 307,
    /**
     * @generated from protobuf enum value: OP_LDoNOpen = 308;
     */
    OP_LDoNOpen = 308,
    /**
     * @generated from protobuf enum value: OP_LDoNPickLock = 309;
     */
    OP_LDoNPickLock = 309,
    /**
     * @generated from protobuf enum value: OP_LDoNSenseTraps = 310;
     */
    OP_LDoNSenseTraps = 310,
    /**
     * @generated from protobuf enum value: OP_LFGGetMatchesRequest = 319;
     */
    OP_LFGGetMatchesRequest = 319,
    /**
     * @generated from protobuf enum value: OP_LFGGetMatchesResponse = 320;
     */
    OP_LFGGetMatchesResponse = 320,
    /**
     * @generated from protobuf enum value: OP_LFGResponse = 321;
     */
    OP_LFGResponse = 321,
    /**
     * @generated from protobuf enum value: OP_LFPCommand = 323;
     */
    OP_LFPCommand = 323,
    /**
     * @generated from protobuf enum value: OP_LFPGetMatchesRequest = 324;
     */
    OP_LFPGetMatchesRequest = 324,
    /**
     * @generated from protobuf enum value: OP_LFPGetMatchesResponse = 325;
     */
    OP_LFPGetMatchesResponse = 325,
    /**
     * @generated from protobuf enum value: OP_LinkedReuse = 326;
     */
    OP_LinkedReuse = 326,
    /**
     * @generated from protobuf enum value: OP_LocInfo = 328;
     */
    OP_LocInfo = 328,
    /**
     * @generated from protobuf enum value: OP_LockoutTimerInfo = 329;
     */
    OP_LockoutTimerInfo = 329,
    /**
     * @generated from protobuf enum value: OP_Login = 330;
     */
    OP_Login = 330,
    /**
     * @generated from protobuf enum value: OP_LoginComplete = 332;
     */
    OP_LoginComplete = 332,
    /**
     * @generated from protobuf enum value: OP_LoginExpansionPacketData = 333;
     */
    OP_LoginExpansionPacketData = 333,
    /**
     * @generated from protobuf enum value: OP_LoginUnknown1 = 334;
     */
    OP_LoginUnknown1 = 334,
    /**
     * @generated from protobuf enum value: OP_LoginUnknown2 = 335;
     */
    OP_LoginUnknown2 = 335,
    /**
     * @generated from protobuf enum value: OP_LogoutReply = 337;
     */
    OP_LogoutReply = 337,
    /**
     * @generated from protobuf enum value: OP_MarkNPC = 344;
     */
    OP_MarkNPC = 344,
    /**
     * @generated from protobuf enum value: OP_MarkRaidNPC = 345;
     */
    OP_MarkRaidNPC = 345,
    /**
     * @generated from protobuf enum value: OP_Marquee = 346;
     */
    OP_Marquee = 346,
    /**
     * @generated from protobuf enum value: OP_MendHPUpdate = 349;
     */
    OP_MendHPUpdate = 349,
    /**
     * @generated from protobuf enum value: OP_MercenaryAssign = 350;
     */
    OP_MercenaryAssign = 350,
    /**
     * @generated from protobuf enum value: OP_MercenaryCommand = 351;
     */
    OP_MercenaryCommand = 351,
    /**
     * @generated from protobuf enum value: OP_MercenaryDataRequest = 352;
     */
    OP_MercenaryDataRequest = 352,
    /**
     * @generated from protobuf enum value: OP_MercenaryDataResponse = 353;
     */
    OP_MercenaryDataResponse = 353,
    /**
     * @generated from protobuf enum value: OP_MercenaryDataUpdate = 354;
     */
    OP_MercenaryDataUpdate = 354,
    /**
     * @generated from protobuf enum value: OP_MercenaryDataUpdateRequest = 355;
     */
    OP_MercenaryDataUpdateRequest = 355,
    /**
     * @generated from protobuf enum value: OP_MercenaryDismiss = 356;
     */
    OP_MercenaryDismiss = 356,
    /**
     * @generated from protobuf enum value: OP_MercenaryHire = 357;
     */
    OP_MercenaryHire = 357,
    /**
     * @generated from protobuf enum value: OP_MercenarySuspendRequest = 358;
     */
    OP_MercenarySuspendRequest = 358,
    /**
     * @generated from protobuf enum value: OP_MercenarySuspendResponse = 359;
     */
    OP_MercenarySuspendResponse = 359,
    /**
     * @generated from protobuf enum value: OP_MercenaryTimer = 360;
     */
    OP_MercenaryTimer = 360,
    /**
     * @generated from protobuf enum value: OP_MercenaryTimerRequest = 361;
     */
    OP_MercenaryTimerRequest = 361,
    /**
     * @generated from protobuf enum value: OP_MercenaryUnknown1 = 362;
     */
    OP_MercenaryUnknown1 = 362,
    /**
     * @generated from protobuf enum value: OP_MercenaryUnsuspendResponse = 363;
     */
    OP_MercenaryUnsuspendResponse = 363,
    /**
     * @generated from protobuf enum value: OP_MobUpdate = 368;
     */
    OP_MobUpdate = 368,
    /**
     * @generated from protobuf enum value: OP_MoveMultipleItems = 375;
     */
    OP_MoveMultipleItems = 375,
    /**
     * @generated from protobuf enum value: OP_MoveLogDisregard = 376;
     */
    OP_MoveLogDisregard = 376,
    /**
     * @generated from protobuf enum value: OP_MoveLogRequest = 377;
     */
    OP_MoveLogRequest = 377,
    /**
     * @generated from protobuf enum value: OP_MultiLineMsg = 378;
     */
    OP_MultiLineMsg = 378,
    /**
     * @generated from protobuf enum value: OP_NewTitlesAvailable = 380;
     */
    OP_NewTitlesAvailable = 380,
    /**
     * @generated from protobuf enum value: OP_OpenContainer = 383;
     */
    OP_OpenContainer = 383,
    /**
     * @generated from protobuf enum value: OP_OpenDiscordMerchant = 384;
     */
    OP_OpenDiscordMerchant = 384,
    /**
     * @generated from protobuf enum value: OP_OpenInventory = 386;
     */
    OP_OpenInventory = 386,
    /**
     * @generated from protobuf enum value: OP_PetBuffWindow = 389;
     */
    OP_PetBuffWindow = 389,
    /**
     * @generated from protobuf enum value: OP_PetCommandState = 391;
     */
    OP_PetCommandState = 391,
    /**
     * @generated from protobuf enum value: OP_PetHoTT = 392;
     */
    OP_PetHoTT = 392,
    /**
     * @generated from protobuf enum value: OP_PetitionCheckout2 = 397;
     */
    OP_PetitionCheckout2 = 397,
    /**
     * @generated from protobuf enum value: OP_PetitionSearch = 402;
     */
    OP_PetitionSearch = 402,
    /**
     * @generated from protobuf enum value: OP_PetitionSearchResults = 403;
     */
    OP_PetitionSearchResults = 403,
    /**
     * @generated from protobuf enum value: OP_PetitionSearchText = 404;
     */
    OP_PetitionSearchText = 404,
    /**
     * @generated from protobuf enum value: OP_PlayerStateAdd = 411;
     */
    OP_PlayerStateAdd = 411,
    /**
     * @generated from protobuf enum value: OP_PlayerStateRemove = 412;
     */
    OP_PlayerStateRemove = 412,
    /**
     * @generated from protobuf enum value: OP_Poll = 416;
     */
    OP_Poll = 416,
    /**
     * @generated from protobuf enum value: OP_PollResponse = 417;
     */
    OP_PollResponse = 417,
    /**
     * @generated from protobuf enum value: OP_PopupResponse = 418;
     */
    OP_PopupResponse = 418,
    /**
     * @generated from protobuf enum value: OP_PreLogoutReply = 421;
     */
    OP_PreLogoutReply = 421,
    /**
     * @generated from protobuf enum value: OP_PVPLeaderBoardDetailsReply = 423;
     */
    OP_PVPLeaderBoardDetailsReply = 423,
    /**
     * @generated from protobuf enum value: OP_PVPLeaderBoardDetailsRequest = 424;
     */
    OP_PVPLeaderBoardDetailsRequest = 424,
    /**
     * @generated from protobuf enum value: OP_PVPLeaderBoardReply = 425;
     */
    OP_PVPLeaderBoardReply = 425,
    /**
     * @generated from protobuf enum value: OP_PVPLeaderBoardRequest = 426;
     */
    OP_PVPLeaderBoardRequest = 426,
    /**
     * @generated from protobuf enum value: OP_QueryResponseThing = 428;
     */
    OP_QueryResponseThing = 428,
    /**
     * @generated from protobuf enum value: OP_QueryUCSServerStatus = 429;
     */
    OP_QueryUCSServerStatus = 429,
    /**
     * @generated from protobuf enum value: OP_RaidDelegateAbility = 430;
     */
    OP_RaidDelegateAbility = 430,
    /**
     * @generated from protobuf enum value: OP_RaidClearNPCMarks = 431;
     */
    OP_RaidClearNPCMarks = 431,
    /**
     * @generated from protobuf enum value: OP_RaidInvite = 432;
     */
    OP_RaidInvite = 432,
    /**
     * @generated from protobuf enum value: OP_RaidJoin = 433;
     */
    OP_RaidJoin = 433,
    /**
     * @generated from protobuf enum value: OP_RandomNameGenerator = 435;
     */
    OP_RandomNameGenerator = 435,
    /**
     * @generated from protobuf enum value: OP_ReclaimCrystals = 444;
     */
    OP_ReclaimCrystals = 444,
    /**
     * @generated from protobuf enum value: OP_RemoveAllDoors = 446;
     */
    OP_RemoveAllDoors = 446,
    /**
     * @generated from protobuf enum value: OP_RemoveBlockedBuffs = 447;
     */
    OP_RemoveBlockedBuffs = 447,
    /**
     * @generated from protobuf enum value: OP_RemoveNimbusEffect = 448;
     */
    OP_RemoveNimbusEffect = 448,
    /**
     * @generated from protobuf enum value: OP_RemoveTrap = 449;
     */
    OP_RemoveTrap = 449,
    /**
     * @generated from protobuf enum value: OP_RequestKnowledgeBase = 456;
     */
    OP_RequestKnowledgeBase = 456,
    /**
     * @generated from protobuf enum value: OP_RespawnWindow = 458;
     */
    OP_RespawnWindow = 458,
    /**
     * @generated from protobuf enum value: OP_RestState = 460;
     */
    OP_RestState = 460,
    /**
     * @generated from protobuf enum value: OP_Rewind = 461;
     */
    OP_Rewind = 461,
    /**
     * @generated from protobuf enum value: OP_RezzComplete = 463;
     */
    OP_RezzComplete = 463,
    /**
     * @generated from protobuf enum value: OP_Sacrifice = 465;
     */
    OP_Sacrifice = 465,
    /**
     * @generated from protobuf enum value: OP_SendFindableNPCs = 475;
     */
    OP_SendFindableNPCs = 475,
    /**
     * @generated from protobuf enum value: OP_SendSystemStats = 481;
     */
    OP_SendSystemStats = 481,
    /**
     * @generated from protobuf enum value: OP_SessionReady = 489;
     */
    OP_SessionReady = 489,
    /**
     * @generated from protobuf enum value: OP_SetChatServer = 490;
     */
    OP_SetChatServer = 490,
    /**
     * @generated from protobuf enum value: OP_SetChatServer2 = 491;
     */
    OP_SetChatServer2 = 491,
    /**
     * @generated from protobuf enum value: OP_SetFace = 492;
     */
    OP_SetFace = 492,
    /**
     * @generated from protobuf enum value: OP_SetGroupTarget = 493;
     */
    OP_SetGroupTarget = 493,
    /**
     * @generated from protobuf enum value: OP_SetGuildRank = 495;
     */
    OP_SetGuildRank = 495,
    /**
     * @generated from protobuf enum value: OP_SetStartCity = 498;
     */
    OP_SetStartCity = 498,
    /**
     * @generated from protobuf enum value: OP_SharedTaskMemberList = 501;
     */
    OP_SharedTaskMemberList = 501,
    /**
     * @generated from protobuf enum value: OP_SharedTaskAddPlayer = 502;
     */
    OP_SharedTaskAddPlayer = 502,
    /**
     * @generated from protobuf enum value: OP_SharedTaskRemovePlayer = 503;
     */
    OP_SharedTaskRemovePlayer = 503,
    /**
     * @generated from protobuf enum value: OP_SharedTaskMakeLeader = 504;
     */
    OP_SharedTaskMakeLeader = 504,
    /**
     * @generated from protobuf enum value: OP_SharedTaskMemberInvite = 505;
     */
    OP_SharedTaskMemberInvite = 505,
    /**
     * @generated from protobuf enum value: OP_SharedTaskInvite = 506;
     */
    OP_SharedTaskInvite = 506,
    /**
     * @generated from protobuf enum value: OP_SharedTaskInviteResponse = 507;
     */
    OP_SharedTaskInviteResponse = 507,
    /**
     * @generated from protobuf enum value: OP_SharedTaskAcceptNew = 508;
     */
    OP_SharedTaskAcceptNew = 508,
    /**
     * @generated from protobuf enum value: OP_SharedTaskMemberChange = 509;
     */
    OP_SharedTaskMemberChange = 509,
    /**
     * @generated from protobuf enum value: OP_SharedTaskPlayerList = 510;
     */
    OP_SharedTaskPlayerList = 510,
    /**
     * @generated from protobuf enum value: OP_SharedTaskSelectWindow = 511;
     */
    OP_SharedTaskSelectWindow = 511,
    /**
     * @generated from protobuf enum value: OP_SharedTaskQuit = 512;
     */
    OP_SharedTaskQuit = 512,
    /**
     * @generated from protobuf enum value: OP_TaskTimers = 513;
     */
    OP_TaskTimers = 513,
    /**
     * @generated from protobuf enum value: OP_ShopEndConfirm = 517;
     */
    OP_ShopEndConfirm = 517,
    /**
     * @generated from protobuf enum value: OP_ShopItem = 518;
     */
    OP_ShopItem = 518,
    /**
     * @generated from protobuf enum value: OP_Some3ByteHPUpdate = 530;
     */
    OP_Some3ByteHPUpdate = 530,
    /**
     * @generated from protobuf enum value: OP_Some6ByteHPUpdate = 531;
     */
    OP_Some6ByteHPUpdate = 531,
    /**
     * @generated from protobuf enum value: OP_Sound = 533;
     */
    OP_Sound = 533,
    /**
     * @generated from protobuf enum value: OP_SpawnPositionUpdate = 536;
     */
    OP_SpawnPositionUpdate = 536,
    /**
     * @generated from protobuf enum value: OP_TargetBuffs = 545;
     */
    OP_TargetBuffs = 545,
    /**
     * @generated from protobuf enum value: OP_TargetHoTT = 547;
     */
    OP_TargetHoTT = 547,
    /**
     * @generated from protobuf enum value: OP_TaskActivityComplete = 551;
     */
    OP_TaskActivityComplete = 551,
    /**
     * @generated from protobuf enum value: OP_TaskHistoryReply = 553;
     */
    OP_TaskHistoryReply = 553,
    /**
     * @generated from protobuf enum value: OP_TaskHistoryRequest = 554;
     */
    OP_TaskHistoryRequest = 554,
    /**
     * @generated from protobuf enum value: OP_TaskRequestTimer = 555;
     */
    OP_TaskRequestTimer = 555,
    /**
     * @generated from protobuf enum value: OP_TaskSelectWindow = 556;
     */
    OP_TaskSelectWindow = 556,
    /**
     * @generated from protobuf enum value: OP_Translocate = 578;
     */
    OP_Translocate = 578,
    /**
     * @generated from protobuf enum value: OP_TributePointUpdate = 583;
     */
    OP_TributePointUpdate = 583,
    /**
     * @generated from protobuf enum value: OP_Untargetable = 587;
     */
    OP_Untargetable = 587,
    /**
     * @generated from protobuf enum value: OP_UpdateAA = 588;
     */
    OP_UpdateAA = 588,
    /**
     * @generated from protobuf enum value: OP_UpdateAura = 589;
     */
    OP_UpdateAura = 589,
    /**
     * @generated from protobuf enum value: OP_VetClaimReply = 591;
     */
    OP_VetClaimReply = 591,
    /**
     * @generated from protobuf enum value: OP_VetClaimRequest = 592;
     */
    OP_VetClaimRequest = 592,
    /**
     * @generated from protobuf enum value: OP_VetRewardsAvaliable = 593;
     */
    OP_VetRewardsAvaliable = 593,
    /**
     * @generated from protobuf enum value: OP_VoiceMacroIn = 594;
     */
    OP_VoiceMacroIn = 594,
    /**
     * @generated from protobuf enum value: OP_VoiceMacroOut = 595;
     */
    OP_VoiceMacroOut = 595,
    /**
     * @generated from protobuf enum value: OP_WeaponEquip1 = 596;
     */
    OP_WeaponEquip1 = 596,
    /**
     * @generated from protobuf enum value: OP_Weblink = 599;
     */
    OP_Weblink = 599,
    /**
     * @generated from protobuf enum value: OP_WhoAllResponse = 601;
     */
    OP_WhoAllResponse = 601,
    /**
     * @generated from protobuf enum value: OP_World_Client_CRC1 = 602;
     */
    OP_World_Client_CRC1 = 602,
    /**
     * @generated from protobuf enum value: OP_World_Client_CRC2 = 603;
     */
    OP_World_Client_CRC2 = 603,
    /**
     * @generated from protobuf enum value: OP_World_Client_CRC3 = 604;
     */
    OP_World_Client_CRC3 = 604,
    /**
     * @generated from protobuf enum value: OP_WorldClientReady = 605;
     */
    OP_WorldClientReady = 605,
    /**
     * @generated from protobuf enum value: OP_WorldComplete = 606;
     */
    OP_WorldComplete = 606,
    /**
     * @generated from protobuf enum value: OP_WorldLogout = 607;
     */
    OP_WorldLogout = 607,
    /**
     * @generated from protobuf enum value: OP_WorldUnknown001 = 609;
     */
    OP_WorldUnknown001 = 609,
    /**
     * @generated from protobuf enum value: OP_XTargetAutoAddHaters = 610;
     */
    OP_XTargetAutoAddHaters = 610,
    /**
     * @generated from protobuf enum value: OP_XTargetOpen = 611;
     */
    OP_XTargetOpen = 611,
    /**
     * @generated from protobuf enum value: OP_XTargetOpenResponse = 612;
     */
    OP_XTargetOpenResponse = 612,
    /**
     * @generated from protobuf enum value: OP_XTargetRequest = 613;
     */
    OP_XTargetRequest = 613,
    /**
     * @generated from protobuf enum value: OP_XTargetResponse = 614;
     */
    OP_XTargetResponse = 614,
    /**
     * @generated from protobuf enum value: OP_ZoneComplete = 617;
     */
    OP_ZoneComplete = 617,
    /**
     * @generated from protobuf enum value: OP_ZoneGuildList = 619;
     */
    OP_ZoneGuildList = 619,
    /**
     * @generated from protobuf enum value: OP_ZonePlayerToBind = 621;
     */
    OP_ZonePlayerToBind = 621,
    /**
     * @generated from protobuf enum value: OP_ZoneServerReady = 623;
     */
    OP_ZoneServerReady = 623,
    /**
     * @generated from protobuf enum value: OP_ResetAA = 626;
     */
    OP_ResetAA = 626,
    /**
     * @generated from protobuf enum value: OP_UnderWorld = 627;
     */
    OP_UnderWorld = 627
}
// @generated message type with reflection information, may provide speed optimized methods
class JWTLogin$Type extends MessageType<JWTLogin> {
    constructor() {
        super("eq.JWTLogin", [
            { no: 1, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<JWTLogin>): JWTLogin {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<JWTLogin>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JWTLogin): JWTLogin {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string token */ 1:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JWTLogin, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string token = 1; */
        if (message.token !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.JWTLogin
 */
export const JWTLogin = new JWTLogin$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JWTResponse$Type extends MessageType<JWTResponse> {
    constructor() {
        super("eq.JWTResponse", [
            { no: 1, name: "status", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<JWTResponse>): JWTResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = 0;
        if (value !== undefined)
            reflectionMergePartial<JWTResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JWTResponse): JWTResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 status */ 1:
                    message.status = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JWTResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).int32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.JWTResponse
 */
export const JWTResponse = new JWTResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginReply$Type extends MessageType<LoginReply> {
    constructor() {
        super("eq.LoginReply", [
            { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "error_str_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "failed_attempts", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "lsid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "show_player_count", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<LoginReply>): LoginReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.key = "";
        message.errorStrId = 0;
        message.failedAttempts = 0;
        message.lsid = 0;
        message.success = false;
        message.showPlayerCount = false;
        if (value !== undefined)
            reflectionMergePartial<LoginReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoginReply): LoginReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string key */ 1:
                    message.key = reader.string();
                    break;
                case /* int32 error_str_id */ 2:
                    message.errorStrId = reader.int32();
                    break;
                case /* int32 failed_attempts */ 3:
                    message.failedAttempts = reader.int32();
                    break;
                case /* int32 lsid */ 4:
                    message.lsid = reader.int32();
                    break;
                case /* bool success */ 5:
                    message.success = reader.bool();
                    break;
                case /* bool show_player_count */ 6:
                    message.showPlayerCount = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoginReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string key = 1; */
        if (message.key !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        /* int32 error_str_id = 2; */
        if (message.errorStrId !== 0)
            writer.tag(2, WireType.Varint).int32(message.errorStrId);
        /* int32 failed_attempts = 3; */
        if (message.failedAttempts !== 0)
            writer.tag(3, WireType.Varint).int32(message.failedAttempts);
        /* int32 lsid = 4; */
        if (message.lsid !== 0)
            writer.tag(4, WireType.Varint).int32(message.lsid);
        /* bool success = 5; */
        if (message.success !== false)
            writer.tag(5, WireType.Varint).bool(message.success);
        /* bool show_player_count = 6; */
        if (message.showPlayerCount !== false)
            writer.tag(6, WireType.Varint).bool(message.showPlayerCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.LoginReply
 */
export const LoginReply = new LoginReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginRequest$Type extends MessageType<LoginRequest> {
    constructor() {
        super("eq.LoginRequest", [
            { no: 1, name: "sequence", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<LoginRequest>): LoginRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sequence = 0;
        if (value !== undefined)
            reflectionMergePartial<LoginRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoginRequest): LoginRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 sequence */ 1:
                    message.sequence = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoginRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 sequence = 1; */
        if (message.sequence !== 0)
            writer.tag(1, WireType.Varint).int32(message.sequence);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.LoginRequest
 */
export const LoginRequest = new LoginRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorldServer$Type extends MessageType<WorldServer> {
    constructor() {
        super("eq.WorldServer", [
            { no: 1, name: "ip", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "server_type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "server_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "long_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "country_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "language_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "status", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "players_online", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<WorldServer>): WorldServer {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ip = "";
        message.serverType = 0;
        message.serverId = 0;
        message.longName = "";
        message.countryCode = "";
        message.languageCode = "";
        message.status = 0;
        message.playersOnline = 0;
        if (value !== undefined)
            reflectionMergePartial<WorldServer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorldServer): WorldServer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ip */ 1:
                    message.ip = reader.string();
                    break;
                case /* int32 server_type */ 2:
                    message.serverType = reader.int32();
                    break;
                case /* int32 server_id */ 3:
                    message.serverId = reader.int32();
                    break;
                case /* string long_name */ 4:
                    message.longName = reader.string();
                    break;
                case /* string country_code */ 5:
                    message.countryCode = reader.string();
                    break;
                case /* string language_code */ 6:
                    message.languageCode = reader.string();
                    break;
                case /* int32 status */ 7:
                    message.status = reader.int32();
                    break;
                case /* int32 players_online */ 8:
                    message.playersOnline = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorldServer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ip = 1; */
        if (message.ip !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.ip);
        /* int32 server_type = 2; */
        if (message.serverType !== 0)
            writer.tag(2, WireType.Varint).int32(message.serverType);
        /* int32 server_id = 3; */
        if (message.serverId !== 0)
            writer.tag(3, WireType.Varint).int32(message.serverId);
        /* string long_name = 4; */
        if (message.longName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.longName);
        /* string country_code = 5; */
        if (message.countryCode !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.countryCode);
        /* string language_code = 6; */
        if (message.languageCode !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.languageCode);
        /* int32 status = 7; */
        if (message.status !== 0)
            writer.tag(7, WireType.Varint).int32(message.status);
        /* int32 players_online = 8; */
        if (message.playersOnline !== 0)
            writer.tag(8, WireType.Varint).int32(message.playersOnline);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.WorldServer
 */
export const WorldServer = new WorldServer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginServerResponse$Type extends MessageType<LoginServerResponse> {
    constructor() {
        super("eq.LoginServerResponse", [
            { no: 1, name: "server_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "servers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => WorldServer }
        ]);
    }
    create(value?: PartialMessage<LoginServerResponse>): LoginServerResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serverCount = 0;
        message.servers = [];
        if (value !== undefined)
            reflectionMergePartial<LoginServerResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoginServerResponse): LoginServerResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 server_count */ 1:
                    message.serverCount = reader.int32();
                    break;
                case /* repeated eq.WorldServer servers */ 2:
                    message.servers.push(WorldServer.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoginServerResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 server_count = 1; */
        if (message.serverCount !== 0)
            writer.tag(1, WireType.Varint).int32(message.serverCount);
        /* repeated eq.WorldServer servers = 2; */
        for (let i = 0; i < message.servers.length; i++)
            WorldServer.internalBinaryWrite(message.servers[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.LoginServerResponse
 */
export const LoginServerResponse = new LoginServerResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayEverquest$Type extends MessageType<PlayEverquest> {
    constructor() {
        super("eq.PlayEverquest", [
            { no: 1, name: "server_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<PlayEverquest>): PlayEverquest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serverId = 0;
        if (value !== undefined)
            reflectionMergePartial<PlayEverquest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayEverquest): PlayEverquest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 server_id */ 1:
                    message.serverId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayEverquest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 server_id = 1; */
        if (message.serverId !== 0)
            writer.tag(1, WireType.Varint).int32(message.serverId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.PlayEverquest
 */
export const PlayEverquest = new PlayEverquest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayEverquestResponse$Type extends MessageType<PlayEverquestResponse> {
    constructor() {
        super("eq.PlayEverquestResponse", [
            { no: 1, name: "server_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "error_str_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<PlayEverquestResponse>): PlayEverquestResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serverId = 0;
        message.success = false;
        message.errorStrId = 0;
        if (value !== undefined)
            reflectionMergePartial<PlayEverquestResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayEverquestResponse): PlayEverquestResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 server_id */ 1:
                    message.serverId = reader.int32();
                    break;
                case /* bool success */ 2:
                    message.success = reader.bool();
                    break;
                case /* int32 error_str_id */ 3:
                    message.errorStrId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayEverquestResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 server_id = 1; */
        if (message.serverId !== 0)
            writer.tag(1, WireType.Varint).int32(message.serverId);
        /* bool success = 2; */
        if (message.success !== false)
            writer.tag(2, WireType.Varint).bool(message.success);
        /* int32 error_str_id = 3; */
        if (message.errorStrId !== 0)
            writer.tag(3, WireType.Varint).int32(message.errorStrId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.PlayEverquestResponse
 */
export const PlayEverquestResponse = new PlayEverquestResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WebInitiateConnection$Type extends MessageType<WebInitiateConnection> {
    constructor() {
        super("eq.WebInitiateConnection", [
            { no: 1, name: "login", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<WebInitiateConnection>): WebInitiateConnection {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.login = false;
        if (value !== undefined)
            reflectionMergePartial<WebInitiateConnection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WebInitiateConnection): WebInitiateConnection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool login */ 1:
                    message.login = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WebInitiateConnection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool login = 1; */
        if (message.login !== false)
            writer.tag(1, WireType.Varint).bool(message.login);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.WebInitiateConnection
 */
export const WebInitiateConnection = new WebInitiateConnection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginInfo$Type extends MessageType<LoginInfo> {
    constructor() {
        super("eq.LoginInfo", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "zoning", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<LoginInfo>): LoginInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.password = "";
        message.zoning = 0;
        if (value !== undefined)
            reflectionMergePartial<LoginInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoginInfo): LoginInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string password */ 2:
                    message.password = reader.string();
                    break;
                case /* int32 zoning */ 3:
                    message.zoning = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoginInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string password = 2; */
        if (message.password !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.password);
        /* int32 zoning = 3; */
        if (message.zoning !== 0)
            writer.tag(3, WireType.Varint).int32(message.zoning);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.LoginInfo
 */
export const LoginInfo = new LoginInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Tint$Type extends MessageType<Tint> {
    constructor() {
        super("eq.Tint", [
            { no: 1, name: "blue", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "green", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "red", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "use_tint", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Tint>): Tint {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.blue = 0;
        message.green = 0;
        message.red = 0;
        message.useTint = 0;
        if (value !== undefined)
            reflectionMergePartial<Tint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Tint): Tint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 blue */ 1:
                    message.blue = reader.int32();
                    break;
                case /* int32 green */ 2:
                    message.green = reader.int32();
                    break;
                case /* int32 red */ 3:
                    message.red = reader.int32();
                    break;
                case /* int32 use_tint */ 4:
                    message.useTint = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Tint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 blue = 1; */
        if (message.blue !== 0)
            writer.tag(1, WireType.Varint).int32(message.blue);
        /* int32 green = 2; */
        if (message.green !== 0)
            writer.tag(2, WireType.Varint).int32(message.green);
        /* int32 red = 3; */
        if (message.red !== 0)
            writer.tag(3, WireType.Varint).int32(message.red);
        /* int32 use_tint = 4; */
        if (message.useTint !== 0)
            writer.tag(4, WireType.Varint).int32(message.useTint);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Tint
 */
export const Tint = new Tint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CharSelectEquip$Type extends MessageType<CharSelectEquip> {
    constructor() {
        super("eq.CharSelectEquip", [
            { no: 1, name: "material", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "color", kind: "message", T: () => Tint }
        ]);
    }
    create(value?: PartialMessage<CharSelectEquip>): CharSelectEquip {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.material = 0;
        if (value !== undefined)
            reflectionMergePartial<CharSelectEquip>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CharSelectEquip): CharSelectEquip {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 material */ 1:
                    message.material = reader.int32();
                    break;
                case /* eq.Tint color */ 2:
                    message.color = Tint.internalBinaryRead(reader, reader.uint32(), options, message.color);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CharSelectEquip, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 material = 1; */
        if (message.material !== 0)
            writer.tag(1, WireType.Varint).int32(message.material);
        /* eq.Tint color = 2; */
        if (message.color)
            Tint.internalBinaryWrite(message.color, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.CharSelectEquip
 */
export const CharSelectEquip = new CharSelectEquip$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CharacterSelectEntry$Type extends MessageType<CharacterSelectEntry> {
    constructor() {
        super("eq.CharacterSelectEntry", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "char_class", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "race", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "level", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "zone", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "instance", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "gender", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "face", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "equip", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CharSelectEquip },
            { no: 10, name: "deity", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "primary_id_file", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "secondary_id_file", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "go_home", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "enabled", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "last_login", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CharacterSelectEntry>): CharacterSelectEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.charClass = 0;
        message.race = 0;
        message.level = 0;
        message.zone = 0;
        message.instance = 0;
        message.gender = 0;
        message.face = 0;
        message.equip = [];
        message.deity = 0;
        message.primaryIdFile = 0;
        message.secondaryIdFile = 0;
        message.goHome = 0;
        message.enabled = 0;
        message.lastLogin = 0;
        if (value !== undefined)
            reflectionMergePartial<CharacterSelectEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CharacterSelectEntry): CharacterSelectEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* int32 char_class */ 2:
                    message.charClass = reader.int32();
                    break;
                case /* int32 race */ 3:
                    message.race = reader.int32();
                    break;
                case /* int32 level */ 4:
                    message.level = reader.int32();
                    break;
                case /* int32 zone */ 5:
                    message.zone = reader.int32();
                    break;
                case /* int32 instance */ 6:
                    message.instance = reader.int32();
                    break;
                case /* int32 gender */ 7:
                    message.gender = reader.int32();
                    break;
                case /* int32 face */ 8:
                    message.face = reader.int32();
                    break;
                case /* repeated eq.CharSelectEquip equip */ 9:
                    message.equip.push(CharSelectEquip.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 deity */ 10:
                    message.deity = reader.int32();
                    break;
                case /* int32 primary_id_file */ 11:
                    message.primaryIdFile = reader.int32();
                    break;
                case /* int32 secondary_id_file */ 12:
                    message.secondaryIdFile = reader.int32();
                    break;
                case /* int32 go_home */ 13:
                    message.goHome = reader.int32();
                    break;
                case /* int32 enabled */ 14:
                    message.enabled = reader.int32();
                    break;
                case /* int32 last_login */ 15:
                    message.lastLogin = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CharacterSelectEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* int32 char_class = 2; */
        if (message.charClass !== 0)
            writer.tag(2, WireType.Varint).int32(message.charClass);
        /* int32 race = 3; */
        if (message.race !== 0)
            writer.tag(3, WireType.Varint).int32(message.race);
        /* int32 level = 4; */
        if (message.level !== 0)
            writer.tag(4, WireType.Varint).int32(message.level);
        /* int32 zone = 5; */
        if (message.zone !== 0)
            writer.tag(5, WireType.Varint).int32(message.zone);
        /* int32 instance = 6; */
        if (message.instance !== 0)
            writer.tag(6, WireType.Varint).int32(message.instance);
        /* int32 gender = 7; */
        if (message.gender !== 0)
            writer.tag(7, WireType.Varint).int32(message.gender);
        /* int32 face = 8; */
        if (message.face !== 0)
            writer.tag(8, WireType.Varint).int32(message.face);
        /* repeated eq.CharSelectEquip equip = 9; */
        for (let i = 0; i < message.equip.length; i++)
            CharSelectEquip.internalBinaryWrite(message.equip[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* int32 deity = 10; */
        if (message.deity !== 0)
            writer.tag(10, WireType.Varint).int32(message.deity);
        /* int32 primary_id_file = 11; */
        if (message.primaryIdFile !== 0)
            writer.tag(11, WireType.Varint).int32(message.primaryIdFile);
        /* int32 secondary_id_file = 12; */
        if (message.secondaryIdFile !== 0)
            writer.tag(12, WireType.Varint).int32(message.secondaryIdFile);
        /* int32 go_home = 13; */
        if (message.goHome !== 0)
            writer.tag(13, WireType.Varint).int32(message.goHome);
        /* int32 enabled = 14; */
        if (message.enabled !== 0)
            writer.tag(14, WireType.Varint).int32(message.enabled);
        /* int32 last_login = 15; */
        if (message.lastLogin !== 0)
            writer.tag(15, WireType.Varint).int32(message.lastLogin);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.CharacterSelectEntry
 */
export const CharacterSelectEntry = new CharacterSelectEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CharacterSelect$Type extends MessageType<CharacterSelect> {
    constructor() {
        super("eq.CharacterSelect", [
            { no: 1, name: "character_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "characters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CharacterSelectEntry }
        ]);
    }
    create(value?: PartialMessage<CharacterSelect>): CharacterSelect {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.characterCount = 0;
        message.characters = [];
        if (value !== undefined)
            reflectionMergePartial<CharacterSelect>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CharacterSelect): CharacterSelect {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 character_count */ 1:
                    message.characterCount = reader.int32();
                    break;
                case /* repeated eq.CharacterSelectEntry characters */ 2:
                    message.characters.push(CharacterSelectEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CharacterSelect, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 character_count = 1; */
        if (message.characterCount !== 0)
            writer.tag(1, WireType.Varint).int32(message.characterCount);
        /* repeated eq.CharacterSelectEntry characters = 2; */
        for (let i = 0; i < message.characters.length; i++)
            CharacterSelectEntry.internalBinaryWrite(message.characters[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.CharacterSelect
 */
export const CharacterSelect = new CharacterSelect$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EnterWorld$Type extends MessageType<EnterWorld> {
    constructor() {
        super("eq.EnterWorld", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "tutorial", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "return_home", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<EnterWorld>): EnterWorld {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.tutorial = 0;
        message.returnHome = 0;
        if (value !== undefined)
            reflectionMergePartial<EnterWorld>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EnterWorld): EnterWorld {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* int32 tutorial */ 2:
                    message.tutorial = reader.int32();
                    break;
                case /* int32 return_home */ 3:
                    message.returnHome = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EnterWorld, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* int32 tutorial = 2; */
        if (message.tutorial !== 0)
            writer.tag(2, WireType.Varint).int32(message.tutorial);
        /* int32 return_home = 3; */
        if (message.returnHome !== 0)
            writer.tag(3, WireType.Varint).int32(message.returnHome);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.EnterWorld
 */
export const EnterWorld = new EnterWorld$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InventorySlot$Type extends MessageType<InventorySlot> {
    constructor() {
        super("eq.InventorySlot", [
            { no: 1, name: "type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "slot", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "sub_index", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<InventorySlot>): InventorySlot {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.slot = 0;
        message.subIndex = 0;
        if (value !== undefined)
            reflectionMergePartial<InventorySlot>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InventorySlot): InventorySlot {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 type */ 1:
                    message.type = reader.int32();
                    break;
                case /* int32 slot */ 2:
                    message.slot = reader.int32();
                    break;
                case /* int32 sub_index */ 3:
                    message.subIndex = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InventorySlot, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* int32 slot = 2; */
        if (message.slot !== 0)
            writer.tag(2, WireType.Varint).int32(message.slot);
        /* int32 sub_index = 3; */
        if (message.subIndex !== 0)
            writer.tag(3, WireType.Varint).int32(message.subIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.InventorySlot
 */
export const InventorySlot = new InventorySlot$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypelessInventorySlot$Type extends MessageType<TypelessInventorySlot> {
    constructor() {
        super("eq.TypelessInventorySlot", [
            { no: 1, name: "slot", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "sub_index", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TypelessInventorySlot>): TypelessInventorySlot {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.slot = 0;
        message.subIndex = 0;
        if (value !== undefined)
            reflectionMergePartial<TypelessInventorySlot>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TypelessInventorySlot): TypelessInventorySlot {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 slot */ 1:
                    message.slot = reader.int32();
                    break;
                case /* int32 sub_index */ 2:
                    message.subIndex = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TypelessInventorySlot, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 slot = 1; */
        if (message.slot !== 0)
            writer.tag(1, WireType.Varint).int32(message.slot);
        /* int32 sub_index = 2; */
        if (message.subIndex !== 0)
            writer.tag(2, WireType.Varint).int32(message.subIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.TypelessInventorySlot
 */
export const TypelessInventorySlot = new TypelessInventorySlot$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NameApproval$Type extends MessageType<NameApproval> {
    constructor() {
        super("eq.NameApproval", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "race", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "char_class", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "deity", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<NameApproval>): NameApproval {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.race = 0;
        message.charClass = 0;
        message.deity = 0;
        if (value !== undefined)
            reflectionMergePartial<NameApproval>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NameApproval): NameApproval {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* int32 race */ 2:
                    message.race = reader.int32();
                    break;
                case /* int32 char_class */ 3:
                    message.charClass = reader.int32();
                    break;
                case /* int32 deity */ 4:
                    message.deity = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NameApproval, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* int32 race = 2; */
        if (message.race !== 0)
            writer.tag(2, WireType.Varint).int32(message.race);
        /* int32 char_class = 3; */
        if (message.charClass !== 0)
            writer.tag(3, WireType.Varint).int32(message.charClass);
        /* int32 deity = 4; */
        if (message.deity !== 0)
            writer.tag(4, WireType.Varint).int32(message.deity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.NameApproval
 */
export const NameApproval = new NameApproval$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EntityId$Type extends MessageType<EntityId> {
    constructor() {
        super("eq.EntityId", [
            { no: 1, name: "entity_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<EntityId>): EntityId {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entityId = 0;
        if (value !== undefined)
            reflectionMergePartial<EntityId>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EntityId): EntityId {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 entity_id */ 1:
                    message.entityId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EntityId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 entity_id = 1; */
        if (message.entityId !== 0)
            writer.tag(1, WireType.Varint).int32(message.entityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.EntityId
 */
export const EntityId = new EntityId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Duel$Type extends MessageType<Duel> {
    constructor() {
        super("eq.Duel", [
            { no: 1, name: "duel_initiator", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "duel_target", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Duel>): Duel {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.duelInitiator = 0;
        message.duelTarget = 0;
        if (value !== undefined)
            reflectionMergePartial<Duel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Duel): Duel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 duel_initiator */ 1:
                    message.duelInitiator = reader.int32();
                    break;
                case /* int32 duel_target */ 2:
                    message.duelTarget = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Duel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 duel_initiator = 1; */
        if (message.duelInitiator !== 0)
            writer.tag(1, WireType.Varint).int32(message.duelInitiator);
        /* int32 duel_target = 2; */
        if (message.duelTarget !== 0)
            writer.tag(2, WireType.Varint).int32(message.duelTarget);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Duel
 */
export const Duel = new Duel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DuelResponse$Type extends MessageType<DuelResponse> {
    constructor() {
        super("eq.DuelResponse", [
            { no: 1, name: "target_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "entity_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<DuelResponse>): DuelResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.targetId = 0;
        message.entityId = 0;
        if (value !== undefined)
            reflectionMergePartial<DuelResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DuelResponse): DuelResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 target_id */ 1:
                    message.targetId = reader.int32();
                    break;
                case /* int32 entity_id */ 2:
                    message.entityId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DuelResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 target_id = 1; */
        if (message.targetId !== 0)
            writer.tag(1, WireType.Varint).int32(message.targetId);
        /* int32 entity_id = 2; */
        if (message.entityId !== 0)
            writer.tag(2, WireType.Varint).int32(message.entityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.DuelResponse
 */
export const DuelResponse = new DuelResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventureInfo$Type extends MessageType<AdventureInfo> {
    constructor() {
        super("eq.AdventureInfo", [
            { no: 1, name: "quest_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "npc_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "in_use", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "status", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "show_compass", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "objetive", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "objetive_value", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "minutes", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "points", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 13, name: "y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 14, name: "zoneid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "zonedungeonid", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AdventureInfo>): AdventureInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.questId = 0;
        message.npcId = 0;
        message.inUse = false;
        message.status = 0;
        message.showCompass = false;
        message.objetive = 0;
        message.objetiveValue = 0;
        message.text = "";
        message.type = 0;
        message.minutes = 0;
        message.points = 0;
        message.x = 0;
        message.y = 0;
        message.zoneid = 0;
        message.zonedungeonid = 0;
        if (value !== undefined)
            reflectionMergePartial<AdventureInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureInfo): AdventureInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 quest_id */ 1:
                    message.questId = reader.int32();
                    break;
                case /* int32 npc_id */ 2:
                    message.npcId = reader.int32();
                    break;
                case /* bool in_use */ 3:
                    message.inUse = reader.bool();
                    break;
                case /* int32 status */ 4:
                    message.status = reader.int32();
                    break;
                case /* bool show_compass */ 5:
                    message.showCompass = reader.bool();
                    break;
                case /* int32 objetive */ 6:
                    message.objetive = reader.int32();
                    break;
                case /* int32 objetive_value */ 7:
                    message.objetiveValue = reader.int32();
                    break;
                case /* string text */ 8:
                    message.text = reader.string();
                    break;
                case /* int32 type */ 9:
                    message.type = reader.int32();
                    break;
                case /* int32 minutes */ 10:
                    message.minutes = reader.int32();
                    break;
                case /* int32 points */ 11:
                    message.points = reader.int32();
                    break;
                case /* float x */ 12:
                    message.x = reader.float();
                    break;
                case /* float y */ 13:
                    message.y = reader.float();
                    break;
                case /* int32 zoneid */ 14:
                    message.zoneid = reader.int32();
                    break;
                case /* int32 zonedungeonid */ 15:
                    message.zonedungeonid = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdventureInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 quest_id = 1; */
        if (message.questId !== 0)
            writer.tag(1, WireType.Varint).int32(message.questId);
        /* int32 npc_id = 2; */
        if (message.npcId !== 0)
            writer.tag(2, WireType.Varint).int32(message.npcId);
        /* bool in_use = 3; */
        if (message.inUse !== false)
            writer.tag(3, WireType.Varint).bool(message.inUse);
        /* int32 status = 4; */
        if (message.status !== 0)
            writer.tag(4, WireType.Varint).int32(message.status);
        /* bool show_compass = 5; */
        if (message.showCompass !== false)
            writer.tag(5, WireType.Varint).bool(message.showCompass);
        /* int32 objetive = 6; */
        if (message.objetive !== 0)
            writer.tag(6, WireType.Varint).int32(message.objetive);
        /* int32 objetive_value = 7; */
        if (message.objetiveValue !== 0)
            writer.tag(7, WireType.Varint).int32(message.objetiveValue);
        /* string text = 8; */
        if (message.text !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.text);
        /* int32 type = 9; */
        if (message.type !== 0)
            writer.tag(9, WireType.Varint).int32(message.type);
        /* int32 minutes = 10; */
        if (message.minutes !== 0)
            writer.tag(10, WireType.Varint).int32(message.minutes);
        /* int32 points = 11; */
        if (message.points !== 0)
            writer.tag(11, WireType.Varint).int32(message.points);
        /* float x = 12; */
        if (message.x !== 0)
            writer.tag(12, WireType.Bit32).float(message.x);
        /* float y = 13; */
        if (message.y !== 0)
            writer.tag(13, WireType.Bit32).float(message.y);
        /* int32 zoneid = 14; */
        if (message.zoneid !== 0)
            writer.tag(14, WireType.Varint).int32(message.zoneid);
        /* int32 zonedungeonid = 15; */
        if (message.zonedungeonid !== 0)
            writer.tag(15, WireType.Varint).int32(message.zonedungeonid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.AdventureInfo
 */
export const AdventureInfo = new AdventureInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TextureProfile$Type extends MessageType<TextureProfile> {
    constructor() {
        super("eq.TextureProfile", [
            { no: 1, name: "head", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "chest", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "arms", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "wrist", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "hands", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "legs", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "feet", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "primary", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "secondary", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TextureProfile>): TextureProfile {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.head = 0;
        message.chest = 0;
        message.arms = 0;
        message.wrist = 0;
        message.hands = 0;
        message.legs = 0;
        message.feet = 0;
        message.primary = 0;
        message.secondary = 0;
        if (value !== undefined)
            reflectionMergePartial<TextureProfile>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TextureProfile): TextureProfile {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 head */ 1:
                    message.head = reader.int32();
                    break;
                case /* int32 chest */ 2:
                    message.chest = reader.int32();
                    break;
                case /* int32 arms */ 3:
                    message.arms = reader.int32();
                    break;
                case /* int32 wrist */ 4:
                    message.wrist = reader.int32();
                    break;
                case /* int32 hands */ 5:
                    message.hands = reader.int32();
                    break;
                case /* int32 legs */ 6:
                    message.legs = reader.int32();
                    break;
                case /* int32 feet */ 7:
                    message.feet = reader.int32();
                    break;
                case /* int32 primary */ 8:
                    message.primary = reader.int32();
                    break;
                case /* int32 secondary */ 9:
                    message.secondary = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TextureProfile, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 head = 1; */
        if (message.head !== 0)
            writer.tag(1, WireType.Varint).int32(message.head);
        /* int32 chest = 2; */
        if (message.chest !== 0)
            writer.tag(2, WireType.Varint).int32(message.chest);
        /* int32 arms = 3; */
        if (message.arms !== 0)
            writer.tag(3, WireType.Varint).int32(message.arms);
        /* int32 wrist = 4; */
        if (message.wrist !== 0)
            writer.tag(4, WireType.Varint).int32(message.wrist);
        /* int32 hands = 5; */
        if (message.hands !== 0)
            writer.tag(5, WireType.Varint).int32(message.hands);
        /* int32 legs = 6; */
        if (message.legs !== 0)
            writer.tag(6, WireType.Varint).int32(message.legs);
        /* int32 feet = 7; */
        if (message.feet !== 0)
            writer.tag(7, WireType.Varint).int32(message.feet);
        /* int32 primary = 8; */
        if (message.primary !== 0)
            writer.tag(8, WireType.Varint).int32(message.primary);
        /* int32 secondary = 9; */
        if (message.secondary !== 0)
            writer.tag(9, WireType.Varint).int32(message.secondary);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.TextureProfile
 */
export const TextureProfile = new TextureProfile$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TintProfile$Type extends MessageType<TintProfile> {
    constructor() {
        super("eq.TintProfile", [
            { no: 1, name: "head", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "chest", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "arms", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "wrist", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "hands", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "legs", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "feet", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "primary", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "secondary", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TintProfile>): TintProfile {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.head = 0;
        message.chest = 0;
        message.arms = 0;
        message.wrist = 0;
        message.hands = 0;
        message.legs = 0;
        message.feet = 0;
        message.primary = 0;
        message.secondary = 0;
        if (value !== undefined)
            reflectionMergePartial<TintProfile>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TintProfile): TintProfile {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 head */ 1:
                    message.head = reader.int32();
                    break;
                case /* int32 chest */ 2:
                    message.chest = reader.int32();
                    break;
                case /* int32 arms */ 3:
                    message.arms = reader.int32();
                    break;
                case /* int32 wrist */ 4:
                    message.wrist = reader.int32();
                    break;
                case /* int32 hands */ 5:
                    message.hands = reader.int32();
                    break;
                case /* int32 legs */ 6:
                    message.legs = reader.int32();
                    break;
                case /* int32 feet */ 7:
                    message.feet = reader.int32();
                    break;
                case /* int32 primary */ 8:
                    message.primary = reader.int32();
                    break;
                case /* int32 secondary */ 9:
                    message.secondary = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TintProfile, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 head = 1; */
        if (message.head !== 0)
            writer.tag(1, WireType.Varint).int32(message.head);
        /* int32 chest = 2; */
        if (message.chest !== 0)
            writer.tag(2, WireType.Varint).int32(message.chest);
        /* int32 arms = 3; */
        if (message.arms !== 0)
            writer.tag(3, WireType.Varint).int32(message.arms);
        /* int32 wrist = 4; */
        if (message.wrist !== 0)
            writer.tag(4, WireType.Varint).int32(message.wrist);
        /* int32 hands = 5; */
        if (message.hands !== 0)
            writer.tag(5, WireType.Varint).int32(message.hands);
        /* int32 legs = 6; */
        if (message.legs !== 0)
            writer.tag(6, WireType.Varint).int32(message.legs);
        /* int32 feet = 7; */
        if (message.feet !== 0)
            writer.tag(7, WireType.Varint).int32(message.feet);
        /* int32 primary = 8; */
        if (message.primary !== 0)
            writer.tag(8, WireType.Varint).int32(message.primary);
        /* int32 secondary = 9; */
        if (message.secondary !== 0)
            writer.tag(9, WireType.Varint).int32(message.secondary);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.TintProfile
 */
export const TintProfile = new TintProfile$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Spawns$Type extends MessageType<Spawns> {
    constructor() {
        super("eq.Spawns", [
            { no: 1, name: "spawn_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "spawns", kind: "message", T: () => Spawn }
        ]);
    }
    create(value?: PartialMessage<Spawns>): Spawns {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.spawnCount = 0;
        if (value !== undefined)
            reflectionMergePartial<Spawns>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Spawns): Spawns {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 spawn_count */ 1:
                    message.spawnCount = reader.int32();
                    break;
                case /* eq.Spawn spawns */ 2:
                    message.spawns = Spawn.internalBinaryRead(reader, reader.uint32(), options, message.spawns);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Spawns, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 spawn_count = 1; */
        if (message.spawnCount !== 0)
            writer.tag(1, WireType.Varint).int32(message.spawnCount);
        /* eq.Spawn spawns = 2; */
        if (message.spawns)
            Spawn.internalBinaryWrite(message.spawns, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Spawns
 */
export const Spawns = new Spawns$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Spawn$Type extends MessageType<Spawn> {
    constructor() {
        super("eq.Spawn", [
            { no: 1, name: "gm", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "aaitle", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "anon", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "face", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "deity", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "size", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "npc", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "invis", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "haircolor", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "cur_hp", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "max_hp", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "findable", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "delta_heading", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "x", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 16, name: "y", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 17, name: "animation", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 18, name: "z", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 19, name: "delta_y", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 20, name: "delta_x", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 21, name: "heading", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 22, name: "delta_z", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 23, name: "eyecolor1", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 24, name: "showhelm", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 25, name: "is_npc", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 26, name: "hairstyle", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 27, name: "beardcolor", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 28, name: "level", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 29, name: "player_state", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 30, name: "beard", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 31, name: "suffix", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 32, name: "pet_owner_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 33, name: "guildrank", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 34, name: "equipment", kind: "message", T: () => TextureProfile },
            { no: 35, name: "runspeed", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 36, name: "afk", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 37, name: "guild_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 38, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 39, name: "helm", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 40, name: "race", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 41, name: "last_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 42, name: "walkspeed", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 43, name: "is_pet", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 44, name: "light", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 45, name: "char_class", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 46, name: "eyecolor2", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 47, name: "flymode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 48, name: "gender", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 49, name: "bodytype", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 50, name: "equip_chest", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 51, name: "mount_color", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 52, name: "spawn_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 53, name: "bounding_radius", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 54, name: "equipment_tint", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 55, name: "lfg", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Spawn>): Spawn {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.gm = 0;
        message.aaitle = 0;
        message.anon = 0;
        message.face = 0;
        message.name = "";
        message.deity = 0;
        message.size = 0;
        message.npc = 0;
        message.invis = 0;
        message.haircolor = 0;
        message.curHp = 0;
        message.maxHp = 0;
        message.findable = 0;
        message.deltaHeading = 0;
        message.x = 0;
        message.y = 0;
        message.animation = 0;
        message.z = 0;
        message.deltaY = 0;
        message.deltaX = 0;
        message.heading = 0;
        message.deltaZ = 0;
        message.eyecolor1 = 0;
        message.showhelm = 0;
        message.isNpc = 0;
        message.hairstyle = 0;
        message.beardcolor = 0;
        message.level = 0;
        message.playerState = 0;
        message.beard = 0;
        message.suffix = "";
        message.petOwnerId = 0;
        message.guildrank = 0;
        message.runspeed = 0;
        message.afk = 0;
        message.guildId = 0;
        message.title = "";
        message.helm = 0;
        message.race = 0;
        message.lastName = "";
        message.walkspeed = 0;
        message.isPet = 0;
        message.light = 0;
        message.charClass = 0;
        message.eyecolor2 = 0;
        message.flymode = 0;
        message.gender = 0;
        message.bodytype = 0;
        message.equipChest = 0;
        message.mountColor = 0;
        message.spawnId = 0;
        message.boundingRadius = 0;
        message.equipmentTint = 0;
        message.lfg = 0;
        if (value !== undefined)
            reflectionMergePartial<Spawn>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Spawn): Spawn {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 gm */ 1:
                    message.gm = reader.int32();
                    break;
                case /* int32 aaitle */ 2:
                    message.aaitle = reader.int32();
                    break;
                case /* int32 anon */ 3:
                    message.anon = reader.int32();
                    break;
                case /* int32 face */ 4:
                    message.face = reader.int32();
                    break;
                case /* string name */ 5:
                    message.name = reader.string();
                    break;
                case /* int32 deity */ 6:
                    message.deity = reader.int32();
                    break;
                case /* float size */ 7:
                    message.size = reader.float();
                    break;
                case /* int32 npc */ 8:
                    message.npc = reader.int32();
                    break;
                case /* int32 invis */ 9:
                    message.invis = reader.int32();
                    break;
                case /* int32 haircolor */ 10:
                    message.haircolor = reader.int32();
                    break;
                case /* int32 cur_hp */ 11:
                    message.curHp = reader.int32();
                    break;
                case /* int32 max_hp */ 12:
                    message.maxHp = reader.int32();
                    break;
                case /* int32 findable */ 13:
                    message.findable = reader.int32();
                    break;
                case /* int32 delta_heading */ 14:
                    message.deltaHeading = reader.int32();
                    break;
                case /* int32 x */ 15:
                    message.x = reader.int32();
                    break;
                case /* int32 y */ 16:
                    message.y = reader.int32();
                    break;
                case /* int32 animation */ 17:
                    message.animation = reader.int32();
                    break;
                case /* int32 z */ 18:
                    message.z = reader.int32();
                    break;
                case /* int32 delta_y */ 19:
                    message.deltaY = reader.int32();
                    break;
                case /* int32 delta_x */ 20:
                    message.deltaX = reader.int32();
                    break;
                case /* int32 heading */ 21:
                    message.heading = reader.int32();
                    break;
                case /* int32 delta_z */ 22:
                    message.deltaZ = reader.int32();
                    break;
                case /* int32 eyecolor1 */ 23:
                    message.eyecolor1 = reader.int32();
                    break;
                case /* int32 showhelm */ 24:
                    message.showhelm = reader.int32();
                    break;
                case /* int32 is_npc */ 25:
                    message.isNpc = reader.int32();
                    break;
                case /* int32 hairstyle */ 26:
                    message.hairstyle = reader.int32();
                    break;
                case /* int32 beardcolor */ 27:
                    message.beardcolor = reader.int32();
                    break;
                case /* int32 level */ 28:
                    message.level = reader.int32();
                    break;
                case /* int32 player_state */ 29:
                    message.playerState = reader.int32();
                    break;
                case /* int32 beard */ 30:
                    message.beard = reader.int32();
                    break;
                case /* string suffix */ 31:
                    message.suffix = reader.string();
                    break;
                case /* int32 pet_owner_id */ 32:
                    message.petOwnerId = reader.int32();
                    break;
                case /* int32 guildrank */ 33:
                    message.guildrank = reader.int32();
                    break;
                case /* eq.TextureProfile equipment */ 34:
                    message.equipment = TextureProfile.internalBinaryRead(reader, reader.uint32(), options, message.equipment);
                    break;
                case /* float runspeed */ 35:
                    message.runspeed = reader.float();
                    break;
                case /* int32 afk */ 36:
                    message.afk = reader.int32();
                    break;
                case /* int32 guild_id */ 37:
                    message.guildId = reader.int32();
                    break;
                case /* string title */ 38:
                    message.title = reader.string();
                    break;
                case /* int32 helm */ 39:
                    message.helm = reader.int32();
                    break;
                case /* int32 race */ 40:
                    message.race = reader.int32();
                    break;
                case /* string last_name */ 41:
                    message.lastName = reader.string();
                    break;
                case /* float walkspeed */ 42:
                    message.walkspeed = reader.float();
                    break;
                case /* int32 is_pet */ 43:
                    message.isPet = reader.int32();
                    break;
                case /* int32 light */ 44:
                    message.light = reader.int32();
                    break;
                case /* int32 char_class */ 45:
                    message.charClass = reader.int32();
                    break;
                case /* int32 eyecolor2 */ 46:
                    message.eyecolor2 = reader.int32();
                    break;
                case /* int32 flymode */ 47:
                    message.flymode = reader.int32();
                    break;
                case /* int32 gender */ 48:
                    message.gender = reader.int32();
                    break;
                case /* int32 bodytype */ 49:
                    message.bodytype = reader.int32();
                    break;
                case /* int32 equip_chest */ 50:
                    message.equipChest = reader.int32();
                    break;
                case /* int32 mount_color */ 51:
                    message.mountColor = reader.int32();
                    break;
                case /* int32 spawn_id */ 52:
                    message.spawnId = reader.int32();
                    break;
                case /* float bounding_radius */ 53:
                    message.boundingRadius = reader.float();
                    break;
                case /* int32 equipment_tint */ 54:
                    message.equipmentTint = reader.int32();
                    break;
                case /* int32 lfg */ 55:
                    message.lfg = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Spawn, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 gm = 1; */
        if (message.gm !== 0)
            writer.tag(1, WireType.Varint).int32(message.gm);
        /* int32 aaitle = 2; */
        if (message.aaitle !== 0)
            writer.tag(2, WireType.Varint).int32(message.aaitle);
        /* int32 anon = 3; */
        if (message.anon !== 0)
            writer.tag(3, WireType.Varint).int32(message.anon);
        /* int32 face = 4; */
        if (message.face !== 0)
            writer.tag(4, WireType.Varint).int32(message.face);
        /* string name = 5; */
        if (message.name !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.name);
        /* int32 deity = 6; */
        if (message.deity !== 0)
            writer.tag(6, WireType.Varint).int32(message.deity);
        /* float size = 7; */
        if (message.size !== 0)
            writer.tag(7, WireType.Bit32).float(message.size);
        /* int32 npc = 8; */
        if (message.npc !== 0)
            writer.tag(8, WireType.Varint).int32(message.npc);
        /* int32 invis = 9; */
        if (message.invis !== 0)
            writer.tag(9, WireType.Varint).int32(message.invis);
        /* int32 haircolor = 10; */
        if (message.haircolor !== 0)
            writer.tag(10, WireType.Varint).int32(message.haircolor);
        /* int32 cur_hp = 11; */
        if (message.curHp !== 0)
            writer.tag(11, WireType.Varint).int32(message.curHp);
        /* int32 max_hp = 12; */
        if (message.maxHp !== 0)
            writer.tag(12, WireType.Varint).int32(message.maxHp);
        /* int32 findable = 13; */
        if (message.findable !== 0)
            writer.tag(13, WireType.Varint).int32(message.findable);
        /* int32 delta_heading = 14; */
        if (message.deltaHeading !== 0)
            writer.tag(14, WireType.Varint).int32(message.deltaHeading);
        /* int32 x = 15; */
        if (message.x !== 0)
            writer.tag(15, WireType.Varint).int32(message.x);
        /* int32 y = 16; */
        if (message.y !== 0)
            writer.tag(16, WireType.Varint).int32(message.y);
        /* int32 animation = 17; */
        if (message.animation !== 0)
            writer.tag(17, WireType.Varint).int32(message.animation);
        /* int32 z = 18; */
        if (message.z !== 0)
            writer.tag(18, WireType.Varint).int32(message.z);
        /* int32 delta_y = 19; */
        if (message.deltaY !== 0)
            writer.tag(19, WireType.Varint).int32(message.deltaY);
        /* int32 delta_x = 20; */
        if (message.deltaX !== 0)
            writer.tag(20, WireType.Varint).int32(message.deltaX);
        /* int32 heading = 21; */
        if (message.heading !== 0)
            writer.tag(21, WireType.Varint).int32(message.heading);
        /* int32 delta_z = 22; */
        if (message.deltaZ !== 0)
            writer.tag(22, WireType.Varint).int32(message.deltaZ);
        /* int32 eyecolor1 = 23; */
        if (message.eyecolor1 !== 0)
            writer.tag(23, WireType.Varint).int32(message.eyecolor1);
        /* int32 showhelm = 24; */
        if (message.showhelm !== 0)
            writer.tag(24, WireType.Varint).int32(message.showhelm);
        /* int32 is_npc = 25; */
        if (message.isNpc !== 0)
            writer.tag(25, WireType.Varint).int32(message.isNpc);
        /* int32 hairstyle = 26; */
        if (message.hairstyle !== 0)
            writer.tag(26, WireType.Varint).int32(message.hairstyle);
        /* int32 beardcolor = 27; */
        if (message.beardcolor !== 0)
            writer.tag(27, WireType.Varint).int32(message.beardcolor);
        /* int32 level = 28; */
        if (message.level !== 0)
            writer.tag(28, WireType.Varint).int32(message.level);
        /* int32 player_state = 29; */
        if (message.playerState !== 0)
            writer.tag(29, WireType.Varint).int32(message.playerState);
        /* int32 beard = 30; */
        if (message.beard !== 0)
            writer.tag(30, WireType.Varint).int32(message.beard);
        /* string suffix = 31; */
        if (message.suffix !== "")
            writer.tag(31, WireType.LengthDelimited).string(message.suffix);
        /* int32 pet_owner_id = 32; */
        if (message.petOwnerId !== 0)
            writer.tag(32, WireType.Varint).int32(message.petOwnerId);
        /* int32 guildrank = 33; */
        if (message.guildrank !== 0)
            writer.tag(33, WireType.Varint).int32(message.guildrank);
        /* eq.TextureProfile equipment = 34; */
        if (message.equipment)
            TextureProfile.internalBinaryWrite(message.equipment, writer.tag(34, WireType.LengthDelimited).fork(), options).join();
        /* float runspeed = 35; */
        if (message.runspeed !== 0)
            writer.tag(35, WireType.Bit32).float(message.runspeed);
        /* int32 afk = 36; */
        if (message.afk !== 0)
            writer.tag(36, WireType.Varint).int32(message.afk);
        /* int32 guild_id = 37; */
        if (message.guildId !== 0)
            writer.tag(37, WireType.Varint).int32(message.guildId);
        /* string title = 38; */
        if (message.title !== "")
            writer.tag(38, WireType.LengthDelimited).string(message.title);
        /* int32 helm = 39; */
        if (message.helm !== 0)
            writer.tag(39, WireType.Varint).int32(message.helm);
        /* int32 race = 40; */
        if (message.race !== 0)
            writer.tag(40, WireType.Varint).int32(message.race);
        /* string last_name = 41; */
        if (message.lastName !== "")
            writer.tag(41, WireType.LengthDelimited).string(message.lastName);
        /* float walkspeed = 42; */
        if (message.walkspeed !== 0)
            writer.tag(42, WireType.Bit32).float(message.walkspeed);
        /* int32 is_pet = 43; */
        if (message.isPet !== 0)
            writer.tag(43, WireType.Varint).int32(message.isPet);
        /* int32 light = 44; */
        if (message.light !== 0)
            writer.tag(44, WireType.Varint).int32(message.light);
        /* int32 char_class = 45; */
        if (message.charClass !== 0)
            writer.tag(45, WireType.Varint).int32(message.charClass);
        /* int32 eyecolor2 = 46; */
        if (message.eyecolor2 !== 0)
            writer.tag(46, WireType.Varint).int32(message.eyecolor2);
        /* int32 flymode = 47; */
        if (message.flymode !== 0)
            writer.tag(47, WireType.Varint).int32(message.flymode);
        /* int32 gender = 48; */
        if (message.gender !== 0)
            writer.tag(48, WireType.Varint).int32(message.gender);
        /* int32 bodytype = 49; */
        if (message.bodytype !== 0)
            writer.tag(49, WireType.Varint).int32(message.bodytype);
        /* int32 equip_chest = 50; */
        if (message.equipChest !== 0)
            writer.tag(50, WireType.Varint).int32(message.equipChest);
        /* int32 mount_color = 51; */
        if (message.mountColor !== 0)
            writer.tag(51, WireType.Varint).int32(message.mountColor);
        /* int32 spawn_id = 52; */
        if (message.spawnId !== 0)
            writer.tag(52, WireType.Varint).int32(message.spawnId);
        /* float bounding_radius = 53; */
        if (message.boundingRadius !== 0)
            writer.tag(53, WireType.Bit32).float(message.boundingRadius);
        /* int32 equipment_tint = 54; */
        if (message.equipmentTint !== 0)
            writer.tag(54, WireType.Varint).int32(message.equipmentTint);
        /* int32 lfg = 55; */
        if (message.lfg !== 0)
            writer.tag(55, WireType.Varint).int32(message.lfg);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Spawn
 */
export const Spawn = new Spawn$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NewSpawn$Type extends MessageType<NewSpawn> {
    constructor() {
        super("eq.NewSpawn", [
            { no: 1, name: "spawn", kind: "message", T: () => Spawn }
        ]);
    }
    create(value?: PartialMessage<NewSpawn>): NewSpawn {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<NewSpawn>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NewSpawn): NewSpawn {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* eq.Spawn spawn */ 1:
                    message.spawn = Spawn.internalBinaryRead(reader, reader.uint32(), options, message.spawn);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NewSpawn, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* eq.Spawn spawn = 1; */
        if (message.spawn)
            Spawn.internalBinaryWrite(message.spawn, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.NewSpawn
 */
export const NewSpawn = new NewSpawn$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClientZoneEntry$Type extends MessageType<ClientZoneEntry> {
    constructor() {
        super("eq.ClientZoneEntry", [
            { no: 1, name: "char_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ClientZoneEntry>): ClientZoneEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.charName = "";
        if (value !== undefined)
            reflectionMergePartial<ClientZoneEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClientZoneEntry): ClientZoneEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string char_name */ 1:
                    message.charName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClientZoneEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string char_name = 1; */
        if (message.charName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.charName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.ClientZoneEntry
 */
export const ClientZoneEntry = new ClientZoneEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServerZoneEntry$Type extends MessageType<ServerZoneEntry> {
    constructor() {
        super("eq.ServerZoneEntry", [
            { no: 1, name: "player", kind: "message", T: () => NewSpawn }
        ]);
    }
    create(value?: PartialMessage<ServerZoneEntry>): ServerZoneEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ServerZoneEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServerZoneEntry): ServerZoneEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* eq.NewSpawn player */ 1:
                    message.player = NewSpawn.internalBinaryRead(reader, reader.uint32(), options, message.player);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServerZoneEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* eq.NewSpawn player = 1; */
        if (message.player)
            NewSpawn.internalBinaryWrite(message.player, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.ServerZoneEntry
 */
export const ServerZoneEntry = new ServerZoneEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NewZone$Type extends MessageType<NewZone> {
    constructor() {
        super("eq.NewZone", [
            { no: 1, name: "char_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "zone_short_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "zone_long_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "ztype", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "fog_red", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "fog_green", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "fog_blue", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "fog_minclip", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "fog_maxclip", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 10, name: "gravity", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 11, name: "time_type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "rain_chance", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "rain_duration", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "snow_chance", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "snow_duration", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 16, name: "sky", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 17, name: "zone_exp_multiplier", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 18, name: "safe_y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 19, name: "safe_x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 20, name: "safe_z", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 21, name: "max_z", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 22, name: "underworld", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 23, name: "minclip", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 24, name: "maxclip", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 25, name: "zone_short_name2", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 26, name: "zone_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 27, name: "zone_instance", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<NewZone>): NewZone {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.charName = "";
        message.zoneShortName = "";
        message.zoneLongName = "";
        message.ztype = 0;
        message.fogRed = [];
        message.fogGreen = [];
        message.fogBlue = [];
        message.fogMinclip = [];
        message.fogMaxclip = [];
        message.gravity = 0;
        message.timeType = 0;
        message.rainChance = [];
        message.rainDuration = [];
        message.snowChance = [];
        message.snowDuration = [];
        message.sky = 0;
        message.zoneExpMultiplier = 0;
        message.safeY = 0;
        message.safeX = 0;
        message.safeZ = 0;
        message.maxZ = 0;
        message.underworld = 0;
        message.minclip = 0;
        message.maxclip = 0;
        message.zoneShortName2 = "";
        message.zoneId = 0;
        message.zoneInstance = 0;
        if (value !== undefined)
            reflectionMergePartial<NewZone>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NewZone): NewZone {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string char_name */ 1:
                    message.charName = reader.string();
                    break;
                case /* string zone_short_name */ 2:
                    message.zoneShortName = reader.string();
                    break;
                case /* string zone_long_name */ 3:
                    message.zoneLongName = reader.string();
                    break;
                case /* int32 ztype */ 4:
                    message.ztype = reader.int32();
                    break;
                case /* repeated int32 fog_red */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.fogRed.push(reader.int32());
                    else
                        message.fogRed.push(reader.int32());
                    break;
                case /* repeated int32 fog_green */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.fogGreen.push(reader.int32());
                    else
                        message.fogGreen.push(reader.int32());
                    break;
                case /* repeated int32 fog_blue */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.fogBlue.push(reader.int32());
                    else
                        message.fogBlue.push(reader.int32());
                    break;
                case /* repeated float fog_minclip */ 8:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.fogMinclip.push(reader.float());
                    else
                        message.fogMinclip.push(reader.float());
                    break;
                case /* repeated float fog_maxclip */ 9:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.fogMaxclip.push(reader.float());
                    else
                        message.fogMaxclip.push(reader.float());
                    break;
                case /* float gravity */ 10:
                    message.gravity = reader.float();
                    break;
                case /* int32 time_type */ 11:
                    message.timeType = reader.int32();
                    break;
                case /* repeated int32 rain_chance */ 12:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.rainChance.push(reader.int32());
                    else
                        message.rainChance.push(reader.int32());
                    break;
                case /* repeated int32 rain_duration */ 13:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.rainDuration.push(reader.int32());
                    else
                        message.rainDuration.push(reader.int32());
                    break;
                case /* repeated int32 snow_chance */ 14:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.snowChance.push(reader.int32());
                    else
                        message.snowChance.push(reader.int32());
                    break;
                case /* repeated int32 snow_duration */ 15:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.snowDuration.push(reader.int32());
                    else
                        message.snowDuration.push(reader.int32());
                    break;
                case /* int32 sky */ 16:
                    message.sky = reader.int32();
                    break;
                case /* float zone_exp_multiplier */ 17:
                    message.zoneExpMultiplier = reader.float();
                    break;
                case /* float safe_y */ 18:
                    message.safeY = reader.float();
                    break;
                case /* float safe_x */ 19:
                    message.safeX = reader.float();
                    break;
                case /* float safe_z */ 20:
                    message.safeZ = reader.float();
                    break;
                case /* float max_z */ 21:
                    message.maxZ = reader.float();
                    break;
                case /* float underworld */ 22:
                    message.underworld = reader.float();
                    break;
                case /* float minclip */ 23:
                    message.minclip = reader.float();
                    break;
                case /* float maxclip */ 24:
                    message.maxclip = reader.float();
                    break;
                case /* string zone_short_name2 */ 25:
                    message.zoneShortName2 = reader.string();
                    break;
                case /* int32 zone_id */ 26:
                    message.zoneId = reader.int32();
                    break;
                case /* int32 zone_instance */ 27:
                    message.zoneInstance = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NewZone, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string char_name = 1; */
        if (message.charName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.charName);
        /* string zone_short_name = 2; */
        if (message.zoneShortName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.zoneShortName);
        /* string zone_long_name = 3; */
        if (message.zoneLongName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.zoneLongName);
        /* int32 ztype = 4; */
        if (message.ztype !== 0)
            writer.tag(4, WireType.Varint).int32(message.ztype);
        /* repeated int32 fog_red = 5; */
        if (message.fogRed.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.fogRed.length; i++)
                writer.int32(message.fogRed[i]);
            writer.join();
        }
        /* repeated int32 fog_green = 6; */
        if (message.fogGreen.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.fogGreen.length; i++)
                writer.int32(message.fogGreen[i]);
            writer.join();
        }
        /* repeated int32 fog_blue = 7; */
        if (message.fogBlue.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.fogBlue.length; i++)
                writer.int32(message.fogBlue[i]);
            writer.join();
        }
        /* repeated float fog_minclip = 8; */
        if (message.fogMinclip.length) {
            writer.tag(8, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.fogMinclip.length; i++)
                writer.float(message.fogMinclip[i]);
            writer.join();
        }
        /* repeated float fog_maxclip = 9; */
        if (message.fogMaxclip.length) {
            writer.tag(9, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.fogMaxclip.length; i++)
                writer.float(message.fogMaxclip[i]);
            writer.join();
        }
        /* float gravity = 10; */
        if (message.gravity !== 0)
            writer.tag(10, WireType.Bit32).float(message.gravity);
        /* int32 time_type = 11; */
        if (message.timeType !== 0)
            writer.tag(11, WireType.Varint).int32(message.timeType);
        /* repeated int32 rain_chance = 12; */
        if (message.rainChance.length) {
            writer.tag(12, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.rainChance.length; i++)
                writer.int32(message.rainChance[i]);
            writer.join();
        }
        /* repeated int32 rain_duration = 13; */
        if (message.rainDuration.length) {
            writer.tag(13, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.rainDuration.length; i++)
                writer.int32(message.rainDuration[i]);
            writer.join();
        }
        /* repeated int32 snow_chance = 14; */
        if (message.snowChance.length) {
            writer.tag(14, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.snowChance.length; i++)
                writer.int32(message.snowChance[i]);
            writer.join();
        }
        /* repeated int32 snow_duration = 15; */
        if (message.snowDuration.length) {
            writer.tag(15, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.snowDuration.length; i++)
                writer.int32(message.snowDuration[i]);
            writer.join();
        }
        /* int32 sky = 16; */
        if (message.sky !== 0)
            writer.tag(16, WireType.Varint).int32(message.sky);
        /* float zone_exp_multiplier = 17; */
        if (message.zoneExpMultiplier !== 0)
            writer.tag(17, WireType.Bit32).float(message.zoneExpMultiplier);
        /* float safe_y = 18; */
        if (message.safeY !== 0)
            writer.tag(18, WireType.Bit32).float(message.safeY);
        /* float safe_x = 19; */
        if (message.safeX !== 0)
            writer.tag(19, WireType.Bit32).float(message.safeX);
        /* float safe_z = 20; */
        if (message.safeZ !== 0)
            writer.tag(20, WireType.Bit32).float(message.safeZ);
        /* float max_z = 21; */
        if (message.maxZ !== 0)
            writer.tag(21, WireType.Bit32).float(message.maxZ);
        /* float underworld = 22; */
        if (message.underworld !== 0)
            writer.tag(22, WireType.Bit32).float(message.underworld);
        /* float minclip = 23; */
        if (message.minclip !== 0)
            writer.tag(23, WireType.Bit32).float(message.minclip);
        /* float maxclip = 24; */
        if (message.maxclip !== 0)
            writer.tag(24, WireType.Bit32).float(message.maxclip);
        /* string zone_short_name2 = 25; */
        if (message.zoneShortName2 !== "")
            writer.tag(25, WireType.LengthDelimited).string(message.zoneShortName2);
        /* int32 zone_id = 26; */
        if (message.zoneId !== 0)
            writer.tag(26, WireType.Varint).int32(message.zoneId);
        /* int32 zone_instance = 27; */
        if (message.zoneInstance !== 0)
            writer.tag(27, WireType.Varint).int32(message.zoneInstance);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.NewZone
 */
export const NewZone = new NewZone$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MemorizeSpell$Type extends MessageType<MemorizeSpell> {
    constructor() {
        super("eq.MemorizeSpell", [
            { no: 1, name: "slot", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "spell_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "scribing", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "reduction", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<MemorizeSpell>): MemorizeSpell {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.slot = 0;
        message.spellId = 0;
        message.scribing = 0;
        message.reduction = 0;
        if (value !== undefined)
            reflectionMergePartial<MemorizeSpell>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MemorizeSpell): MemorizeSpell {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 slot */ 1:
                    message.slot = reader.int32();
                    break;
                case /* int32 spell_id */ 2:
                    message.spellId = reader.int32();
                    break;
                case /* int32 scribing */ 3:
                    message.scribing = reader.int32();
                    break;
                case /* int32 reduction */ 4:
                    message.reduction = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MemorizeSpell, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 slot = 1; */
        if (message.slot !== 0)
            writer.tag(1, WireType.Varint).int32(message.slot);
        /* int32 spell_id = 2; */
        if (message.spellId !== 0)
            writer.tag(2, WireType.Varint).int32(message.spellId);
        /* int32 scribing = 3; */
        if (message.scribing !== 0)
            writer.tag(3, WireType.Varint).int32(message.scribing);
        /* int32 reduction = 4; */
        if (message.reduction !== 0)
            writer.tag(4, WireType.Varint).int32(message.reduction);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.MemorizeSpell
 */
export const MemorizeSpell = new MemorizeSpell$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Charm$Type extends MessageType<Charm> {
    constructor() {
        super("eq.Charm", [
            { no: 1, name: "owner_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "pet_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "command", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Charm>): Charm {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ownerId = 0;
        message.petId = 0;
        message.command = 0;
        if (value !== undefined)
            reflectionMergePartial<Charm>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Charm): Charm {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 owner_id */ 1:
                    message.ownerId = reader.int32();
                    break;
                case /* int32 pet_id */ 2:
                    message.petId = reader.int32();
                    break;
                case /* int32 command */ 3:
                    message.command = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Charm, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 owner_id = 1; */
        if (message.ownerId !== 0)
            writer.tag(1, WireType.Varint).int32(message.ownerId);
        /* int32 pet_id = 2; */
        if (message.petId !== 0)
            writer.tag(2, WireType.Varint).int32(message.petId);
        /* int32 command = 3; */
        if (message.command !== 0)
            writer.tag(3, WireType.Varint).int32(message.command);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Charm
 */
export const Charm = new Charm$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InterruptCast$Type extends MessageType<InterruptCast> {
    constructor() {
        super("eq.InterruptCast", [
            { no: 1, name: "spawnid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "messageid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<InterruptCast>): InterruptCast {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.spawnid = 0;
        message.messageid = 0;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<InterruptCast>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InterruptCast): InterruptCast {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 spawnid */ 1:
                    message.spawnid = reader.int32();
                    break;
                case /* int32 messageid */ 2:
                    message.messageid = reader.int32();
                    break;
                case /* string message */ 3:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InterruptCast, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 spawnid = 1; */
        if (message.spawnid !== 0)
            writer.tag(1, WireType.Varint).int32(message.spawnid);
        /* int32 messageid = 2; */
        if (message.messageid !== 0)
            writer.tag(2, WireType.Varint).int32(message.messageid);
        /* string message = 3; */
        if (message.message !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.InterruptCast
 */
export const InterruptCast = new InterruptCast$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteSpell$Type extends MessageType<DeleteSpell> {
    constructor() {
        super("eq.DeleteSpell", [
            { no: 1, name: "spell_slot", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "success", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteSpell>): DeleteSpell {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.spellSlot = 0;
        message.success = 0;
        if (value !== undefined)
            reflectionMergePartial<DeleteSpell>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteSpell): DeleteSpell {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 spell_slot */ 1:
                    message.spellSlot = reader.int32();
                    break;
                case /* int32 success */ 2:
                    message.success = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteSpell, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 spell_slot = 1; */
        if (message.spellSlot !== 0)
            writer.tag(1, WireType.Varint).int32(message.spellSlot);
        /* int32 success = 2; */
        if (message.success !== 0)
            writer.tag(2, WireType.Varint).int32(message.success);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.DeleteSpell
 */
export const DeleteSpell = new DeleteSpell$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ManaChange$Type extends MessageType<ManaChange> {
    constructor() {
        super("eq.ManaChange", [
            { no: 1, name: "new_mana", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "stamina", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "spell_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "keepcasting", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "padding", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ManaChange>): ManaChange {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.newMana = 0;
        message.stamina = 0;
        message.spellId = 0;
        message.keepcasting = 0;
        message.padding = [];
        if (value !== undefined)
            reflectionMergePartial<ManaChange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ManaChange): ManaChange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 new_mana */ 1:
                    message.newMana = reader.int32();
                    break;
                case /* int32 stamina */ 2:
                    message.stamina = reader.int32();
                    break;
                case /* int32 spell_id */ 3:
                    message.spellId = reader.int32();
                    break;
                case /* int32 keepcasting */ 4:
                    message.keepcasting = reader.int32();
                    break;
                case /* repeated int32 padding */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.padding.push(reader.int32());
                    else
                        message.padding.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ManaChange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 new_mana = 1; */
        if (message.newMana !== 0)
            writer.tag(1, WireType.Varint).int32(message.newMana);
        /* int32 stamina = 2; */
        if (message.stamina !== 0)
            writer.tag(2, WireType.Varint).int32(message.stamina);
        /* int32 spell_id = 3; */
        if (message.spellId !== 0)
            writer.tag(3, WireType.Varint).int32(message.spellId);
        /* int32 keepcasting = 4; */
        if (message.keepcasting !== 0)
            writer.tag(4, WireType.Varint).int32(message.keepcasting);
        /* repeated int32 padding = 5; */
        if (message.padding.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.padding.length; i++)
                writer.int32(message.padding[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.ManaChange
 */
export const ManaChange = new ManaChange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SwapSpell$Type extends MessageType<SwapSpell> {
    constructor() {
        super("eq.SwapSpell", [
            { no: 1, name: "from_slot", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "to_slot", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SwapSpell>): SwapSpell {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fromSlot = 0;
        message.toSlot = 0;
        if (value !== undefined)
            reflectionMergePartial<SwapSpell>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SwapSpell): SwapSpell {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 from_slot */ 1:
                    message.fromSlot = reader.int32();
                    break;
                case /* int32 to_slot */ 2:
                    message.toSlot = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SwapSpell, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 from_slot = 1; */
        if (message.fromSlot !== 0)
            writer.tag(1, WireType.Varint).int32(message.fromSlot);
        /* int32 to_slot = 2; */
        if (message.toSlot !== 0)
            writer.tag(2, WireType.Varint).int32(message.toSlot);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.SwapSpell
 */
export const SwapSpell = new SwapSpell$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BeginCast$Type extends MessageType<BeginCast> {
    constructor() {
        super("eq.BeginCast", [
            { no: 1, name: "caster_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "spell_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "cast_time", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<BeginCast>): BeginCast {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.casterId = 0;
        message.spellId = 0;
        message.castTime = 0;
        if (value !== undefined)
            reflectionMergePartial<BeginCast>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BeginCast): BeginCast {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 caster_id */ 1:
                    message.casterId = reader.int32();
                    break;
                case /* int32 spell_id */ 2:
                    message.spellId = reader.int32();
                    break;
                case /* int32 cast_time */ 3:
                    message.castTime = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BeginCast, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 caster_id = 1; */
        if (message.casterId !== 0)
            writer.tag(1, WireType.Varint).int32(message.casterId);
        /* int32 spell_id = 2; */
        if (message.spellId !== 0)
            writer.tag(2, WireType.Varint).int32(message.spellId);
        /* int32 cast_time = 3; */
        if (message.castTime !== 0)
            writer.tag(3, WireType.Varint).int32(message.castTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.BeginCast
 */
export const BeginCast = new BeginCast$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CastSpell$Type extends MessageType<CastSpell> {
    constructor() {
        super("eq.CastSpell", [
            { no: 1, name: "slot", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "spell_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "inventoryslot", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "target_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CastSpell>): CastSpell {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.slot = 0;
        message.spellId = 0;
        message.inventoryslot = 0;
        message.targetId = 0;
        if (value !== undefined)
            reflectionMergePartial<CastSpell>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CastSpell): CastSpell {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 slot */ 1:
                    message.slot = reader.int32();
                    break;
                case /* int32 spell_id */ 2:
                    message.spellId = reader.int32();
                    break;
                case /* int32 inventoryslot */ 3:
                    message.inventoryslot = reader.int32();
                    break;
                case /* int32 target_id */ 4:
                    message.targetId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CastSpell, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 slot = 1; */
        if (message.slot !== 0)
            writer.tag(1, WireType.Varint).int32(message.slot);
        /* int32 spell_id = 2; */
        if (message.spellId !== 0)
            writer.tag(2, WireType.Varint).int32(message.spellId);
        /* int32 inventoryslot = 3; */
        if (message.inventoryslot !== 0)
            writer.tag(3, WireType.Varint).int32(message.inventoryslot);
        /* int32 target_id = 4; */
        if (message.targetId !== 0)
            writer.tag(4, WireType.Varint).int32(message.targetId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.CastSpell
 */
export const CastSpell = new CastSpell$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpawnAppearance$Type extends MessageType<SpawnAppearance> {
    constructor() {
        super("eq.SpawnAppearance", [
            { no: 1, name: "spawn_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "parameter", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SpawnAppearance>): SpawnAppearance {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.spawnId = 0;
        message.type = 0;
        message.parameter = 0;
        if (value !== undefined)
            reflectionMergePartial<SpawnAppearance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpawnAppearance): SpawnAppearance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 spawn_id */ 1:
                    message.spawnId = reader.int32();
                    break;
                case /* int32 type */ 2:
                    message.type = reader.int32();
                    break;
                case /* int32 parameter */ 3:
                    message.parameter = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpawnAppearance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 spawn_id = 1; */
        if (message.spawnId !== 0)
            writer.tag(1, WireType.Varint).int32(message.spawnId);
        /* int32 type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* int32 parameter = 3; */
        if (message.parameter !== 0)
            writer.tag(3, WireType.Varint).int32(message.parameter);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.SpawnAppearance
 */
export const SpawnAppearance = new SpawnAppearance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpellBuff$Type extends MessageType<SpellBuff> {
    constructor() {
        super("eq.SpellBuff", [
            { no: 1, name: "effect_type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "level", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "bard_modifier", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "spellid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "duration", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "counters", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "player_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SpellBuff>): SpellBuff {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.effectType = 0;
        message.level = 0;
        message.bardModifier = 0;
        message.spellid = 0;
        message.duration = 0;
        message.counters = 0;
        message.playerId = 0;
        if (value !== undefined)
            reflectionMergePartial<SpellBuff>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpellBuff): SpellBuff {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 effect_type */ 1:
                    message.effectType = reader.int32();
                    break;
                case /* int32 level */ 2:
                    message.level = reader.int32();
                    break;
                case /* int32 bard_modifier */ 3:
                    message.bardModifier = reader.int32();
                    break;
                case /* int32 spellid */ 4:
                    message.spellid = reader.int32();
                    break;
                case /* int32 duration */ 5:
                    message.duration = reader.int32();
                    break;
                case /* int32 counters */ 6:
                    message.counters = reader.int32();
                    break;
                case /* int32 player_id */ 7:
                    message.playerId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpellBuff, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 effect_type = 1; */
        if (message.effectType !== 0)
            writer.tag(1, WireType.Varint).int32(message.effectType);
        /* int32 level = 2; */
        if (message.level !== 0)
            writer.tag(2, WireType.Varint).int32(message.level);
        /* int32 bard_modifier = 3; */
        if (message.bardModifier !== 0)
            writer.tag(3, WireType.Varint).int32(message.bardModifier);
        /* int32 spellid = 4; */
        if (message.spellid !== 0)
            writer.tag(4, WireType.Varint).int32(message.spellid);
        /* int32 duration = 5; */
        if (message.duration !== 0)
            writer.tag(5, WireType.Varint).int32(message.duration);
        /* int32 counters = 6; */
        if (message.counters !== 0)
            writer.tag(6, WireType.Varint).int32(message.counters);
        /* int32 player_id = 7; */
        if (message.playerId !== 0)
            writer.tag(7, WireType.Varint).int32(message.playerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.SpellBuff
 */
export const SpellBuff = new SpellBuff$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpellBuffPacket$Type extends MessageType<SpellBuffPacket> {
    constructor() {
        super("eq.SpellBuffPacket", [
            { no: 1, name: "entityid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "buff", kind: "message", T: () => SpellBuff },
            { no: 3, name: "slotid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "bufffade", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SpellBuffPacket>): SpellBuffPacket {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entityid = 0;
        message.slotid = 0;
        message.bufffade = 0;
        if (value !== undefined)
            reflectionMergePartial<SpellBuffPacket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpellBuffPacket): SpellBuffPacket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 entityid */ 1:
                    message.entityid = reader.int32();
                    break;
                case /* eq.SpellBuff buff */ 2:
                    message.buff = SpellBuff.internalBinaryRead(reader, reader.uint32(), options, message.buff);
                    break;
                case /* int32 slotid */ 3:
                    message.slotid = reader.int32();
                    break;
                case /* int32 bufffade */ 4:
                    message.bufffade = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpellBuffPacket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 entityid = 1; */
        if (message.entityid !== 0)
            writer.tag(1, WireType.Varint).int32(message.entityid);
        /* eq.SpellBuff buff = 2; */
        if (message.buff)
            SpellBuff.internalBinaryWrite(message.buff, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int32 slotid = 3; */
        if (message.slotid !== 0)
            writer.tag(3, WireType.Varint).int32(message.slotid);
        /* int32 bufffade = 4; */
        if (message.bufffade !== 0)
            writer.tag(4, WireType.Varint).int32(message.bufffade);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.SpellBuffPacket
 */
export const SpellBuffPacket = new SpellBuffPacket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ItemNamePacket$Type extends MessageType<ItemNamePacket> {
    constructor() {
        super("eq.ItemNamePacket", [
            { no: 1, name: "item_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "unkown", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ItemNamePacket>): ItemNamePacket {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.itemId = 0;
        message.unkown = 0;
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<ItemNamePacket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ItemNamePacket): ItemNamePacket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 item_id */ 1:
                    message.itemId = reader.int32();
                    break;
                case /* int32 unkown */ 2:
                    message.unkown = reader.int32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ItemNamePacket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 item_id = 1; */
        if (message.itemId !== 0)
            writer.tag(1, WireType.Varint).int32(message.itemId);
        /* int32 unkown = 2; */
        if (message.unkown !== 0)
            writer.tag(2, WireType.Varint).int32(message.unkown);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.ItemNamePacket
 */
export const ItemNamePacket = new ItemNamePacket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ItemProperties$Type extends MessageType<ItemProperties> {
    constructor() {
        super("eq.ItemProperties", [
            { no: 1, name: "charges", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ItemProperties>): ItemProperties {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.charges = 0;
        if (value !== undefined)
            reflectionMergePartial<ItemProperties>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ItemProperties): ItemProperties {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 charges */ 1:
                    message.charges = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ItemProperties, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 charges = 1; */
        if (message.charges !== 0)
            writer.tag(1, WireType.Varint).int32(message.charges);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.ItemProperties
 */
export const ItemProperties = new ItemProperties$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GMTrainee$Type extends MessageType<GMTrainee> {
    constructor() {
        super("eq.GMTrainee", [
            { no: 1, name: "npcid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "playerid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "skills", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GMTrainee>): GMTrainee {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.npcid = 0;
        message.playerid = 0;
        message.skills = [];
        if (value !== undefined)
            reflectionMergePartial<GMTrainee>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GMTrainee): GMTrainee {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 npcid */ 1:
                    message.npcid = reader.int32();
                    break;
                case /* int32 playerid */ 2:
                    message.playerid = reader.int32();
                    break;
                case /* repeated int32 skills */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.skills.push(reader.int32());
                    else
                        message.skills.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GMTrainee, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 npcid = 1; */
        if (message.npcid !== 0)
            writer.tag(1, WireType.Varint).int32(message.npcid);
        /* int32 playerid = 2; */
        if (message.playerid !== 0)
            writer.tag(2, WireType.Varint).int32(message.playerid);
        /* repeated int32 skills = 3; */
        if (message.skills.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.skills.length; i++)
                writer.int32(message.skills[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.GMTrainee
 */
export const GMTrainee = new GMTrainee$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GMTrainEnd$Type extends MessageType<GMTrainEnd> {
    constructor() {
        super("eq.GMTrainEnd", [
            { no: 1, name: "npcid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "playerid", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GMTrainEnd>): GMTrainEnd {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.npcid = 0;
        message.playerid = 0;
        if (value !== undefined)
            reflectionMergePartial<GMTrainEnd>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GMTrainEnd): GMTrainEnd {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 npcid */ 1:
                    message.npcid = reader.int32();
                    break;
                case /* int32 playerid */ 2:
                    message.playerid = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GMTrainEnd, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 npcid = 1; */
        if (message.npcid !== 0)
            writer.tag(1, WireType.Varint).int32(message.npcid);
        /* int32 playerid = 2; */
        if (message.playerid !== 0)
            writer.tag(2, WireType.Varint).int32(message.playerid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.GMTrainEnd
 */
export const GMTrainEnd = new GMTrainEnd$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GMSkillChange$Type extends MessageType<GMSkillChange> {
    constructor() {
        super("eq.GMSkillChange", [
            { no: 1, name: "npcid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "skillbank", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "skill_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GMSkillChange>): GMSkillChange {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.npcid = 0;
        message.skillbank = 0;
        message.skillId = 0;
        if (value !== undefined)
            reflectionMergePartial<GMSkillChange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GMSkillChange): GMSkillChange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 npcid */ 1:
                    message.npcid = reader.int32();
                    break;
                case /* int32 skillbank */ 2:
                    message.skillbank = reader.int32();
                    break;
                case /* int32 skill_id */ 3:
                    message.skillId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GMSkillChange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 npcid = 1; */
        if (message.npcid !== 0)
            writer.tag(1, WireType.Varint).int32(message.npcid);
        /* int32 skillbank = 2; */
        if (message.skillbank !== 0)
            writer.tag(2, WireType.Varint).int32(message.skillbank);
        /* int32 skill_id = 3; */
        if (message.skillId !== 0)
            writer.tag(3, WireType.Varint).int32(message.skillId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.GMSkillChange
 */
export const GMSkillChange = new GMSkillChange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConsentResponse$Type extends MessageType<ConsentResponse> {
    constructor() {
        super("eq.ConsentResponse", [
            { no: 1, name: "grantname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ownername", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "permission", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "zonename", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ConsentResponse>): ConsentResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.grantname = "";
        message.ownername = "";
        message.permission = 0;
        message.zonename = "";
        if (value !== undefined)
            reflectionMergePartial<ConsentResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConsentResponse): ConsentResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string grantname */ 1:
                    message.grantname = reader.string();
                    break;
                case /* string ownername */ 2:
                    message.ownername = reader.string();
                    break;
                case /* int32 permission */ 3:
                    message.permission = reader.int32();
                    break;
                case /* string zonename */ 4:
                    message.zonename = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConsentResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string grantname = 1; */
        if (message.grantname !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.grantname);
        /* string ownername = 2; */
        if (message.ownername !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.ownername);
        /* int32 permission = 3; */
        if (message.permission !== 0)
            writer.tag(3, WireType.Varint).int32(message.permission);
        /* string zonename = 4; */
        if (message.zonename !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.zonename);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.ConsentResponse
 */
export const ConsentResponse = new ConsentResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NameGeneration$Type extends MessageType<NameGeneration> {
    constructor() {
        super("eq.NameGeneration", [
            { no: 1, name: "race", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "gender", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<NameGeneration>): NameGeneration {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.race = 0;
        message.gender = 0;
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<NameGeneration>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NameGeneration): NameGeneration {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 race */ 1:
                    message.race = reader.int32();
                    break;
                case /* int32 gender */ 2:
                    message.gender = reader.int32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NameGeneration, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 race = 1; */
        if (message.race !== 0)
            writer.tag(1, WireType.Varint).int32(message.race);
        /* int32 gender = 2; */
        if (message.gender !== 0)
            writer.tag(2, WireType.Varint).int32(message.gender);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.NameGeneration
 */
export const NameGeneration = new NameGeneration$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NameApprove$Type extends MessageType<NameApprove> {
    constructor() {
        super("eq.NameApprove", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "race", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "gender", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<NameApprove>): NameApprove {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.race = 0;
        message.gender = 0;
        if (value !== undefined)
            reflectionMergePartial<NameApprove>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NameApprove): NameApprove {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* int32 race */ 2:
                    message.race = reader.int32();
                    break;
                case /* int32 gender */ 3:
                    message.gender = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NameApprove, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* int32 race = 2; */
        if (message.race !== 0)
            writer.tag(2, WireType.Varint).int32(message.race);
        /* int32 gender = 3; */
        if (message.gender !== 0)
            writer.tag(3, WireType.Varint).int32(message.gender);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.NameApprove
 */
export const NameApprove = new NameApprove$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CharCreate$Type extends MessageType<CharCreate> {
    constructor() {
        super("eq.CharCreate", [
            { no: 1, name: "char_class", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "haircolor", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "beardcolor", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "beard", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "gender", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "race", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "start_zone", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "hairstyle", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "deity", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "str", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "sta", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "agi", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "dex", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "wis", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "intel", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 16, name: "cha", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 17, name: "face", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 18, name: "eyecolor1", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 19, name: "eyecolor2", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 20, name: "tutorial", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CharCreate>): CharCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.charClass = 0;
        message.haircolor = 0;
        message.beardcolor = 0;
        message.beard = 0;
        message.gender = 0;
        message.race = 0;
        message.startZone = 0;
        message.hairstyle = 0;
        message.deity = 0;
        message.str = 0;
        message.sta = 0;
        message.agi = 0;
        message.dex = 0;
        message.wis = 0;
        message.intel = 0;
        message.cha = 0;
        message.face = 0;
        message.eyecolor1 = 0;
        message.eyecolor2 = 0;
        message.tutorial = 0;
        if (value !== undefined)
            reflectionMergePartial<CharCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CharCreate): CharCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 char_class */ 1:
                    message.charClass = reader.int32();
                    break;
                case /* int32 haircolor */ 2:
                    message.haircolor = reader.int32();
                    break;
                case /* int32 beardcolor */ 3:
                    message.beardcolor = reader.int32();
                    break;
                case /* int32 beard */ 4:
                    message.beard = reader.int32();
                    break;
                case /* int32 gender */ 5:
                    message.gender = reader.int32();
                    break;
                case /* int32 race */ 6:
                    message.race = reader.int32();
                    break;
                case /* int32 start_zone */ 7:
                    message.startZone = reader.int32();
                    break;
                case /* int32 hairstyle */ 8:
                    message.hairstyle = reader.int32();
                    break;
                case /* int32 deity */ 9:
                    message.deity = reader.int32();
                    break;
                case /* int32 str */ 10:
                    message.str = reader.int32();
                    break;
                case /* int32 sta */ 11:
                    message.sta = reader.int32();
                    break;
                case /* int32 agi */ 12:
                    message.agi = reader.int32();
                    break;
                case /* int32 dex */ 13:
                    message.dex = reader.int32();
                    break;
                case /* int32 wis */ 14:
                    message.wis = reader.int32();
                    break;
                case /* int32 intel */ 15:
                    message.intel = reader.int32();
                    break;
                case /* int32 cha */ 16:
                    message.cha = reader.int32();
                    break;
                case /* int32 face */ 17:
                    message.face = reader.int32();
                    break;
                case /* int32 eyecolor1 */ 18:
                    message.eyecolor1 = reader.int32();
                    break;
                case /* int32 eyecolor2 */ 19:
                    message.eyecolor2 = reader.int32();
                    break;
                case /* int32 tutorial */ 20:
                    message.tutorial = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CharCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 char_class = 1; */
        if (message.charClass !== 0)
            writer.tag(1, WireType.Varint).int32(message.charClass);
        /* int32 haircolor = 2; */
        if (message.haircolor !== 0)
            writer.tag(2, WireType.Varint).int32(message.haircolor);
        /* int32 beardcolor = 3; */
        if (message.beardcolor !== 0)
            writer.tag(3, WireType.Varint).int32(message.beardcolor);
        /* int32 beard = 4; */
        if (message.beard !== 0)
            writer.tag(4, WireType.Varint).int32(message.beard);
        /* int32 gender = 5; */
        if (message.gender !== 0)
            writer.tag(5, WireType.Varint).int32(message.gender);
        /* int32 race = 6; */
        if (message.race !== 0)
            writer.tag(6, WireType.Varint).int32(message.race);
        /* int32 start_zone = 7; */
        if (message.startZone !== 0)
            writer.tag(7, WireType.Varint).int32(message.startZone);
        /* int32 hairstyle = 8; */
        if (message.hairstyle !== 0)
            writer.tag(8, WireType.Varint).int32(message.hairstyle);
        /* int32 deity = 9; */
        if (message.deity !== 0)
            writer.tag(9, WireType.Varint).int32(message.deity);
        /* int32 str = 10; */
        if (message.str !== 0)
            writer.tag(10, WireType.Varint).int32(message.str);
        /* int32 sta = 11; */
        if (message.sta !== 0)
            writer.tag(11, WireType.Varint).int32(message.sta);
        /* int32 agi = 12; */
        if (message.agi !== 0)
            writer.tag(12, WireType.Varint).int32(message.agi);
        /* int32 dex = 13; */
        if (message.dex !== 0)
            writer.tag(13, WireType.Varint).int32(message.dex);
        /* int32 wis = 14; */
        if (message.wis !== 0)
            writer.tag(14, WireType.Varint).int32(message.wis);
        /* int32 intel = 15; */
        if (message.intel !== 0)
            writer.tag(15, WireType.Varint).int32(message.intel);
        /* int32 cha = 16; */
        if (message.cha !== 0)
            writer.tag(16, WireType.Varint).int32(message.cha);
        /* int32 face = 17; */
        if (message.face !== 0)
            writer.tag(17, WireType.Varint).int32(message.face);
        /* int32 eyecolor1 = 18; */
        if (message.eyecolor1 !== 0)
            writer.tag(18, WireType.Varint).int32(message.eyecolor1);
        /* int32 eyecolor2 = 19; */
        if (message.eyecolor2 !== 0)
            writer.tag(19, WireType.Varint).int32(message.eyecolor2);
        /* int32 tutorial = 20; */
        if (message.tutorial !== 0)
            writer.tag(20, WireType.Varint).int32(message.tutorial);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.CharCreate
 */
export const CharCreate = new CharCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AA_Array$Type extends MessageType<AA_Array> {
    constructor() {
        super("eq.AA_Array", [
            { no: 1, name: "aa", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "value", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AA_Array>): AA_Array {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.aa = 0;
        message.value = 0;
        if (value !== undefined)
            reflectionMergePartial<AA_Array>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AA_Array): AA_Array {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 aa */ 1:
                    message.aa = reader.int32();
                    break;
                case /* int32 value */ 2:
                    message.value = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AA_Array, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 aa = 1; */
        if (message.aa !== 0)
            writer.tag(1, WireType.Varint).int32(message.aa);
        /* int32 value = 2; */
        if (message.value !== 0)
            writer.tag(2, WireType.Varint).int32(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.AA_Array
 */
export const AA_Array = new AA_Array$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Disciplines$Type extends MessageType<Disciplines> {
    constructor() {
        super("eq.Disciplines", [
            { no: 1, name: "values", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Disciplines>): Disciplines {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.values = [];
        if (value !== undefined)
            reflectionMergePartial<Disciplines>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Disciplines): Disciplines {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 values */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.values.push(reader.int32());
                    else
                        message.values.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Disciplines, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 values = 1; */
        if (message.values.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.values.length; i++)
                writer.int32(message.values[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Disciplines
 */
export const Disciplines = new Disciplines$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Tribute$Type extends MessageType<Tribute> {
    constructor() {
        super("eq.Tribute", [
            { no: 1, name: "tribute", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "tier", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Tribute>): Tribute {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tribute = 0;
        message.tier = 0;
        if (value !== undefined)
            reflectionMergePartial<Tribute>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Tribute): Tribute {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 tribute */ 1:
                    message.tribute = reader.int32();
                    break;
                case /* int32 tier */ 2:
                    message.tier = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Tribute, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 tribute = 1; */
        if (message.tribute !== 0)
            writer.tag(1, WireType.Varint).int32(message.tribute);
        /* int32 tier = 2; */
        if (message.tier !== 0)
            writer.tag(2, WireType.Varint).int32(message.tier);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Tribute
 */
export const Tribute = new Tribute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BandolierItem$Type extends MessageType<BandolierItem> {
    constructor() {
        super("eq.BandolierItem", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "icon", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BandolierItem>): BandolierItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.icon = 0;
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<BandolierItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BandolierItem): BandolierItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* int32 icon */ 2:
                    message.icon = reader.int32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BandolierItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* int32 icon = 2; */
        if (message.icon !== 0)
            writer.tag(2, WireType.Varint).int32(message.icon);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.BandolierItem
 */
export const BandolierItem = new BandolierItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Bandolier$Type extends MessageType<Bandolier> {
    constructor() {
        super("eq.Bandolier", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BandolierItem }
        ]);
    }
    create(value?: PartialMessage<Bandolier>): Bandolier {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.items = [];
        if (value !== undefined)
            reflectionMergePartial<Bandolier>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Bandolier): Bandolier {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* repeated eq.BandolierItem items */ 2:
                    message.items.push(BandolierItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Bandolier, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* repeated eq.BandolierItem items = 2; */
        for (let i = 0; i < message.items.length; i++)
            BandolierItem.internalBinaryWrite(message.items[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Bandolier
 */
export const Bandolier = new Bandolier$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PotionBeltItem$Type extends MessageType<PotionBeltItem> {
    constructor() {
        super("eq.PotionBeltItem", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "icon", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PotionBeltItem>): PotionBeltItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.icon = 0;
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<PotionBeltItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PotionBeltItem): PotionBeltItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* int32 icon */ 2:
                    message.icon = reader.int32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PotionBeltItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* int32 icon = 2; */
        if (message.icon !== 0)
            writer.tag(2, WireType.Varint).int32(message.icon);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.PotionBeltItem
 */
export const PotionBeltItem = new PotionBeltItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PotionBelt$Type extends MessageType<PotionBelt> {
    constructor() {
        super("eq.PotionBelt", [
            { no: 1, name: "items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PotionBeltItem }
        ]);
    }
    create(value?: PartialMessage<PotionBelt>): PotionBelt {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.items = [];
        if (value !== undefined)
            reflectionMergePartial<PotionBelt>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PotionBelt): PotionBelt {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eq.PotionBeltItem items */ 1:
                    message.items.push(PotionBeltItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PotionBelt, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated eq.PotionBeltItem items = 1; */
        for (let i = 0; i < message.items.length; i++)
            PotionBeltItem.internalBinaryWrite(message.items[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.PotionBelt
 */
export const PotionBelt = new PotionBelt$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StringList$Type extends MessageType<StringList> {
    constructor() {
        super("eq.StringList", [
            { no: 1, name: "str", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StringList>): StringList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.str = "";
        if (value !== undefined)
            reflectionMergePartial<StringList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StringList): StringList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string str */ 1:
                    message.str = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StringList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string str = 1; */
        if (message.str !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.str);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.StringList
 */
export const StringList = new StringList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroupLeadershipAA$Type extends MessageType<GroupLeadershipAA> {
    constructor() {
        super("eq.GroupLeadershipAA", [
            { no: 1, name: "group_aa_mark_npc", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "group_aanpc_health", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "group_aa_delegate_main_assist", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "group_aa_delegate_mark_npc", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "group_aa4", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "group_aa5", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "group_aa_inspect_buffs", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "group_aa7", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "group_aa_spell_awareness", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "group_aa_offense_enhancement", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "group_aa_mana_enhancement", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "group_aa_health_enhancement", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "group_aa_health_regeneration", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "group_aa_find_path_to_pc", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "group_aa_health_of_targets_target", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 16, name: "group_aa15", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GroupLeadershipAA>): GroupLeadershipAA {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.groupAaMarkNpc = 0;
        message.groupAanpcHealth = 0;
        message.groupAaDelegateMainAssist = 0;
        message.groupAaDelegateMarkNpc = 0;
        message.groupAa4 = 0;
        message.groupAa5 = 0;
        message.groupAaInspectBuffs = 0;
        message.groupAa7 = 0;
        message.groupAaSpellAwareness = 0;
        message.groupAaOffenseEnhancement = 0;
        message.groupAaManaEnhancement = 0;
        message.groupAaHealthEnhancement = 0;
        message.groupAaHealthRegeneration = 0;
        message.groupAaFindPathToPc = 0;
        message.groupAaHealthOfTargetsTarget = 0;
        message.groupAa15 = 0;
        if (value !== undefined)
            reflectionMergePartial<GroupLeadershipAA>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GroupLeadershipAA): GroupLeadershipAA {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 group_aa_mark_npc */ 1:
                    message.groupAaMarkNpc = reader.int32();
                    break;
                case /* int32 group_aanpc_health */ 2:
                    message.groupAanpcHealth = reader.int32();
                    break;
                case /* int32 group_aa_delegate_main_assist */ 3:
                    message.groupAaDelegateMainAssist = reader.int32();
                    break;
                case /* int32 group_aa_delegate_mark_npc */ 4:
                    message.groupAaDelegateMarkNpc = reader.int32();
                    break;
                case /* int32 group_aa4 */ 5:
                    message.groupAa4 = reader.int32();
                    break;
                case /* int32 group_aa5 */ 6:
                    message.groupAa5 = reader.int32();
                    break;
                case /* int32 group_aa_inspect_buffs */ 7:
                    message.groupAaInspectBuffs = reader.int32();
                    break;
                case /* int32 group_aa7 */ 8:
                    message.groupAa7 = reader.int32();
                    break;
                case /* int32 group_aa_spell_awareness */ 9:
                    message.groupAaSpellAwareness = reader.int32();
                    break;
                case /* int32 group_aa_offense_enhancement */ 10:
                    message.groupAaOffenseEnhancement = reader.int32();
                    break;
                case /* int32 group_aa_mana_enhancement */ 11:
                    message.groupAaManaEnhancement = reader.int32();
                    break;
                case /* int32 group_aa_health_enhancement */ 12:
                    message.groupAaHealthEnhancement = reader.int32();
                    break;
                case /* int32 group_aa_health_regeneration */ 13:
                    message.groupAaHealthRegeneration = reader.int32();
                    break;
                case /* int32 group_aa_find_path_to_pc */ 14:
                    message.groupAaFindPathToPc = reader.int32();
                    break;
                case /* int32 group_aa_health_of_targets_target */ 15:
                    message.groupAaHealthOfTargetsTarget = reader.int32();
                    break;
                case /* int32 group_aa15 */ 16:
                    message.groupAa15 = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GroupLeadershipAA, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 group_aa_mark_npc = 1; */
        if (message.groupAaMarkNpc !== 0)
            writer.tag(1, WireType.Varint).int32(message.groupAaMarkNpc);
        /* int32 group_aanpc_health = 2; */
        if (message.groupAanpcHealth !== 0)
            writer.tag(2, WireType.Varint).int32(message.groupAanpcHealth);
        /* int32 group_aa_delegate_main_assist = 3; */
        if (message.groupAaDelegateMainAssist !== 0)
            writer.tag(3, WireType.Varint).int32(message.groupAaDelegateMainAssist);
        /* int32 group_aa_delegate_mark_npc = 4; */
        if (message.groupAaDelegateMarkNpc !== 0)
            writer.tag(4, WireType.Varint).int32(message.groupAaDelegateMarkNpc);
        /* int32 group_aa4 = 5; */
        if (message.groupAa4 !== 0)
            writer.tag(5, WireType.Varint).int32(message.groupAa4);
        /* int32 group_aa5 = 6; */
        if (message.groupAa5 !== 0)
            writer.tag(6, WireType.Varint).int32(message.groupAa5);
        /* int32 group_aa_inspect_buffs = 7; */
        if (message.groupAaInspectBuffs !== 0)
            writer.tag(7, WireType.Varint).int32(message.groupAaInspectBuffs);
        /* int32 group_aa7 = 8; */
        if (message.groupAa7 !== 0)
            writer.tag(8, WireType.Varint).int32(message.groupAa7);
        /* int32 group_aa_spell_awareness = 9; */
        if (message.groupAaSpellAwareness !== 0)
            writer.tag(9, WireType.Varint).int32(message.groupAaSpellAwareness);
        /* int32 group_aa_offense_enhancement = 10; */
        if (message.groupAaOffenseEnhancement !== 0)
            writer.tag(10, WireType.Varint).int32(message.groupAaOffenseEnhancement);
        /* int32 group_aa_mana_enhancement = 11; */
        if (message.groupAaManaEnhancement !== 0)
            writer.tag(11, WireType.Varint).int32(message.groupAaManaEnhancement);
        /* int32 group_aa_health_enhancement = 12; */
        if (message.groupAaHealthEnhancement !== 0)
            writer.tag(12, WireType.Varint).int32(message.groupAaHealthEnhancement);
        /* int32 group_aa_health_regeneration = 13; */
        if (message.groupAaHealthRegeneration !== 0)
            writer.tag(13, WireType.Varint).int32(message.groupAaHealthRegeneration);
        /* int32 group_aa_find_path_to_pc = 14; */
        if (message.groupAaFindPathToPc !== 0)
            writer.tag(14, WireType.Varint).int32(message.groupAaFindPathToPc);
        /* int32 group_aa_health_of_targets_target = 15; */
        if (message.groupAaHealthOfTargetsTarget !== 0)
            writer.tag(15, WireType.Varint).int32(message.groupAaHealthOfTargetsTarget);
        /* int32 group_aa15 = 16; */
        if (message.groupAa15 !== 0)
            writer.tag(16, WireType.Varint).int32(message.groupAa15);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.GroupLeadershipAA
 */
export const GroupLeadershipAA = new GroupLeadershipAA$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RaidLeadershipAA$Type extends MessageType<RaidLeadershipAA> {
    constructor() {
        super("eq.RaidLeadershipAA", [
            { no: 1, name: "raid_aa_mark_npc", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "raid_aanpc_health", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "raid_aa_delegate_main_assist", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "raid_aa_delegate_mark_npc", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "raid_aa4", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "raid_aa5", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "raid_aa6", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "raid_aa_spell_awareness", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "raid_aa_offense_enhancement", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "raid_aa_mana_enhancement", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "raid_aa_health_enhancement", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "raid_aa_health_regeneration", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "raid_aa_find_path_to_pc", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "raid_aa_health_of_targets_target", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "raid_aa14", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 16, name: "raid_aa15", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<RaidLeadershipAA>): RaidLeadershipAA {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.raidAaMarkNpc = 0;
        message.raidAanpcHealth = 0;
        message.raidAaDelegateMainAssist = 0;
        message.raidAaDelegateMarkNpc = 0;
        message.raidAa4 = 0;
        message.raidAa5 = 0;
        message.raidAa6 = 0;
        message.raidAaSpellAwareness = 0;
        message.raidAaOffenseEnhancement = 0;
        message.raidAaManaEnhancement = 0;
        message.raidAaHealthEnhancement = 0;
        message.raidAaHealthRegeneration = 0;
        message.raidAaFindPathToPc = 0;
        message.raidAaHealthOfTargetsTarget = 0;
        message.raidAa14 = 0;
        message.raidAa15 = 0;
        if (value !== undefined)
            reflectionMergePartial<RaidLeadershipAA>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RaidLeadershipAA): RaidLeadershipAA {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 raid_aa_mark_npc */ 1:
                    message.raidAaMarkNpc = reader.int32();
                    break;
                case /* int32 raid_aanpc_health */ 2:
                    message.raidAanpcHealth = reader.int32();
                    break;
                case /* int32 raid_aa_delegate_main_assist */ 3:
                    message.raidAaDelegateMainAssist = reader.int32();
                    break;
                case /* int32 raid_aa_delegate_mark_npc */ 4:
                    message.raidAaDelegateMarkNpc = reader.int32();
                    break;
                case /* int32 raid_aa4 */ 5:
                    message.raidAa4 = reader.int32();
                    break;
                case /* int32 raid_aa5 */ 6:
                    message.raidAa5 = reader.int32();
                    break;
                case /* int32 raid_aa6 */ 7:
                    message.raidAa6 = reader.int32();
                    break;
                case /* int32 raid_aa_spell_awareness */ 8:
                    message.raidAaSpellAwareness = reader.int32();
                    break;
                case /* int32 raid_aa_offense_enhancement */ 9:
                    message.raidAaOffenseEnhancement = reader.int32();
                    break;
                case /* int32 raid_aa_mana_enhancement */ 10:
                    message.raidAaManaEnhancement = reader.int32();
                    break;
                case /* int32 raid_aa_health_enhancement */ 11:
                    message.raidAaHealthEnhancement = reader.int32();
                    break;
                case /* int32 raid_aa_health_regeneration */ 12:
                    message.raidAaHealthRegeneration = reader.int32();
                    break;
                case /* int32 raid_aa_find_path_to_pc */ 13:
                    message.raidAaFindPathToPc = reader.int32();
                    break;
                case /* int32 raid_aa_health_of_targets_target */ 14:
                    message.raidAaHealthOfTargetsTarget = reader.int32();
                    break;
                case /* int32 raid_aa14 */ 15:
                    message.raidAa14 = reader.int32();
                    break;
                case /* int32 raid_aa15 */ 16:
                    message.raidAa15 = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RaidLeadershipAA, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 raid_aa_mark_npc = 1; */
        if (message.raidAaMarkNpc !== 0)
            writer.tag(1, WireType.Varint).int32(message.raidAaMarkNpc);
        /* int32 raid_aanpc_health = 2; */
        if (message.raidAanpcHealth !== 0)
            writer.tag(2, WireType.Varint).int32(message.raidAanpcHealth);
        /* int32 raid_aa_delegate_main_assist = 3; */
        if (message.raidAaDelegateMainAssist !== 0)
            writer.tag(3, WireType.Varint).int32(message.raidAaDelegateMainAssist);
        /* int32 raid_aa_delegate_mark_npc = 4; */
        if (message.raidAaDelegateMarkNpc !== 0)
            writer.tag(4, WireType.Varint).int32(message.raidAaDelegateMarkNpc);
        /* int32 raid_aa4 = 5; */
        if (message.raidAa4 !== 0)
            writer.tag(5, WireType.Varint).int32(message.raidAa4);
        /* int32 raid_aa5 = 6; */
        if (message.raidAa5 !== 0)
            writer.tag(6, WireType.Varint).int32(message.raidAa5);
        /* int32 raid_aa6 = 7; */
        if (message.raidAa6 !== 0)
            writer.tag(7, WireType.Varint).int32(message.raidAa6);
        /* int32 raid_aa_spell_awareness = 8; */
        if (message.raidAaSpellAwareness !== 0)
            writer.tag(8, WireType.Varint).int32(message.raidAaSpellAwareness);
        /* int32 raid_aa_offense_enhancement = 9; */
        if (message.raidAaOffenseEnhancement !== 0)
            writer.tag(9, WireType.Varint).int32(message.raidAaOffenseEnhancement);
        /* int32 raid_aa_mana_enhancement = 10; */
        if (message.raidAaManaEnhancement !== 0)
            writer.tag(10, WireType.Varint).int32(message.raidAaManaEnhancement);
        /* int32 raid_aa_health_enhancement = 11; */
        if (message.raidAaHealthEnhancement !== 0)
            writer.tag(11, WireType.Varint).int32(message.raidAaHealthEnhancement);
        /* int32 raid_aa_health_regeneration = 12; */
        if (message.raidAaHealthRegeneration !== 0)
            writer.tag(12, WireType.Varint).int32(message.raidAaHealthRegeneration);
        /* int32 raid_aa_find_path_to_pc = 13; */
        if (message.raidAaFindPathToPc !== 0)
            writer.tag(13, WireType.Varint).int32(message.raidAaFindPathToPc);
        /* int32 raid_aa_health_of_targets_target = 14; */
        if (message.raidAaHealthOfTargetsTarget !== 0)
            writer.tag(14, WireType.Varint).int32(message.raidAaHealthOfTargetsTarget);
        /* int32 raid_aa14 = 15; */
        if (message.raidAa14 !== 0)
            writer.tag(15, WireType.Varint).int32(message.raidAa14);
        /* int32 raid_aa15 = 16; */
        if (message.raidAa15 !== 0)
            writer.tag(16, WireType.Varint).int32(message.raidAa15);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.RaidLeadershipAA
 */
export const RaidLeadershipAA = new RaidLeadershipAA$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LeadershipAA$Type extends MessageType<LeadershipAA> {
    constructor() {
        super("eq.LeadershipAA", [
            { no: 1, name: "group", kind: "message", T: () => GroupLeadershipAA },
            { no: 2, name: "raid", kind: "message", T: () => RaidLeadershipAA }
        ]);
    }
    create(value?: PartialMessage<LeadershipAA>): LeadershipAA {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<LeadershipAA>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LeadershipAA): LeadershipAA {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* eq.GroupLeadershipAA group */ 1:
                    message.group = GroupLeadershipAA.internalBinaryRead(reader, reader.uint32(), options, message.group);
                    break;
                case /* eq.RaidLeadershipAA raid */ 2:
                    message.raid = RaidLeadershipAA.internalBinaryRead(reader, reader.uint32(), options, message.raid);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LeadershipAA, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* eq.GroupLeadershipAA group = 1; */
        if (message.group)
            GroupLeadershipAA.internalBinaryWrite(message.group, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* eq.RaidLeadershipAA raid = 2; */
        if (message.raid)
            RaidLeadershipAA.internalBinaryWrite(message.raid, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.LeadershipAA
 */
export const LeadershipAA = new LeadershipAA$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Bind$Type extends MessageType<Bind> {
    constructor() {
        super("eq.Bind", [
            { no: 1, name: "zone_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "z", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "heading", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Bind>): Bind {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.zoneId = 0;
        message.x = 0;
        message.y = 0;
        message.z = 0;
        message.heading = 0;
        if (value !== undefined)
            reflectionMergePartial<Bind>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Bind): Bind {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 zone_id */ 1:
                    message.zoneId = reader.int32();
                    break;
                case /* float x */ 2:
                    message.x = reader.float();
                    break;
                case /* float y */ 3:
                    message.y = reader.float();
                    break;
                case /* float z */ 4:
                    message.z = reader.float();
                    break;
                case /* float heading */ 5:
                    message.heading = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Bind, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 zone_id = 1; */
        if (message.zoneId !== 0)
            writer.tag(1, WireType.Varint).int32(message.zoneId);
        /* float x = 2; */
        if (message.x !== 0)
            writer.tag(2, WireType.Bit32).float(message.x);
        /* float y = 3; */
        if (message.y !== 0)
            writer.tag(3, WireType.Bit32).float(message.y);
        /* float z = 4; */
        if (message.z !== 0)
            writer.tag(4, WireType.Bit32).float(message.z);
        /* float heading = 5; */
        if (message.heading !== 0)
            writer.tag(5, WireType.Bit32).float(message.heading);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Bind
 */
export const Bind = new Bind$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PVPStatsEntry$Type extends MessageType<PVPStatsEntry> {
    constructor() {
        super("eq.PVPStatsEntry", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "level", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "race", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "char_class", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "zone", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "time", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "points", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<PVPStatsEntry>): PVPStatsEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.level = 0;
        message.race = 0;
        message.charClass = 0;
        message.zone = 0;
        message.time = 0;
        message.points = 0;
        if (value !== undefined)
            reflectionMergePartial<PVPStatsEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PVPStatsEntry): PVPStatsEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* int32 level */ 2:
                    message.level = reader.int32();
                    break;
                case /* int32 race */ 3:
                    message.race = reader.int32();
                    break;
                case /* int32 char_class */ 4:
                    message.charClass = reader.int32();
                    break;
                case /* int32 zone */ 5:
                    message.zone = reader.int32();
                    break;
                case /* int32 time */ 6:
                    message.time = reader.int32();
                    break;
                case /* int32 points */ 7:
                    message.points = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PVPStatsEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* int32 level = 2; */
        if (message.level !== 0)
            writer.tag(2, WireType.Varint).int32(message.level);
        /* int32 race = 3; */
        if (message.race !== 0)
            writer.tag(3, WireType.Varint).int32(message.race);
        /* int32 char_class = 4; */
        if (message.charClass !== 0)
            writer.tag(4, WireType.Varint).int32(message.charClass);
        /* int32 zone = 5; */
        if (message.zone !== 0)
            writer.tag(5, WireType.Varint).int32(message.zone);
        /* int32 time = 6; */
        if (message.time !== 0)
            writer.tag(6, WireType.Varint).int32(message.time);
        /* int32 points = 7; */
        if (message.points !== 0)
            writer.tag(7, WireType.Varint).int32(message.points);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.PVPStatsEntry
 */
export const PVPStatsEntry = new PVPStatsEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerProfile$Type extends MessageType<PlayerProfile> {
    constructor() {
        super("eq.PlayerProfile", [
            { no: 1, name: "checksum", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "gender", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "race", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "char_class", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "level", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "level1", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "binds", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Bind },
            { no: 8, name: "deity", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "intoxication", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "spell_slot_refresh", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "ability_slot_refresh", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "haircolor", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "beardcolor", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "eyecolor1", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "eyecolor2", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 16, name: "hairstyle", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 17, name: "beard", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 18, name: "item_material", kind: "message", T: () => TextureProfile },
            { no: 19, name: "item_tint", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 20, name: "aa_array", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AA_Array },
            { no: 21, name: "points", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 22, name: "mana", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 23, name: "cur_hp", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 24, name: "str", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 25, name: "sta", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 26, name: "cha", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 27, name: "dex", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 28, name: "intel", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 29, name: "agi", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 30, name: "wis", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 31, name: "face", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 32, name: "spell_book", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 33, name: "mem_spells", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 34, name: "platinum", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 35, name: "gold", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 36, name: "silver", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 37, name: "copper", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 38, name: "platinum_cursor", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 39, name: "gold_cursor", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 40, name: "silver_cursor", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 41, name: "copper_cursor", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 42, name: "skills", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 43, name: "innate_skills", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 44, name: "toxicity", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 45, name: "thirst_level", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 46, name: "hunger_level", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 47, name: "buffs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SpellBuff },
            { no: 48, name: "disciplines", kind: "message", T: () => Disciplines },
            { no: 49, name: "recast_timers", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 50, name: "endurance", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 51, name: "aapoints_spent", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 52, name: "aapoints", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 53, name: "bandoliers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Bandolier },
            { no: 54, name: "potionbelt", kind: "message", T: () => PotionBelt },
            { no: 55, name: "available_slots", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 56, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 57, name: "last_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 58, name: "guild_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 59, name: "birthday", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 60, name: "lastlogin", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 61, name: "time_played_min", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 62, name: "pvp", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 63, name: "anon", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 64, name: "gm", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 65, name: "guildrank", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 66, name: "guildbanker", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 67, name: "exp", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 68, name: "timeentitledonaccount", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 69, name: "languages", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 70, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 71, name: "y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 72, name: "z", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 73, name: "heading", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 74, name: "platinum_bank", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 75, name: "gold_bank", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 76, name: "silver_bank", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 77, name: "copper_bank", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 78, name: "platinum_shared", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 79, name: "expansions", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 80, name: "autosplit", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 81, name: "zone_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 82, name: "zone_instance", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 83, name: "group_members", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => StringList },
            { no: 84, name: "group_leader", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 85, name: "entityid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 86, name: "lead_aa_active", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 87, name: "ldon_points_guk", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 88, name: "ldon_points_mir", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 89, name: "ldon_points_mmc", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 90, name: "ldon_points_ruj", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 91, name: "ldon_points_tak", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 92, name: "ldon_points_available", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 93, name: "tribute_time_remaining", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 94, name: "career_tribute_points", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 95, name: "tribute_points", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 96, name: "tribute_active", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 97, name: "tributes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Tribute },
            { no: 98, name: "group_leadership_exp", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 99, name: "raid_leadership_exp", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 100, name: "group_leadership_points", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 101, name: "raid_leadership_points", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 102, name: "leader_abilities", kind: "message", T: () => LeadershipAA },
            { no: 103, name: "air_remaining", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 104, name: "pvp_kills", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 105, name: "pvp_deaths", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 106, name: "pvp_current_points", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 107, name: "pvp_career_points", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 108, name: "pvp_best_kill_streak", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 109, name: "pvp_worst_death_streak", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 110, name: "pvp_current_kill_streak", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 111, name: "pvp_last_kill", kind: "message", T: () => PVPStatsEntry },
            { no: 112, name: "pvp_last_death", kind: "message", T: () => PVPStatsEntry },
            { no: 113, name: "pvp_number_of_kills_in_last__hours", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 114, name: "pvp_recent_kills", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PVPStatsEntry },
            { no: 115, name: "exp_aa", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 116, name: "current_rad_crystals", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 117, name: "career_rad_crystals", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 118, name: "current_ebon_crystals", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 119, name: "career_ebon_crystals", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 120, name: "group_autoconsent", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 121, name: "raid_autoconsent", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 122, name: "guild_autoconsent", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 123, name: "level3", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 124, name: "showhelm", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<PlayerProfile>): PlayerProfile {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.checksum = 0;
        message.gender = 0;
        message.race = 0;
        message.charClass = 0;
        message.level = 0;
        message.level1 = 0;
        message.binds = [];
        message.deity = 0;
        message.intoxication = 0;
        message.spellSlotRefresh = [];
        message.abilitySlotRefresh = 0;
        message.haircolor = 0;
        message.beardcolor = 0;
        message.eyecolor1 = 0;
        message.eyecolor2 = 0;
        message.hairstyle = 0;
        message.beard = 0;
        message.itemTint = 0;
        message.aaArray = [];
        message.points = 0;
        message.mana = 0;
        message.curHp = 0;
        message.str = 0;
        message.sta = 0;
        message.cha = 0;
        message.dex = 0;
        message.intel = 0;
        message.agi = 0;
        message.wis = 0;
        message.face = 0;
        message.spellBook = [];
        message.memSpells = [];
        message.platinum = 0;
        message.gold = 0;
        message.silver = 0;
        message.copper = 0;
        message.platinumCursor = 0;
        message.goldCursor = 0;
        message.silverCursor = 0;
        message.copperCursor = 0;
        message.skills = [];
        message.innateSkills = [];
        message.toxicity = 0;
        message.thirstLevel = 0;
        message.hungerLevel = 0;
        message.buffs = [];
        message.recastTimers = [];
        message.endurance = 0;
        message.aapointsSpent = 0;
        message.aapoints = 0;
        message.bandoliers = [];
        message.availableSlots = 0;
        message.name = "";
        message.lastName = "";
        message.guildId = 0;
        message.birthday = 0;
        message.lastlogin = 0;
        message.timePlayedMin = 0;
        message.pvp = 0;
        message.anon = 0;
        message.gm = 0;
        message.guildrank = 0;
        message.guildbanker = 0;
        message.exp = 0;
        message.timeentitledonaccount = 0;
        message.languages = [];
        message.x = 0;
        message.y = 0;
        message.z = 0;
        message.heading = 0;
        message.platinumBank = 0;
        message.goldBank = 0;
        message.silverBank = 0;
        message.copperBank = 0;
        message.platinumShared = 0;
        message.expansions = 0;
        message.autosplit = 0;
        message.zoneId = 0;
        message.zoneInstance = 0;
        message.groupMembers = [];
        message.groupLeader = "";
        message.entityid = 0;
        message.leadAaActive = 0;
        message.ldonPointsGuk = 0;
        message.ldonPointsMir = 0;
        message.ldonPointsMmc = 0;
        message.ldonPointsRuj = 0;
        message.ldonPointsTak = 0;
        message.ldonPointsAvailable = 0;
        message.tributeTimeRemaining = 0;
        message.careerTributePoints = 0;
        message.tributePoints = 0;
        message.tributeActive = 0;
        message.tributes = [];
        message.groupLeadershipExp = 0;
        message.raidLeadershipExp = 0;
        message.groupLeadershipPoints = 0;
        message.raidLeadershipPoints = 0;
        message.airRemaining = 0;
        message.pvpKills = 0;
        message.pvpDeaths = 0;
        message.pvpCurrentPoints = 0;
        message.pvpCareerPoints = 0;
        message.pvpBestKillStreak = 0;
        message.pvpWorstDeathStreak = 0;
        message.pvpCurrentKillStreak = 0;
        message.pvpNumberOfKillsInLastHours = 0;
        message.pvpRecentKills = [];
        message.expAa = 0;
        message.currentRadCrystals = 0;
        message.careerRadCrystals = 0;
        message.currentEbonCrystals = 0;
        message.careerEbonCrystals = 0;
        message.groupAutoconsent = 0;
        message.raidAutoconsent = 0;
        message.guildAutoconsent = 0;
        message.level3 = 0;
        message.showhelm = 0;
        if (value !== undefined)
            reflectionMergePartial<PlayerProfile>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerProfile): PlayerProfile {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 checksum */ 1:
                    message.checksum = reader.int32();
                    break;
                case /* int32 gender */ 2:
                    message.gender = reader.int32();
                    break;
                case /* int32 race */ 3:
                    message.race = reader.int32();
                    break;
                case /* int32 char_class */ 4:
                    message.charClass = reader.int32();
                    break;
                case /* int32 level */ 5:
                    message.level = reader.int32();
                    break;
                case /* int32 level1 */ 6:
                    message.level1 = reader.int32();
                    break;
                case /* repeated eq.Bind binds */ 7:
                    message.binds.push(Bind.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 deity */ 8:
                    message.deity = reader.int32();
                    break;
                case /* int32 intoxication */ 9:
                    message.intoxication = reader.int32();
                    break;
                case /* repeated int32 spell_slot_refresh */ 10:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.spellSlotRefresh.push(reader.int32());
                    else
                        message.spellSlotRefresh.push(reader.int32());
                    break;
                case /* int32 ability_slot_refresh */ 11:
                    message.abilitySlotRefresh = reader.int32();
                    break;
                case /* int32 haircolor */ 12:
                    message.haircolor = reader.int32();
                    break;
                case /* int32 beardcolor */ 13:
                    message.beardcolor = reader.int32();
                    break;
                case /* int32 eyecolor1 */ 14:
                    message.eyecolor1 = reader.int32();
                    break;
                case /* int32 eyecolor2 */ 15:
                    message.eyecolor2 = reader.int32();
                    break;
                case /* int32 hairstyle */ 16:
                    message.hairstyle = reader.int32();
                    break;
                case /* int32 beard */ 17:
                    message.beard = reader.int32();
                    break;
                case /* eq.TextureProfile item_material */ 18:
                    message.itemMaterial = TextureProfile.internalBinaryRead(reader, reader.uint32(), options, message.itemMaterial);
                    break;
                case /* int32 item_tint */ 19:
                    message.itemTint = reader.int32();
                    break;
                case /* repeated eq.AA_Array aa_array */ 20:
                    message.aaArray.push(AA_Array.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 points */ 21:
                    message.points = reader.int32();
                    break;
                case /* int32 mana */ 22:
                    message.mana = reader.int32();
                    break;
                case /* int32 cur_hp */ 23:
                    message.curHp = reader.int32();
                    break;
                case /* int32 str */ 24:
                    message.str = reader.int32();
                    break;
                case /* int32 sta */ 25:
                    message.sta = reader.int32();
                    break;
                case /* int32 cha */ 26:
                    message.cha = reader.int32();
                    break;
                case /* int32 dex */ 27:
                    message.dex = reader.int32();
                    break;
                case /* int32 intel */ 28:
                    message.intel = reader.int32();
                    break;
                case /* int32 agi */ 29:
                    message.agi = reader.int32();
                    break;
                case /* int32 wis */ 30:
                    message.wis = reader.int32();
                    break;
                case /* int32 face */ 31:
                    message.face = reader.int32();
                    break;
                case /* repeated int32 spell_book */ 32:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.spellBook.push(reader.int32());
                    else
                        message.spellBook.push(reader.int32());
                    break;
                case /* repeated int32 mem_spells */ 33:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.memSpells.push(reader.int32());
                    else
                        message.memSpells.push(reader.int32());
                    break;
                case /* int32 platinum */ 34:
                    message.platinum = reader.int32();
                    break;
                case /* int32 gold */ 35:
                    message.gold = reader.int32();
                    break;
                case /* int32 silver */ 36:
                    message.silver = reader.int32();
                    break;
                case /* int32 copper */ 37:
                    message.copper = reader.int32();
                    break;
                case /* int32 platinum_cursor */ 38:
                    message.platinumCursor = reader.int32();
                    break;
                case /* int32 gold_cursor */ 39:
                    message.goldCursor = reader.int32();
                    break;
                case /* int32 silver_cursor */ 40:
                    message.silverCursor = reader.int32();
                    break;
                case /* int32 copper_cursor */ 41:
                    message.copperCursor = reader.int32();
                    break;
                case /* repeated int32 skills */ 42:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.skills.push(reader.int32());
                    else
                        message.skills.push(reader.int32());
                    break;
                case /* repeated int32 innate_skills */ 43:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.innateSkills.push(reader.int32());
                    else
                        message.innateSkills.push(reader.int32());
                    break;
                case /* int32 toxicity */ 44:
                    message.toxicity = reader.int32();
                    break;
                case /* int32 thirst_level */ 45:
                    message.thirstLevel = reader.int32();
                    break;
                case /* int32 hunger_level */ 46:
                    message.hungerLevel = reader.int32();
                    break;
                case /* repeated eq.SpellBuff buffs */ 47:
                    message.buffs.push(SpellBuff.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* eq.Disciplines disciplines */ 48:
                    message.disciplines = Disciplines.internalBinaryRead(reader, reader.uint32(), options, message.disciplines);
                    break;
                case /* repeated int32 recast_timers */ 49:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.recastTimers.push(reader.int32());
                    else
                        message.recastTimers.push(reader.int32());
                    break;
                case /* int32 endurance */ 50:
                    message.endurance = reader.int32();
                    break;
                case /* int32 aapoints_spent */ 51:
                    message.aapointsSpent = reader.int32();
                    break;
                case /* int32 aapoints */ 52:
                    message.aapoints = reader.int32();
                    break;
                case /* repeated eq.Bandolier bandoliers */ 53:
                    message.bandoliers.push(Bandolier.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* eq.PotionBelt potionbelt */ 54:
                    message.potionbelt = PotionBelt.internalBinaryRead(reader, reader.uint32(), options, message.potionbelt);
                    break;
                case /* int32 available_slots */ 55:
                    message.availableSlots = reader.int32();
                    break;
                case /* string name */ 56:
                    message.name = reader.string();
                    break;
                case /* string last_name */ 57:
                    message.lastName = reader.string();
                    break;
                case /* int32 guild_id */ 58:
                    message.guildId = reader.int32();
                    break;
                case /* int32 birthday */ 59:
                    message.birthday = reader.int32();
                    break;
                case /* int32 lastlogin */ 60:
                    message.lastlogin = reader.int32();
                    break;
                case /* int32 time_played_min */ 61:
                    message.timePlayedMin = reader.int32();
                    break;
                case /* int32 pvp */ 62:
                    message.pvp = reader.int32();
                    break;
                case /* int32 anon */ 63:
                    message.anon = reader.int32();
                    break;
                case /* int32 gm */ 64:
                    message.gm = reader.int32();
                    break;
                case /* int32 guildrank */ 65:
                    message.guildrank = reader.int32();
                    break;
                case /* int32 guildbanker */ 66:
                    message.guildbanker = reader.int32();
                    break;
                case /* int32 exp */ 67:
                    message.exp = reader.int32();
                    break;
                case /* int32 timeentitledonaccount */ 68:
                    message.timeentitledonaccount = reader.int32();
                    break;
                case /* repeated int32 languages */ 69:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.languages.push(reader.int32());
                    else
                        message.languages.push(reader.int32());
                    break;
                case /* float x */ 70:
                    message.x = reader.float();
                    break;
                case /* float y */ 71:
                    message.y = reader.float();
                    break;
                case /* float z */ 72:
                    message.z = reader.float();
                    break;
                case /* float heading */ 73:
                    message.heading = reader.float();
                    break;
                case /* int32 platinum_bank */ 74:
                    message.platinumBank = reader.int32();
                    break;
                case /* int32 gold_bank */ 75:
                    message.goldBank = reader.int32();
                    break;
                case /* int32 silver_bank */ 76:
                    message.silverBank = reader.int32();
                    break;
                case /* int32 copper_bank */ 77:
                    message.copperBank = reader.int32();
                    break;
                case /* int32 platinum_shared */ 78:
                    message.platinumShared = reader.int32();
                    break;
                case /* int32 expansions */ 79:
                    message.expansions = reader.int32();
                    break;
                case /* int32 autosplit */ 80:
                    message.autosplit = reader.int32();
                    break;
                case /* int32 zone_id */ 81:
                    message.zoneId = reader.int32();
                    break;
                case /* int32 zone_instance */ 82:
                    message.zoneInstance = reader.int32();
                    break;
                case /* repeated eq.StringList group_members */ 83:
                    message.groupMembers.push(StringList.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string group_leader */ 84:
                    message.groupLeader = reader.string();
                    break;
                case /* int32 entityid */ 85:
                    message.entityid = reader.int32();
                    break;
                case /* int32 lead_aa_active */ 86:
                    message.leadAaActive = reader.int32();
                    break;
                case /* int32 ldon_points_guk */ 87:
                    message.ldonPointsGuk = reader.int32();
                    break;
                case /* int32 ldon_points_mir */ 88:
                    message.ldonPointsMir = reader.int32();
                    break;
                case /* int32 ldon_points_mmc */ 89:
                    message.ldonPointsMmc = reader.int32();
                    break;
                case /* int32 ldon_points_ruj */ 90:
                    message.ldonPointsRuj = reader.int32();
                    break;
                case /* int32 ldon_points_tak */ 91:
                    message.ldonPointsTak = reader.int32();
                    break;
                case /* int32 ldon_points_available */ 92:
                    message.ldonPointsAvailable = reader.int32();
                    break;
                case /* int32 tribute_time_remaining */ 93:
                    message.tributeTimeRemaining = reader.int32();
                    break;
                case /* int32 career_tribute_points */ 94:
                    message.careerTributePoints = reader.int32();
                    break;
                case /* int32 tribute_points */ 95:
                    message.tributePoints = reader.int32();
                    break;
                case /* int32 tribute_active */ 96:
                    message.tributeActive = reader.int32();
                    break;
                case /* repeated eq.Tribute tributes */ 97:
                    message.tributes.push(Tribute.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* double group_leadership_exp */ 98:
                    message.groupLeadershipExp = reader.double();
                    break;
                case /* double raid_leadership_exp */ 99:
                    message.raidLeadershipExp = reader.double();
                    break;
                case /* int32 group_leadership_points */ 100:
                    message.groupLeadershipPoints = reader.int32();
                    break;
                case /* int32 raid_leadership_points */ 101:
                    message.raidLeadershipPoints = reader.int32();
                    break;
                case /* eq.LeadershipAA leader_abilities */ 102:
                    message.leaderAbilities = LeadershipAA.internalBinaryRead(reader, reader.uint32(), options, message.leaderAbilities);
                    break;
                case /* int32 air_remaining */ 103:
                    message.airRemaining = reader.int32();
                    break;
                case /* int32 pvp_kills */ 104:
                    message.pvpKills = reader.int32();
                    break;
                case /* int32 pvp_deaths */ 105:
                    message.pvpDeaths = reader.int32();
                    break;
                case /* int32 pvp_current_points */ 106:
                    message.pvpCurrentPoints = reader.int32();
                    break;
                case /* int32 pvp_career_points */ 107:
                    message.pvpCareerPoints = reader.int32();
                    break;
                case /* int32 pvp_best_kill_streak */ 108:
                    message.pvpBestKillStreak = reader.int32();
                    break;
                case /* int32 pvp_worst_death_streak */ 109:
                    message.pvpWorstDeathStreak = reader.int32();
                    break;
                case /* int32 pvp_current_kill_streak */ 110:
                    message.pvpCurrentKillStreak = reader.int32();
                    break;
                case /* eq.PVPStatsEntry pvp_last_kill */ 111:
                    message.pvpLastKill = PVPStatsEntry.internalBinaryRead(reader, reader.uint32(), options, message.pvpLastKill);
                    break;
                case /* eq.PVPStatsEntry pvp_last_death */ 112:
                    message.pvpLastDeath = PVPStatsEntry.internalBinaryRead(reader, reader.uint32(), options, message.pvpLastDeath);
                    break;
                case /* int32 pvp_number_of_kills_in_last__hours */ 113:
                    message.pvpNumberOfKillsInLastHours = reader.int32();
                    break;
                case /* repeated eq.PVPStatsEntry pvp_recent_kills */ 114:
                    message.pvpRecentKills.push(PVPStatsEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 exp_aa */ 115:
                    message.expAa = reader.int32();
                    break;
                case /* int32 current_rad_crystals */ 116:
                    message.currentRadCrystals = reader.int32();
                    break;
                case /* int32 career_rad_crystals */ 117:
                    message.careerRadCrystals = reader.int32();
                    break;
                case /* int32 current_ebon_crystals */ 118:
                    message.currentEbonCrystals = reader.int32();
                    break;
                case /* int32 career_ebon_crystals */ 119:
                    message.careerEbonCrystals = reader.int32();
                    break;
                case /* int32 group_autoconsent */ 120:
                    message.groupAutoconsent = reader.int32();
                    break;
                case /* int32 raid_autoconsent */ 121:
                    message.raidAutoconsent = reader.int32();
                    break;
                case /* int32 guild_autoconsent */ 122:
                    message.guildAutoconsent = reader.int32();
                    break;
                case /* int32 level3 */ 123:
                    message.level3 = reader.int32();
                    break;
                case /* int32 showhelm */ 124:
                    message.showhelm = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerProfile, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 checksum = 1; */
        if (message.checksum !== 0)
            writer.tag(1, WireType.Varint).int32(message.checksum);
        /* int32 gender = 2; */
        if (message.gender !== 0)
            writer.tag(2, WireType.Varint).int32(message.gender);
        /* int32 race = 3; */
        if (message.race !== 0)
            writer.tag(3, WireType.Varint).int32(message.race);
        /* int32 char_class = 4; */
        if (message.charClass !== 0)
            writer.tag(4, WireType.Varint).int32(message.charClass);
        /* int32 level = 5; */
        if (message.level !== 0)
            writer.tag(5, WireType.Varint).int32(message.level);
        /* int32 level1 = 6; */
        if (message.level1 !== 0)
            writer.tag(6, WireType.Varint).int32(message.level1);
        /* repeated eq.Bind binds = 7; */
        for (let i = 0; i < message.binds.length; i++)
            Bind.internalBinaryWrite(message.binds[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* int32 deity = 8; */
        if (message.deity !== 0)
            writer.tag(8, WireType.Varint).int32(message.deity);
        /* int32 intoxication = 9; */
        if (message.intoxication !== 0)
            writer.tag(9, WireType.Varint).int32(message.intoxication);
        /* repeated int32 spell_slot_refresh = 10; */
        if (message.spellSlotRefresh.length) {
            writer.tag(10, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.spellSlotRefresh.length; i++)
                writer.int32(message.spellSlotRefresh[i]);
            writer.join();
        }
        /* int32 ability_slot_refresh = 11; */
        if (message.abilitySlotRefresh !== 0)
            writer.tag(11, WireType.Varint).int32(message.abilitySlotRefresh);
        /* int32 haircolor = 12; */
        if (message.haircolor !== 0)
            writer.tag(12, WireType.Varint).int32(message.haircolor);
        /* int32 beardcolor = 13; */
        if (message.beardcolor !== 0)
            writer.tag(13, WireType.Varint).int32(message.beardcolor);
        /* int32 eyecolor1 = 14; */
        if (message.eyecolor1 !== 0)
            writer.tag(14, WireType.Varint).int32(message.eyecolor1);
        /* int32 eyecolor2 = 15; */
        if (message.eyecolor2 !== 0)
            writer.tag(15, WireType.Varint).int32(message.eyecolor2);
        /* int32 hairstyle = 16; */
        if (message.hairstyle !== 0)
            writer.tag(16, WireType.Varint).int32(message.hairstyle);
        /* int32 beard = 17; */
        if (message.beard !== 0)
            writer.tag(17, WireType.Varint).int32(message.beard);
        /* eq.TextureProfile item_material = 18; */
        if (message.itemMaterial)
            TextureProfile.internalBinaryWrite(message.itemMaterial, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* int32 item_tint = 19; */
        if (message.itemTint !== 0)
            writer.tag(19, WireType.Varint).int32(message.itemTint);
        /* repeated eq.AA_Array aa_array = 20; */
        for (let i = 0; i < message.aaArray.length; i++)
            AA_Array.internalBinaryWrite(message.aaArray[i], writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* int32 points = 21; */
        if (message.points !== 0)
            writer.tag(21, WireType.Varint).int32(message.points);
        /* int32 mana = 22; */
        if (message.mana !== 0)
            writer.tag(22, WireType.Varint).int32(message.mana);
        /* int32 cur_hp = 23; */
        if (message.curHp !== 0)
            writer.tag(23, WireType.Varint).int32(message.curHp);
        /* int32 str = 24; */
        if (message.str !== 0)
            writer.tag(24, WireType.Varint).int32(message.str);
        /* int32 sta = 25; */
        if (message.sta !== 0)
            writer.tag(25, WireType.Varint).int32(message.sta);
        /* int32 cha = 26; */
        if (message.cha !== 0)
            writer.tag(26, WireType.Varint).int32(message.cha);
        /* int32 dex = 27; */
        if (message.dex !== 0)
            writer.tag(27, WireType.Varint).int32(message.dex);
        /* int32 intel = 28; */
        if (message.intel !== 0)
            writer.tag(28, WireType.Varint).int32(message.intel);
        /* int32 agi = 29; */
        if (message.agi !== 0)
            writer.tag(29, WireType.Varint).int32(message.agi);
        /* int32 wis = 30; */
        if (message.wis !== 0)
            writer.tag(30, WireType.Varint).int32(message.wis);
        /* int32 face = 31; */
        if (message.face !== 0)
            writer.tag(31, WireType.Varint).int32(message.face);
        /* repeated int32 spell_book = 32; */
        if (message.spellBook.length) {
            writer.tag(32, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.spellBook.length; i++)
                writer.int32(message.spellBook[i]);
            writer.join();
        }
        /* repeated int32 mem_spells = 33; */
        if (message.memSpells.length) {
            writer.tag(33, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.memSpells.length; i++)
                writer.int32(message.memSpells[i]);
            writer.join();
        }
        /* int32 platinum = 34; */
        if (message.platinum !== 0)
            writer.tag(34, WireType.Varint).int32(message.platinum);
        /* int32 gold = 35; */
        if (message.gold !== 0)
            writer.tag(35, WireType.Varint).int32(message.gold);
        /* int32 silver = 36; */
        if (message.silver !== 0)
            writer.tag(36, WireType.Varint).int32(message.silver);
        /* int32 copper = 37; */
        if (message.copper !== 0)
            writer.tag(37, WireType.Varint).int32(message.copper);
        /* int32 platinum_cursor = 38; */
        if (message.platinumCursor !== 0)
            writer.tag(38, WireType.Varint).int32(message.platinumCursor);
        /* int32 gold_cursor = 39; */
        if (message.goldCursor !== 0)
            writer.tag(39, WireType.Varint).int32(message.goldCursor);
        /* int32 silver_cursor = 40; */
        if (message.silverCursor !== 0)
            writer.tag(40, WireType.Varint).int32(message.silverCursor);
        /* int32 copper_cursor = 41; */
        if (message.copperCursor !== 0)
            writer.tag(41, WireType.Varint).int32(message.copperCursor);
        /* repeated int32 skills = 42; */
        if (message.skills.length) {
            writer.tag(42, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.skills.length; i++)
                writer.int32(message.skills[i]);
            writer.join();
        }
        /* repeated int32 innate_skills = 43; */
        if (message.innateSkills.length) {
            writer.tag(43, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.innateSkills.length; i++)
                writer.int32(message.innateSkills[i]);
            writer.join();
        }
        /* int32 toxicity = 44; */
        if (message.toxicity !== 0)
            writer.tag(44, WireType.Varint).int32(message.toxicity);
        /* int32 thirst_level = 45; */
        if (message.thirstLevel !== 0)
            writer.tag(45, WireType.Varint).int32(message.thirstLevel);
        /* int32 hunger_level = 46; */
        if (message.hungerLevel !== 0)
            writer.tag(46, WireType.Varint).int32(message.hungerLevel);
        /* repeated eq.SpellBuff buffs = 47; */
        for (let i = 0; i < message.buffs.length; i++)
            SpellBuff.internalBinaryWrite(message.buffs[i], writer.tag(47, WireType.LengthDelimited).fork(), options).join();
        /* eq.Disciplines disciplines = 48; */
        if (message.disciplines)
            Disciplines.internalBinaryWrite(message.disciplines, writer.tag(48, WireType.LengthDelimited).fork(), options).join();
        /* repeated int32 recast_timers = 49; */
        if (message.recastTimers.length) {
            writer.tag(49, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.recastTimers.length; i++)
                writer.int32(message.recastTimers[i]);
            writer.join();
        }
        /* int32 endurance = 50; */
        if (message.endurance !== 0)
            writer.tag(50, WireType.Varint).int32(message.endurance);
        /* int32 aapoints_spent = 51; */
        if (message.aapointsSpent !== 0)
            writer.tag(51, WireType.Varint).int32(message.aapointsSpent);
        /* int32 aapoints = 52; */
        if (message.aapoints !== 0)
            writer.tag(52, WireType.Varint).int32(message.aapoints);
        /* repeated eq.Bandolier bandoliers = 53; */
        for (let i = 0; i < message.bandoliers.length; i++)
            Bandolier.internalBinaryWrite(message.bandoliers[i], writer.tag(53, WireType.LengthDelimited).fork(), options).join();
        /* eq.PotionBelt potionbelt = 54; */
        if (message.potionbelt)
            PotionBelt.internalBinaryWrite(message.potionbelt, writer.tag(54, WireType.LengthDelimited).fork(), options).join();
        /* int32 available_slots = 55; */
        if (message.availableSlots !== 0)
            writer.tag(55, WireType.Varint).int32(message.availableSlots);
        /* string name = 56; */
        if (message.name !== "")
            writer.tag(56, WireType.LengthDelimited).string(message.name);
        /* string last_name = 57; */
        if (message.lastName !== "")
            writer.tag(57, WireType.LengthDelimited).string(message.lastName);
        /* int32 guild_id = 58; */
        if (message.guildId !== 0)
            writer.tag(58, WireType.Varint).int32(message.guildId);
        /* int32 birthday = 59; */
        if (message.birthday !== 0)
            writer.tag(59, WireType.Varint).int32(message.birthday);
        /* int32 lastlogin = 60; */
        if (message.lastlogin !== 0)
            writer.tag(60, WireType.Varint).int32(message.lastlogin);
        /* int32 time_played_min = 61; */
        if (message.timePlayedMin !== 0)
            writer.tag(61, WireType.Varint).int32(message.timePlayedMin);
        /* int32 pvp = 62; */
        if (message.pvp !== 0)
            writer.tag(62, WireType.Varint).int32(message.pvp);
        /* int32 anon = 63; */
        if (message.anon !== 0)
            writer.tag(63, WireType.Varint).int32(message.anon);
        /* int32 gm = 64; */
        if (message.gm !== 0)
            writer.tag(64, WireType.Varint).int32(message.gm);
        /* int32 guildrank = 65; */
        if (message.guildrank !== 0)
            writer.tag(65, WireType.Varint).int32(message.guildrank);
        /* int32 guildbanker = 66; */
        if (message.guildbanker !== 0)
            writer.tag(66, WireType.Varint).int32(message.guildbanker);
        /* int32 exp = 67; */
        if (message.exp !== 0)
            writer.tag(67, WireType.Varint).int32(message.exp);
        /* int32 timeentitledonaccount = 68; */
        if (message.timeentitledonaccount !== 0)
            writer.tag(68, WireType.Varint).int32(message.timeentitledonaccount);
        /* repeated int32 languages = 69; */
        if (message.languages.length) {
            writer.tag(69, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.languages.length; i++)
                writer.int32(message.languages[i]);
            writer.join();
        }
        /* float x = 70; */
        if (message.x !== 0)
            writer.tag(70, WireType.Bit32).float(message.x);
        /* float y = 71; */
        if (message.y !== 0)
            writer.tag(71, WireType.Bit32).float(message.y);
        /* float z = 72; */
        if (message.z !== 0)
            writer.tag(72, WireType.Bit32).float(message.z);
        /* float heading = 73; */
        if (message.heading !== 0)
            writer.tag(73, WireType.Bit32).float(message.heading);
        /* int32 platinum_bank = 74; */
        if (message.platinumBank !== 0)
            writer.tag(74, WireType.Varint).int32(message.platinumBank);
        /* int32 gold_bank = 75; */
        if (message.goldBank !== 0)
            writer.tag(75, WireType.Varint).int32(message.goldBank);
        /* int32 silver_bank = 76; */
        if (message.silverBank !== 0)
            writer.tag(76, WireType.Varint).int32(message.silverBank);
        /* int32 copper_bank = 77; */
        if (message.copperBank !== 0)
            writer.tag(77, WireType.Varint).int32(message.copperBank);
        /* int32 platinum_shared = 78; */
        if (message.platinumShared !== 0)
            writer.tag(78, WireType.Varint).int32(message.platinumShared);
        /* int32 expansions = 79; */
        if (message.expansions !== 0)
            writer.tag(79, WireType.Varint).int32(message.expansions);
        /* int32 autosplit = 80; */
        if (message.autosplit !== 0)
            writer.tag(80, WireType.Varint).int32(message.autosplit);
        /* int32 zone_id = 81; */
        if (message.zoneId !== 0)
            writer.tag(81, WireType.Varint).int32(message.zoneId);
        /* int32 zone_instance = 82; */
        if (message.zoneInstance !== 0)
            writer.tag(82, WireType.Varint).int32(message.zoneInstance);
        /* repeated eq.StringList group_members = 83; */
        for (let i = 0; i < message.groupMembers.length; i++)
            StringList.internalBinaryWrite(message.groupMembers[i], writer.tag(83, WireType.LengthDelimited).fork(), options).join();
        /* string group_leader = 84; */
        if (message.groupLeader !== "")
            writer.tag(84, WireType.LengthDelimited).string(message.groupLeader);
        /* int32 entityid = 85; */
        if (message.entityid !== 0)
            writer.tag(85, WireType.Varint).int32(message.entityid);
        /* int32 lead_aa_active = 86; */
        if (message.leadAaActive !== 0)
            writer.tag(86, WireType.Varint).int32(message.leadAaActive);
        /* int32 ldon_points_guk = 87; */
        if (message.ldonPointsGuk !== 0)
            writer.tag(87, WireType.Varint).int32(message.ldonPointsGuk);
        /* int32 ldon_points_mir = 88; */
        if (message.ldonPointsMir !== 0)
            writer.tag(88, WireType.Varint).int32(message.ldonPointsMir);
        /* int32 ldon_points_mmc = 89; */
        if (message.ldonPointsMmc !== 0)
            writer.tag(89, WireType.Varint).int32(message.ldonPointsMmc);
        /* int32 ldon_points_ruj = 90; */
        if (message.ldonPointsRuj !== 0)
            writer.tag(90, WireType.Varint).int32(message.ldonPointsRuj);
        /* int32 ldon_points_tak = 91; */
        if (message.ldonPointsTak !== 0)
            writer.tag(91, WireType.Varint).int32(message.ldonPointsTak);
        /* int32 ldon_points_available = 92; */
        if (message.ldonPointsAvailable !== 0)
            writer.tag(92, WireType.Varint).int32(message.ldonPointsAvailable);
        /* int32 tribute_time_remaining = 93; */
        if (message.tributeTimeRemaining !== 0)
            writer.tag(93, WireType.Varint).int32(message.tributeTimeRemaining);
        /* int32 career_tribute_points = 94; */
        if (message.careerTributePoints !== 0)
            writer.tag(94, WireType.Varint).int32(message.careerTributePoints);
        /* int32 tribute_points = 95; */
        if (message.tributePoints !== 0)
            writer.tag(95, WireType.Varint).int32(message.tributePoints);
        /* int32 tribute_active = 96; */
        if (message.tributeActive !== 0)
            writer.tag(96, WireType.Varint).int32(message.tributeActive);
        /* repeated eq.Tribute tributes = 97; */
        for (let i = 0; i < message.tributes.length; i++)
            Tribute.internalBinaryWrite(message.tributes[i], writer.tag(97, WireType.LengthDelimited).fork(), options).join();
        /* double group_leadership_exp = 98; */
        if (message.groupLeadershipExp !== 0)
            writer.tag(98, WireType.Bit64).double(message.groupLeadershipExp);
        /* double raid_leadership_exp = 99; */
        if (message.raidLeadershipExp !== 0)
            writer.tag(99, WireType.Bit64).double(message.raidLeadershipExp);
        /* int32 group_leadership_points = 100; */
        if (message.groupLeadershipPoints !== 0)
            writer.tag(100, WireType.Varint).int32(message.groupLeadershipPoints);
        /* int32 raid_leadership_points = 101; */
        if (message.raidLeadershipPoints !== 0)
            writer.tag(101, WireType.Varint).int32(message.raidLeadershipPoints);
        /* eq.LeadershipAA leader_abilities = 102; */
        if (message.leaderAbilities)
            LeadershipAA.internalBinaryWrite(message.leaderAbilities, writer.tag(102, WireType.LengthDelimited).fork(), options).join();
        /* int32 air_remaining = 103; */
        if (message.airRemaining !== 0)
            writer.tag(103, WireType.Varint).int32(message.airRemaining);
        /* int32 pvp_kills = 104; */
        if (message.pvpKills !== 0)
            writer.tag(104, WireType.Varint).int32(message.pvpKills);
        /* int32 pvp_deaths = 105; */
        if (message.pvpDeaths !== 0)
            writer.tag(105, WireType.Varint).int32(message.pvpDeaths);
        /* int32 pvp_current_points = 106; */
        if (message.pvpCurrentPoints !== 0)
            writer.tag(106, WireType.Varint).int32(message.pvpCurrentPoints);
        /* int32 pvp_career_points = 107; */
        if (message.pvpCareerPoints !== 0)
            writer.tag(107, WireType.Varint).int32(message.pvpCareerPoints);
        /* int32 pvp_best_kill_streak = 108; */
        if (message.pvpBestKillStreak !== 0)
            writer.tag(108, WireType.Varint).int32(message.pvpBestKillStreak);
        /* int32 pvp_worst_death_streak = 109; */
        if (message.pvpWorstDeathStreak !== 0)
            writer.tag(109, WireType.Varint).int32(message.pvpWorstDeathStreak);
        /* int32 pvp_current_kill_streak = 110; */
        if (message.pvpCurrentKillStreak !== 0)
            writer.tag(110, WireType.Varint).int32(message.pvpCurrentKillStreak);
        /* eq.PVPStatsEntry pvp_last_kill = 111; */
        if (message.pvpLastKill)
            PVPStatsEntry.internalBinaryWrite(message.pvpLastKill, writer.tag(111, WireType.LengthDelimited).fork(), options).join();
        /* eq.PVPStatsEntry pvp_last_death = 112; */
        if (message.pvpLastDeath)
            PVPStatsEntry.internalBinaryWrite(message.pvpLastDeath, writer.tag(112, WireType.LengthDelimited).fork(), options).join();
        /* int32 pvp_number_of_kills_in_last__hours = 113; */
        if (message.pvpNumberOfKillsInLastHours !== 0)
            writer.tag(113, WireType.Varint).int32(message.pvpNumberOfKillsInLastHours);
        /* repeated eq.PVPStatsEntry pvp_recent_kills = 114; */
        for (let i = 0; i < message.pvpRecentKills.length; i++)
            PVPStatsEntry.internalBinaryWrite(message.pvpRecentKills[i], writer.tag(114, WireType.LengthDelimited).fork(), options).join();
        /* int32 exp_aa = 115; */
        if (message.expAa !== 0)
            writer.tag(115, WireType.Varint).int32(message.expAa);
        /* int32 current_rad_crystals = 116; */
        if (message.currentRadCrystals !== 0)
            writer.tag(116, WireType.Varint).int32(message.currentRadCrystals);
        /* int32 career_rad_crystals = 117; */
        if (message.careerRadCrystals !== 0)
            writer.tag(117, WireType.Varint).int32(message.careerRadCrystals);
        /* int32 current_ebon_crystals = 118; */
        if (message.currentEbonCrystals !== 0)
            writer.tag(118, WireType.Varint).int32(message.currentEbonCrystals);
        /* int32 career_ebon_crystals = 119; */
        if (message.careerEbonCrystals !== 0)
            writer.tag(119, WireType.Varint).int32(message.careerEbonCrystals);
        /* int32 group_autoconsent = 120; */
        if (message.groupAutoconsent !== 0)
            writer.tag(120, WireType.Varint).int32(message.groupAutoconsent);
        /* int32 raid_autoconsent = 121; */
        if (message.raidAutoconsent !== 0)
            writer.tag(121, WireType.Varint).int32(message.raidAutoconsent);
        /* int32 guild_autoconsent = 122; */
        if (message.guildAutoconsent !== 0)
            writer.tag(122, WireType.Varint).int32(message.guildAutoconsent);
        /* int32 level3 = 123; */
        if (message.level3 !== 0)
            writer.tag(123, WireType.Varint).int32(message.level3);
        /* int32 showhelm = 124; */
        if (message.showhelm !== 0)
            writer.tag(124, WireType.Varint).int32(message.showhelm);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.PlayerProfile
 */
export const PlayerProfile = new PlayerProfile$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClientTarget$Type extends MessageType<ClientTarget> {
    constructor() {
        super("eq.ClientTarget", [
            { no: 1, name: "new_target", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ClientTarget>): ClientTarget {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.newTarget = 0;
        if (value !== undefined)
            reflectionMergePartial<ClientTarget>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClientTarget): ClientTarget {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 new_target */ 1:
                    message.newTarget = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClientTarget, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 new_target = 1; */
        if (message.newTarget !== 0)
            writer.tag(1, WireType.Varint).int32(message.newTarget);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.ClientTarget
 */
export const ClientTarget = new ClientTarget$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TargetReject$Type extends MessageType<TargetReject> {
    constructor() {
        super("eq.TargetReject", []);
    }
    create(value?: PartialMessage<TargetReject>): TargetReject {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TargetReject>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TargetReject): TargetReject {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TargetReject, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.TargetReject
 */
export const TargetReject = new TargetReject$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PetCommand$Type extends MessageType<PetCommand> {
    constructor() {
        super("eq.PetCommand", [
            { no: 1, name: "command", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "target", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<PetCommand>): PetCommand {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.command = 0;
        message.target = 0;
        if (value !== undefined)
            reflectionMergePartial<PetCommand>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PetCommand): PetCommand {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 command */ 1:
                    message.command = reader.int32();
                    break;
                case /* int32 target */ 2:
                    message.target = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PetCommand, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 command = 1; */
        if (message.command !== 0)
            writer.tag(1, WireType.Varint).int32(message.command);
        /* int32 target = 2; */
        if (message.target !== 0)
            writer.tag(2, WireType.Varint).int32(message.target);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.PetCommand
 */
export const PetCommand = new PetCommand$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteSpawn$Type extends MessageType<DeleteSpawn> {
    constructor() {
        super("eq.DeleteSpawn", [
            { no: 1, name: "spawn_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteSpawn>): DeleteSpawn {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.spawnId = 0;
        if (value !== undefined)
            reflectionMergePartial<DeleteSpawn>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteSpawn): DeleteSpawn {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 spawn_id */ 1:
                    message.spawnId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteSpawn, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 spawn_id = 1; */
        if (message.spawnId !== 0)
            writer.tag(1, WireType.Varint).int32(message.spawnId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.DeleteSpawn
 */
export const DeleteSpawn = new DeleteSpawn$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChannelMessage$Type extends MessageType<ChannelMessage> {
    constructor() {
        super("eq.ChannelMessage", [
            { no: 1, name: "targetname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "language", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "chan_num", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "skill_in_language", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ChannelMessage>): ChannelMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.targetname = "";
        message.sender = "";
        message.language = 0;
        message.chanNum = 0;
        message.skillInLanguage = 0;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<ChannelMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelMessage): ChannelMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string targetname */ 1:
                    message.targetname = reader.string();
                    break;
                case /* string sender */ 2:
                    message.sender = reader.string();
                    break;
                case /* int32 language */ 3:
                    message.language = reader.int32();
                    break;
                case /* int32 chan_num */ 4:
                    message.chanNum = reader.int32();
                    break;
                case /* int32 skill_in_language */ 5:
                    message.skillInLanguage = reader.int32();
                    break;
                case /* string message */ 6:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChannelMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string targetname = 1; */
        if (message.targetname !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.targetname);
        /* string sender = 2; */
        if (message.sender !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sender);
        /* int32 language = 3; */
        if (message.language !== 0)
            writer.tag(3, WireType.Varint).int32(message.language);
        /* int32 chan_num = 4; */
        if (message.chanNum !== 0)
            writer.tag(4, WireType.Varint).int32(message.chanNum);
        /* int32 skill_in_language = 5; */
        if (message.skillInLanguage !== 0)
            writer.tag(5, WireType.Varint).int32(message.skillInLanguage);
        /* string message = 6; */
        if (message.message !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.ChannelMessage
 */
export const ChannelMessage = new ChannelMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpecialMesg$Type extends MessageType<SpecialMesg> {
    constructor() {
        super("eq.SpecialMesg", [
            { no: 1, name: "header", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "msg_type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "target_spawn_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "sayer", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SpecialMesg>): SpecialMesg {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.header = "";
        message.msgType = 0;
        message.targetSpawnId = 0;
        message.sayer = "";
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<SpecialMesg>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpecialMesg): SpecialMesg {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string header */ 1:
                    message.header = reader.string();
                    break;
                case /* int32 msg_type */ 2:
                    message.msgType = reader.int32();
                    break;
                case /* int32 target_spawn_id */ 3:
                    message.targetSpawnId = reader.int32();
                    break;
                case /* string sayer */ 4:
                    message.sayer = reader.string();
                    break;
                case /* string message */ 5:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpecialMesg, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string header = 1; */
        if (message.header !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.header);
        /* int32 msg_type = 2; */
        if (message.msgType !== 0)
            writer.tag(2, WireType.Varint).int32(message.msgType);
        /* int32 target_spawn_id = 3; */
        if (message.targetSpawnId !== 0)
            writer.tag(3, WireType.Varint).int32(message.targetSpawnId);
        /* string sayer = 4; */
        if (message.sayer !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.sayer);
        /* string message = 5; */
        if (message.message !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.SpecialMesg
 */
export const SpecialMesg = new SpecialMesg$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WearChange$Type extends MessageType<WearChange> {
    constructor() {
        super("eq.WearChange", [
            { no: 1, name: "spawn_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "material", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "color", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "wear_slot_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<WearChange>): WearChange {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.spawnId = 0;
        message.material = 0;
        message.color = 0;
        message.wearSlotId = 0;
        if (value !== undefined)
            reflectionMergePartial<WearChange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WearChange): WearChange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 spawn_id */ 1:
                    message.spawnId = reader.int32();
                    break;
                case /* int32 material */ 2:
                    message.material = reader.int32();
                    break;
                case /* int32 color */ 3:
                    message.color = reader.int32();
                    break;
                case /* int32 wear_slot_id */ 4:
                    message.wearSlotId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WearChange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 spawn_id = 1; */
        if (message.spawnId !== 0)
            writer.tag(1, WireType.Varint).int32(message.spawnId);
        /* int32 material = 2; */
        if (message.material !== 0)
            writer.tag(2, WireType.Varint).int32(message.material);
        /* int32 color = 3; */
        if (message.color !== 0)
            writer.tag(3, WireType.Varint).int32(message.color);
        /* int32 wear_slot_id = 4; */
        if (message.wearSlotId !== 0)
            writer.tag(4, WireType.Varint).int32(message.wearSlotId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.WearChange
 */
export const WearChange = new WearChange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BindWound$Type extends MessageType<BindWound> {
    constructor() {
        super("eq.BindWound", [
            { no: 1, name: "to", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "type", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<BindWound>): BindWound {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.to = 0;
        message.type = 0;
        if (value !== undefined)
            reflectionMergePartial<BindWound>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BindWound): BindWound {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 to */ 1:
                    message.to = reader.int32();
                    break;
                case /* int32 type */ 2:
                    message.type = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BindWound, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 to = 1; */
        if (message.to !== 0)
            writer.tag(1, WireType.Varint).int32(message.to);
        /* int32 type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.BindWound
 */
export const BindWound = new BindWound$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ZoneChange$Type extends MessageType<ZoneChange> {
    constructor() {
        super("eq.ZoneChange", [
            { no: 1, name: "char_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "zone_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "instance_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "z", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "zone_reason", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "success", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ZoneChange>): ZoneChange {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.charName = "";
        message.zoneId = 0;
        message.instanceId = 0;
        message.y = 0;
        message.x = 0;
        message.z = 0;
        message.zoneReason = 0;
        message.success = 0;
        if (value !== undefined)
            reflectionMergePartial<ZoneChange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ZoneChange): ZoneChange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string char_name */ 1:
                    message.charName = reader.string();
                    break;
                case /* int32 zone_id */ 2:
                    message.zoneId = reader.int32();
                    break;
                case /* int32 instance_id */ 3:
                    message.instanceId = reader.int32();
                    break;
                case /* float y */ 4:
                    message.y = reader.float();
                    break;
                case /* float x */ 5:
                    message.x = reader.float();
                    break;
                case /* float z */ 6:
                    message.z = reader.float();
                    break;
                case /* int32 zone_reason */ 7:
                    message.zoneReason = reader.int32();
                    break;
                case /* int32 success */ 8:
                    message.success = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ZoneChange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string char_name = 1; */
        if (message.charName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.charName);
        /* int32 zone_id = 2; */
        if (message.zoneId !== 0)
            writer.tag(2, WireType.Varint).int32(message.zoneId);
        /* int32 instance_id = 3; */
        if (message.instanceId !== 0)
            writer.tag(3, WireType.Varint).int32(message.instanceId);
        /* float y = 4; */
        if (message.y !== 0)
            writer.tag(4, WireType.Bit32).float(message.y);
        /* float x = 5; */
        if (message.x !== 0)
            writer.tag(5, WireType.Bit32).float(message.x);
        /* float z = 6; */
        if (message.z !== 0)
            writer.tag(6, WireType.Bit32).float(message.z);
        /* int32 zone_reason = 7; */
        if (message.zoneReason !== 0)
            writer.tag(7, WireType.Varint).int32(message.zoneReason);
        /* int32 success = 8; */
        if (message.success !== 0)
            writer.tag(8, WireType.Varint).int32(message.success);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.ZoneChange
 */
export const ZoneChange = new ZoneChange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestClientZoneChange$Type extends MessageType<RequestClientZoneChange> {
    constructor() {
        super("eq.RequestClientZoneChange", [
            { no: 1, name: "zone_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "instance_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "z", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "heading", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "type", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<RequestClientZoneChange>): RequestClientZoneChange {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.zoneId = 0;
        message.instanceId = 0;
        message.y = 0;
        message.x = 0;
        message.z = 0;
        message.heading = 0;
        message.type = 0;
        if (value !== undefined)
            reflectionMergePartial<RequestClientZoneChange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestClientZoneChange): RequestClientZoneChange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 zone_id */ 1:
                    message.zoneId = reader.int32();
                    break;
                case /* int32 instance_id */ 2:
                    message.instanceId = reader.int32();
                    break;
                case /* float y */ 3:
                    message.y = reader.float();
                    break;
                case /* float x */ 4:
                    message.x = reader.float();
                    break;
                case /* float z */ 5:
                    message.z = reader.float();
                    break;
                case /* float heading */ 6:
                    message.heading = reader.float();
                    break;
                case /* int32 type */ 7:
                    message.type = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestClientZoneChange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 zone_id = 1; */
        if (message.zoneId !== 0)
            writer.tag(1, WireType.Varint).int32(message.zoneId);
        /* int32 instance_id = 2; */
        if (message.instanceId !== 0)
            writer.tag(2, WireType.Varint).int32(message.instanceId);
        /* float y = 3; */
        if (message.y !== 0)
            writer.tag(3, WireType.Bit32).float(message.y);
        /* float x = 4; */
        if (message.x !== 0)
            writer.tag(4, WireType.Bit32).float(message.x);
        /* float z = 5; */
        if (message.z !== 0)
            writer.tag(5, WireType.Bit32).float(message.z);
        /* float heading = 6; */
        if (message.heading !== 0)
            writer.tag(6, WireType.Bit32).float(message.heading);
        /* int32 type = 7; */
        if (message.type !== 0)
            writer.tag(7, WireType.Varint).int32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.RequestClientZoneChange
 */
export const RequestClientZoneChange = new RequestClientZoneChange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Animation$Type extends MessageType<Animation> {
    constructor() {
        super("eq.Animation", [
            { no: 1, name: "spawnid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "speed", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "action", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Animation>): Animation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.spawnid = 0;
        message.speed = 0;
        message.action = 0;
        if (value !== undefined)
            reflectionMergePartial<Animation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Animation): Animation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 spawnid */ 1:
                    message.spawnid = reader.int32();
                    break;
                case /* int32 speed */ 2:
                    message.speed = reader.int32();
                    break;
                case /* int32 action */ 3:
                    message.action = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Animation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 spawnid = 1; */
        if (message.spawnid !== 0)
            writer.tag(1, WireType.Varint).int32(message.spawnid);
        /* int32 speed = 2; */
        if (message.speed !== 0)
            writer.tag(2, WireType.Varint).int32(message.speed);
        /* int32 action = 3; */
        if (message.action !== 0)
            writer.tag(3, WireType.Varint).int32(message.action);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Animation
 */
export const Animation = new Animation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Action$Type extends MessageType<Action> {
    constructor() {
        super("eq.Action", [
            { no: 1, name: "target", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "source", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "level", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "instrument_mod", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "force", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "hit_heading", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "hit_pitch", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "spell", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "spell_level", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "effect_flag", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Action>): Action {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.target = 0;
        message.source = 0;
        message.level = 0;
        message.instrumentMod = 0;
        message.force = 0;
        message.hitHeading = 0;
        message.hitPitch = 0;
        message.type = 0;
        message.spell = 0;
        message.spellLevel = 0;
        message.effectFlag = 0;
        if (value !== undefined)
            reflectionMergePartial<Action>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Action): Action {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 target */ 1:
                    message.target = reader.int32();
                    break;
                case /* int32 source */ 2:
                    message.source = reader.int32();
                    break;
                case /* int32 level */ 3:
                    message.level = reader.int32();
                    break;
                case /* int32 instrument_mod */ 4:
                    message.instrumentMod = reader.int32();
                    break;
                case /* float force */ 5:
                    message.force = reader.float();
                    break;
                case /* float hit_heading */ 6:
                    message.hitHeading = reader.float();
                    break;
                case /* float hit_pitch */ 7:
                    message.hitPitch = reader.float();
                    break;
                case /* int32 type */ 8:
                    message.type = reader.int32();
                    break;
                case /* int32 spell */ 9:
                    message.spell = reader.int32();
                    break;
                case /* int32 spell_level */ 10:
                    message.spellLevel = reader.int32();
                    break;
                case /* int32 effect_flag */ 11:
                    message.effectFlag = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Action, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 target = 1; */
        if (message.target !== 0)
            writer.tag(1, WireType.Varint).int32(message.target);
        /* int32 source = 2; */
        if (message.source !== 0)
            writer.tag(2, WireType.Varint).int32(message.source);
        /* int32 level = 3; */
        if (message.level !== 0)
            writer.tag(3, WireType.Varint).int32(message.level);
        /* int32 instrument_mod = 4; */
        if (message.instrumentMod !== 0)
            writer.tag(4, WireType.Varint).int32(message.instrumentMod);
        /* float force = 5; */
        if (message.force !== 0)
            writer.tag(5, WireType.Bit32).float(message.force);
        /* float hit_heading = 6; */
        if (message.hitHeading !== 0)
            writer.tag(6, WireType.Bit32).float(message.hitHeading);
        /* float hit_pitch = 7; */
        if (message.hitPitch !== 0)
            writer.tag(7, WireType.Bit32).float(message.hitPitch);
        /* int32 type = 8; */
        if (message.type !== 0)
            writer.tag(8, WireType.Varint).int32(message.type);
        /* int32 spell = 9; */
        if (message.spell !== 0)
            writer.tag(9, WireType.Varint).int32(message.spell);
        /* int32 spell_level = 10; */
        if (message.spellLevel !== 0)
            writer.tag(10, WireType.Varint).int32(message.spellLevel);
        /* int32 effect_flag = 11; */
        if (message.effectFlag !== 0)
            writer.tag(11, WireType.Varint).int32(message.effectFlag);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Action
 */
export const Action = new Action$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CombatDamage$Type extends MessageType<CombatDamage> {
    constructor() {
        super("eq.CombatDamage", [
            { no: 1, name: "target", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "source", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "spellid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "damage", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "force", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "hit_heading", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "hit_pitch", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<CombatDamage>): CombatDamage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.target = 0;
        message.source = 0;
        message.type = 0;
        message.spellid = 0;
        message.damage = 0;
        message.force = 0;
        message.hitHeading = 0;
        message.hitPitch = 0;
        if (value !== undefined)
            reflectionMergePartial<CombatDamage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CombatDamage): CombatDamage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 target */ 1:
                    message.target = reader.int32();
                    break;
                case /* int32 source */ 2:
                    message.source = reader.int32();
                    break;
                case /* int32 type */ 3:
                    message.type = reader.int32();
                    break;
                case /* int32 spellid */ 4:
                    message.spellid = reader.int32();
                    break;
                case /* int32 damage */ 5:
                    message.damage = reader.int32();
                    break;
                case /* float force */ 6:
                    message.force = reader.float();
                    break;
                case /* float hit_heading */ 7:
                    message.hitHeading = reader.float();
                    break;
                case /* float hit_pitch */ 8:
                    message.hitPitch = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CombatDamage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 target = 1; */
        if (message.target !== 0)
            writer.tag(1, WireType.Varint).int32(message.target);
        /* int32 source = 2; */
        if (message.source !== 0)
            writer.tag(2, WireType.Varint).int32(message.source);
        /* int32 type = 3; */
        if (message.type !== 0)
            writer.tag(3, WireType.Varint).int32(message.type);
        /* int32 spellid = 4; */
        if (message.spellid !== 0)
            writer.tag(4, WireType.Varint).int32(message.spellid);
        /* int32 damage = 5; */
        if (message.damage !== 0)
            writer.tag(5, WireType.Varint).int32(message.damage);
        /* float force = 6; */
        if (message.force !== 0)
            writer.tag(6, WireType.Bit32).float(message.force);
        /* float hit_heading = 7; */
        if (message.hitHeading !== 0)
            writer.tag(7, WireType.Bit32).float(message.hitHeading);
        /* float hit_pitch = 8; */
        if (message.hitPitch !== 0)
            writer.tag(8, WireType.Bit32).float(message.hitPitch);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.CombatDamage
 */
export const CombatDamage = new CombatDamage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Consider$Type extends MessageType<Consider> {
    constructor() {
        super("eq.Consider", [
            { no: 1, name: "playerid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "targetid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "faction", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "level", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "cur_hp", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "max_hp", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "pvpcon", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Consider>): Consider {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.playerid = 0;
        message.targetid = 0;
        message.faction = 0;
        message.level = 0;
        message.curHp = 0;
        message.maxHp = 0;
        message.pvpcon = 0;
        if (value !== undefined)
            reflectionMergePartial<Consider>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Consider): Consider {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 playerid */ 1:
                    message.playerid = reader.int32();
                    break;
                case /* int32 targetid */ 2:
                    message.targetid = reader.int32();
                    break;
                case /* int32 faction */ 3:
                    message.faction = reader.int32();
                    break;
                case /* int32 level */ 4:
                    message.level = reader.int32();
                    break;
                case /* int32 cur_hp */ 5:
                    message.curHp = reader.int32();
                    break;
                case /* int32 max_hp */ 6:
                    message.maxHp = reader.int32();
                    break;
                case /* int32 pvpcon */ 7:
                    message.pvpcon = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Consider, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 playerid = 1; */
        if (message.playerid !== 0)
            writer.tag(1, WireType.Varint).int32(message.playerid);
        /* int32 targetid = 2; */
        if (message.targetid !== 0)
            writer.tag(2, WireType.Varint).int32(message.targetid);
        /* int32 faction = 3; */
        if (message.faction !== 0)
            writer.tag(3, WireType.Varint).int32(message.faction);
        /* int32 level = 4; */
        if (message.level !== 0)
            writer.tag(4, WireType.Varint).int32(message.level);
        /* int32 cur_hp = 5; */
        if (message.curHp !== 0)
            writer.tag(5, WireType.Varint).int32(message.curHp);
        /* int32 max_hp = 6; */
        if (message.maxHp !== 0)
            writer.tag(6, WireType.Varint).int32(message.maxHp);
        /* int32 pvpcon = 7; */
        if (message.pvpcon !== 0)
            writer.tag(7, WireType.Varint).int32(message.pvpcon);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Consider
 */
export const Consider = new Consider$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Death$Type extends MessageType<Death> {
    constructor() {
        super("eq.Death", [
            { no: 1, name: "spawn_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "killer_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "corpseid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "attack_skill", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "spell_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "bindzoneid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "damage", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Death>): Death {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.spawnId = 0;
        message.killerId = 0;
        message.corpseid = 0;
        message.attackSkill = 0;
        message.spellId = 0;
        message.bindzoneid = 0;
        message.damage = 0;
        if (value !== undefined)
            reflectionMergePartial<Death>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Death): Death {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 spawn_id */ 1:
                    message.spawnId = reader.int32();
                    break;
                case /* int32 killer_id */ 2:
                    message.killerId = reader.int32();
                    break;
                case /* int32 corpseid */ 3:
                    message.corpseid = reader.int32();
                    break;
                case /* int32 attack_skill */ 4:
                    message.attackSkill = reader.int32();
                    break;
                case /* int32 spell_id */ 5:
                    message.spellId = reader.int32();
                    break;
                case /* int32 bindzoneid */ 6:
                    message.bindzoneid = reader.int32();
                    break;
                case /* int32 damage */ 7:
                    message.damage = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Death, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 spawn_id = 1; */
        if (message.spawnId !== 0)
            writer.tag(1, WireType.Varint).int32(message.spawnId);
        /* int32 killer_id = 2; */
        if (message.killerId !== 0)
            writer.tag(2, WireType.Varint).int32(message.killerId);
        /* int32 corpseid = 3; */
        if (message.corpseid !== 0)
            writer.tag(3, WireType.Varint).int32(message.corpseid);
        /* int32 attack_skill = 4; */
        if (message.attackSkill !== 0)
            writer.tag(4, WireType.Varint).int32(message.attackSkill);
        /* int32 spell_id = 5; */
        if (message.spellId !== 0)
            writer.tag(5, WireType.Varint).int32(message.spellId);
        /* int32 bindzoneid = 6; */
        if (message.bindzoneid !== 0)
            writer.tag(6, WireType.Varint).int32(message.bindzoneid);
        /* int32 damage = 7; */
        if (message.damage !== 0)
            writer.tag(7, WireType.Varint).int32(message.damage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Death
 */
export const Death = new Death$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BecomeCorpse$Type extends MessageType<BecomeCorpse> {
    constructor() {
        super("eq.BecomeCorpse", [
            { no: 1, name: "spawn_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "z", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<BecomeCorpse>): BecomeCorpse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.spawnId = 0;
        message.y = 0;
        message.x = 0;
        message.z = 0;
        if (value !== undefined)
            reflectionMergePartial<BecomeCorpse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BecomeCorpse): BecomeCorpse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 spawn_id */ 1:
                    message.spawnId = reader.int32();
                    break;
                case /* float y */ 2:
                    message.y = reader.float();
                    break;
                case /* float x */ 3:
                    message.x = reader.float();
                    break;
                case /* float z */ 4:
                    message.z = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BecomeCorpse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 spawn_id = 1; */
        if (message.spawnId !== 0)
            writer.tag(1, WireType.Varint).int32(message.spawnId);
        /* float y = 2; */
        if (message.y !== 0)
            writer.tag(2, WireType.Bit32).float(message.y);
        /* float x = 3; */
        if (message.x !== 0)
            writer.tag(3, WireType.Bit32).float(message.x);
        /* float z = 4; */
        if (message.z !== 0)
            writer.tag(4, WireType.Bit32).float(message.z);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.BecomeCorpse
 */
export const BecomeCorpse = new BecomeCorpse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerPositionUpdateServer$Type extends MessageType<PlayerPositionUpdateServer> {
    constructor() {
        super("eq.PlayerPositionUpdateServer", [
            { no: 1, name: "spawn_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "delta_heading", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "x_pos", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "y_pos", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "animation", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "z_pos", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "delta_y", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "delta_x", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "heading", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "delta_z", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<PlayerPositionUpdateServer>): PlayerPositionUpdateServer {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.spawnId = 0;
        message.deltaHeading = 0;
        message.xPos = 0;
        message.yPos = 0;
        message.animation = 0;
        message.zPos = 0;
        message.deltaY = 0;
        message.deltaX = 0;
        message.heading = 0;
        message.deltaZ = 0;
        if (value !== undefined)
            reflectionMergePartial<PlayerPositionUpdateServer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerPositionUpdateServer): PlayerPositionUpdateServer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 spawn_id */ 1:
                    message.spawnId = reader.int32();
                    break;
                case /* int32 delta_heading */ 2:
                    message.deltaHeading = reader.int32();
                    break;
                case /* int32 x_pos */ 3:
                    message.xPos = reader.int32();
                    break;
                case /* int32 y_pos */ 4:
                    message.yPos = reader.int32();
                    break;
                case /* int32 animation */ 5:
                    message.animation = reader.int32();
                    break;
                case /* int32 z_pos */ 6:
                    message.zPos = reader.int32();
                    break;
                case /* int32 delta_y */ 7:
                    message.deltaY = reader.int32();
                    break;
                case /* int32 delta_x */ 8:
                    message.deltaX = reader.int32();
                    break;
                case /* int32 heading */ 9:
                    message.heading = reader.int32();
                    break;
                case /* int32 delta_z */ 10:
                    message.deltaZ = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerPositionUpdateServer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 spawn_id = 1; */
        if (message.spawnId !== 0)
            writer.tag(1, WireType.Varint).int32(message.spawnId);
        /* int32 delta_heading = 2; */
        if (message.deltaHeading !== 0)
            writer.tag(2, WireType.Varint).int32(message.deltaHeading);
        /* int32 x_pos = 3; */
        if (message.xPos !== 0)
            writer.tag(3, WireType.Varint).int32(message.xPos);
        /* int32 y_pos = 4; */
        if (message.yPos !== 0)
            writer.tag(4, WireType.Varint).int32(message.yPos);
        /* int32 animation = 5; */
        if (message.animation !== 0)
            writer.tag(5, WireType.Varint).int32(message.animation);
        /* int32 z_pos = 6; */
        if (message.zPos !== 0)
            writer.tag(6, WireType.Varint).int32(message.zPos);
        /* int32 delta_y = 7; */
        if (message.deltaY !== 0)
            writer.tag(7, WireType.Varint).int32(message.deltaY);
        /* int32 delta_x = 8; */
        if (message.deltaX !== 0)
            writer.tag(8, WireType.Varint).int32(message.deltaX);
        /* int32 heading = 9; */
        if (message.heading !== 0)
            writer.tag(9, WireType.Varint).int32(message.heading);
        /* int32 delta_z = 10; */
        if (message.deltaZ !== 0)
            writer.tag(10, WireType.Varint).int32(message.deltaZ);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.PlayerPositionUpdateServer
 */
export const PlayerPositionUpdateServer = new PlayerPositionUpdateServer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerPositionUpdateClient$Type extends MessageType<PlayerPositionUpdateClient> {
    constructor() {
        super("eq.PlayerPositionUpdateClient", [
            { no: 1, name: "spawn_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "sequence", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "y_pos", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "delta_z", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "delta_x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "delta_y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "animation", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "delta_heading", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "x_pos", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 10, name: "z_pos", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 11, name: "heading", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<PlayerPositionUpdateClient>): PlayerPositionUpdateClient {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.spawnId = 0;
        message.sequence = 0;
        message.yPos = 0;
        message.deltaZ = 0;
        message.deltaX = 0;
        message.deltaY = 0;
        message.animation = 0;
        message.deltaHeading = 0;
        message.xPos = 0;
        message.zPos = 0;
        message.heading = 0;
        if (value !== undefined)
            reflectionMergePartial<PlayerPositionUpdateClient>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerPositionUpdateClient): PlayerPositionUpdateClient {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 spawn_id */ 1:
                    message.spawnId = reader.int32();
                    break;
                case /* int32 sequence */ 2:
                    message.sequence = reader.int32();
                    break;
                case /* float y_pos */ 3:
                    message.yPos = reader.float();
                    break;
                case /* float delta_z */ 4:
                    message.deltaZ = reader.float();
                    break;
                case /* float delta_x */ 5:
                    message.deltaX = reader.float();
                    break;
                case /* float delta_y */ 6:
                    message.deltaY = reader.float();
                    break;
                case /* int32 animation */ 7:
                    message.animation = reader.int32();
                    break;
                case /* int32 delta_heading */ 8:
                    message.deltaHeading = reader.int32();
                    break;
                case /* float x_pos */ 9:
                    message.xPos = reader.float();
                    break;
                case /* float z_pos */ 10:
                    message.zPos = reader.float();
                    break;
                case /* int32 heading */ 11:
                    message.heading = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerPositionUpdateClient, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 spawn_id = 1; */
        if (message.spawnId !== 0)
            writer.tag(1, WireType.Varint).int32(message.spawnId);
        /* int32 sequence = 2; */
        if (message.sequence !== 0)
            writer.tag(2, WireType.Varint).int32(message.sequence);
        /* float y_pos = 3; */
        if (message.yPos !== 0)
            writer.tag(3, WireType.Bit32).float(message.yPos);
        /* float delta_z = 4; */
        if (message.deltaZ !== 0)
            writer.tag(4, WireType.Bit32).float(message.deltaZ);
        /* float delta_x = 5; */
        if (message.deltaX !== 0)
            writer.tag(5, WireType.Bit32).float(message.deltaX);
        /* float delta_y = 6; */
        if (message.deltaY !== 0)
            writer.tag(6, WireType.Bit32).float(message.deltaY);
        /* int32 animation = 7; */
        if (message.animation !== 0)
            writer.tag(7, WireType.Varint).int32(message.animation);
        /* int32 delta_heading = 8; */
        if (message.deltaHeading !== 0)
            writer.tag(8, WireType.Varint).int32(message.deltaHeading);
        /* float x_pos = 9; */
        if (message.xPos !== 0)
            writer.tag(9, WireType.Bit32).float(message.xPos);
        /* float z_pos = 10; */
        if (message.zPos !== 0)
            writer.tag(10, WireType.Bit32).float(message.zPos);
        /* int32 heading = 11; */
        if (message.heading !== 0)
            writer.tag(11, WireType.Varint).int32(message.heading);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.PlayerPositionUpdateClient
 */
export const PlayerPositionUpdateClient = new PlayerPositionUpdateClient$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpawnHPUpdate$Type extends MessageType<SpawnHPUpdate> {
    constructor() {
        super("eq.SpawnHPUpdate", [
            { no: 1, name: "cur_hp", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "max_hp", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "spawn_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SpawnHPUpdate>): SpawnHPUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.curHp = 0;
        message.maxHp = 0;
        message.spawnId = 0;
        if (value !== undefined)
            reflectionMergePartial<SpawnHPUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpawnHPUpdate): SpawnHPUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 cur_hp */ 1:
                    message.curHp = reader.int32();
                    break;
                case /* int32 max_hp */ 2:
                    message.maxHp = reader.int32();
                    break;
                case /* int32 spawn_id */ 3:
                    message.spawnId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpawnHPUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 cur_hp = 1; */
        if (message.curHp !== 0)
            writer.tag(1, WireType.Varint).int32(message.curHp);
        /* int32 max_hp = 2; */
        if (message.maxHp !== 0)
            writer.tag(2, WireType.Varint).int32(message.maxHp);
        /* int32 spawn_id = 3; */
        if (message.spawnId !== 0)
            writer.tag(3, WireType.Varint).int32(message.spawnId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.SpawnHPUpdate
 */
export const SpawnHPUpdate = new SpawnHPUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpawnHPUpdate2$Type extends MessageType<SpawnHPUpdate2> {
    constructor() {
        super("eq.SpawnHPUpdate2", [
            { no: 1, name: "spawn_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "hp", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SpawnHPUpdate2>): SpawnHPUpdate2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.spawnId = 0;
        message.hp = 0;
        if (value !== undefined)
            reflectionMergePartial<SpawnHPUpdate2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpawnHPUpdate2): SpawnHPUpdate2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 spawn_id */ 1:
                    message.spawnId = reader.int32();
                    break;
                case /* int32 hp */ 2:
                    message.hp = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpawnHPUpdate2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 spawn_id = 1; */
        if (message.spawnId !== 0)
            writer.tag(1, WireType.Varint).int32(message.spawnId);
        /* int32 hp = 2; */
        if (message.hp !== 0)
            writer.tag(2, WireType.Varint).int32(message.hp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.SpawnHPUpdate2
 */
export const SpawnHPUpdate2 = new SpawnHPUpdate2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Stamina$Type extends MessageType<Stamina> {
    constructor() {
        super("eq.Stamina", [
            { no: 1, name: "food", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "water", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Stamina>): Stamina {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.food = 0;
        message.water = 0;
        if (value !== undefined)
            reflectionMergePartial<Stamina>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Stamina): Stamina {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 food */ 1:
                    message.food = reader.int32();
                    break;
                case /* int32 water */ 2:
                    message.water = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Stamina, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 food = 1; */
        if (message.food !== 0)
            writer.tag(1, WireType.Varint).int32(message.food);
        /* int32 water = 2; */
        if (message.water !== 0)
            writer.tag(2, WireType.Varint).int32(message.water);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Stamina
 */
export const Stamina = new Stamina$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LevelUpdate$Type extends MessageType<LevelUpdate> {
    constructor() {
        super("eq.LevelUpdate", [
            { no: 1, name: "level", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "level_old", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "exp", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<LevelUpdate>): LevelUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.level = 0;
        message.levelOld = 0;
        message.exp = 0;
        if (value !== undefined)
            reflectionMergePartial<LevelUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LevelUpdate): LevelUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 level */ 1:
                    message.level = reader.int32();
                    break;
                case /* int32 level_old */ 2:
                    message.levelOld = reader.int32();
                    break;
                case /* int32 exp */ 3:
                    message.exp = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LevelUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 level = 1; */
        if (message.level !== 0)
            writer.tag(1, WireType.Varint).int32(message.level);
        /* int32 level_old = 2; */
        if (message.levelOld !== 0)
            writer.tag(2, WireType.Varint).int32(message.levelOld);
        /* int32 exp = 3; */
        if (message.exp !== 0)
            writer.tag(3, WireType.Varint).int32(message.exp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.LevelUpdate
 */
export const LevelUpdate = new LevelUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpUpdate$Type extends MessageType<ExpUpdate> {
    constructor() {
        super("eq.ExpUpdate", [
            { no: 1, name: "exp", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "aaxp", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ExpUpdate>): ExpUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.exp = 0;
        message.aaxp = 0;
        if (value !== undefined)
            reflectionMergePartial<ExpUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExpUpdate): ExpUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 exp */ 1:
                    message.exp = reader.int32();
                    break;
                case /* int32 aaxp */ 2:
                    message.aaxp = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExpUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 exp = 1; */
        if (message.exp !== 0)
            writer.tag(1, WireType.Varint).int32(message.exp);
        /* int32 aaxp = 2; */
        if (message.aaxp !== 0)
            writer.tag(2, WireType.Varint).int32(message.aaxp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.ExpUpdate
 */
export const ExpUpdate = new ExpUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ItemPacket$Type extends MessageType<ItemPacket> {
    constructor() {
        super("eq.ItemPacket", [
            { no: 1, name: "packet_type", kind: "enum", T: () => ["eq.ItemPacketType", ItemPacketType] },
            { no: 2, name: "serialized_item", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ItemPacket>): ItemPacket {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.packetType = 0;
        message.serializedItem = "";
        if (value !== undefined)
            reflectionMergePartial<ItemPacket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ItemPacket): ItemPacket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* eq.ItemPacketType packet_type */ 1:
                    message.packetType = reader.int32();
                    break;
                case /* string serialized_item */ 2:
                    message.serializedItem = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ItemPacket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* eq.ItemPacketType packet_type = 1; */
        if (message.packetType !== 0)
            writer.tag(1, WireType.Varint).int32(message.packetType);
        /* string serialized_item = 2; */
        if (message.serializedItem !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.serializedItem);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.ItemPacket
 */
export const ItemPacket = new ItemPacket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BulkItemPacket$Type extends MessageType<BulkItemPacket> {
    constructor() {
        super("eq.BulkItemPacket", [
            { no: 1, name: "serialized_item", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BulkItemPacket>): BulkItemPacket {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serializedItem = "";
        if (value !== undefined)
            reflectionMergePartial<BulkItemPacket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BulkItemPacket): BulkItemPacket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string serialized_item */ 1:
                    message.serializedItem = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BulkItemPacket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string serialized_item = 1; */
        if (message.serializedItem !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.serializedItem);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.BulkItemPacket
 */
export const BulkItemPacket = new BulkItemPacket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Consume$Type extends MessageType<Consume> {
    constructor() {
        super("eq.Consume", [
            { no: 1, name: "slot", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "auto_consumed", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "type", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Consume>): Consume {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.slot = 0;
        message.autoConsumed = 0;
        message.type = 0;
        if (value !== undefined)
            reflectionMergePartial<Consume>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Consume): Consume {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 slot */ 1:
                    message.slot = reader.int32();
                    break;
                case /* int32 auto_consumed */ 2:
                    message.autoConsumed = reader.int32();
                    break;
                case /* int32 type */ 3:
                    message.type = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Consume, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 slot = 1; */
        if (message.slot !== 0)
            writer.tag(1, WireType.Varint).int32(message.slot);
        /* int32 auto_consumed = 2; */
        if (message.autoConsumed !== 0)
            writer.tag(2, WireType.Varint).int32(message.autoConsumed);
        /* int32 type = 3; */
        if (message.type !== 0)
            writer.tag(3, WireType.Varint).int32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Consume
 */
export const Consume = new Consume$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteItem$Type extends MessageType<DeleteItem> {
    constructor() {
        super("eq.DeleteItem", [
            { no: 1, name: "from_slot", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "to_slot", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "number_in_stack", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteItem>): DeleteItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fromSlot = 0;
        message.toSlot = 0;
        message.numberInStack = 0;
        if (value !== undefined)
            reflectionMergePartial<DeleteItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteItem): DeleteItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 from_slot */ 1:
                    message.fromSlot = reader.int32();
                    break;
                case /* int32 to_slot */ 2:
                    message.toSlot = reader.int32();
                    break;
                case /* int32 number_in_stack */ 3:
                    message.numberInStack = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 from_slot = 1; */
        if (message.fromSlot !== 0)
            writer.tag(1, WireType.Varint).int32(message.fromSlot);
        /* int32 to_slot = 2; */
        if (message.toSlot !== 0)
            writer.tag(2, WireType.Varint).int32(message.toSlot);
        /* int32 number_in_stack = 3; */
        if (message.numberInStack !== 0)
            writer.tag(3, WireType.Varint).int32(message.numberInStack);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.DeleteItem
 */
export const DeleteItem = new DeleteItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MoveItem$Type extends MessageType<MoveItem> {
    constructor() {
        super("eq.MoveItem", [
            { no: 1, name: "from_slot", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "to_slot", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "number_in_stack", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<MoveItem>): MoveItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fromSlot = 0;
        message.toSlot = 0;
        message.numberInStack = 0;
        if (value !== undefined)
            reflectionMergePartial<MoveItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MoveItem): MoveItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 from_slot */ 1:
                    message.fromSlot = reader.int32();
                    break;
                case /* int32 to_slot */ 2:
                    message.toSlot = reader.int32();
                    break;
                case /* int32 number_in_stack */ 3:
                    message.numberInStack = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MoveItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 from_slot = 1; */
        if (message.fromSlot !== 0)
            writer.tag(1, WireType.Varint).int32(message.fromSlot);
        /* int32 to_slot = 2; */
        if (message.toSlot !== 0)
            writer.tag(2, WireType.Varint).int32(message.toSlot);
        /* int32 number_in_stack = 3; */
        if (message.numberInStack !== 0)
            writer.tag(3, WireType.Varint).int32(message.numberInStack);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.MoveItem
 */
export const MoveItem = new MoveItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MultiMoveItemSub$Type extends MessageType<MultiMoveItemSub> {
    constructor() {
        super("eq.MultiMoveItemSub", [
            { no: 1, name: "from_slot", kind: "message", T: () => InventorySlot },
            { no: 2, name: "number_in_stack", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "to_slot", kind: "message", T: () => InventorySlot }
        ]);
    }
    create(value?: PartialMessage<MultiMoveItemSub>): MultiMoveItemSub {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.numberInStack = 0;
        if (value !== undefined)
            reflectionMergePartial<MultiMoveItemSub>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MultiMoveItemSub): MultiMoveItemSub {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* eq.InventorySlot from_slot */ 1:
                    message.fromSlot = InventorySlot.internalBinaryRead(reader, reader.uint32(), options, message.fromSlot);
                    break;
                case /* int32 number_in_stack */ 2:
                    message.numberInStack = reader.int32();
                    break;
                case /* eq.InventorySlot to_slot */ 3:
                    message.toSlot = InventorySlot.internalBinaryRead(reader, reader.uint32(), options, message.toSlot);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MultiMoveItemSub, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* eq.InventorySlot from_slot = 1; */
        if (message.fromSlot)
            InventorySlot.internalBinaryWrite(message.fromSlot, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 number_in_stack = 2; */
        if (message.numberInStack !== 0)
            writer.tag(2, WireType.Varint).int32(message.numberInStack);
        /* eq.InventorySlot to_slot = 3; */
        if (message.toSlot)
            InventorySlot.internalBinaryWrite(message.toSlot, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.MultiMoveItemSub
 */
export const MultiMoveItemSub = new MultiMoveItemSub$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MultiMoveItem$Type extends MessageType<MultiMoveItem> {
    constructor() {
        super("eq.MultiMoveItem", [
            { no: 1, name: "count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "moves", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MultiMoveItemSub }
        ]);
    }
    create(value?: PartialMessage<MultiMoveItem>): MultiMoveItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.count = 0;
        message.moves = [];
        if (value !== undefined)
            reflectionMergePartial<MultiMoveItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MultiMoveItem): MultiMoveItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 count */ 1:
                    message.count = reader.int32();
                    break;
                case /* repeated eq.MultiMoveItemSub moves */ 2:
                    message.moves.push(MultiMoveItemSub.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MultiMoveItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 count = 1; */
        if (message.count !== 0)
            writer.tag(1, WireType.Varint).int32(message.count);
        /* repeated eq.MultiMoveItemSub moves = 2; */
        for (let i = 0; i < message.moves.length; i++)
            MultiMoveItemSub.internalBinaryWrite(message.moves[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.MultiMoveItem
 */
export const MultiMoveItem = new MultiMoveItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MoveCoin$Type extends MessageType<MoveCoin> {
    constructor() {
        super("eq.MoveCoin", [
            { no: 1, name: "from_slot", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "to_slot", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "cointype1", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "cointype2", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "amount", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<MoveCoin>): MoveCoin {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fromSlot = 0;
        message.toSlot = 0;
        message.cointype1 = 0;
        message.cointype2 = 0;
        message.amount = 0;
        if (value !== undefined)
            reflectionMergePartial<MoveCoin>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MoveCoin): MoveCoin {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 from_slot */ 1:
                    message.fromSlot = reader.int32();
                    break;
                case /* int32 to_slot */ 2:
                    message.toSlot = reader.int32();
                    break;
                case /* int32 cointype1 */ 3:
                    message.cointype1 = reader.int32();
                    break;
                case /* int32 cointype2 */ 4:
                    message.cointype2 = reader.int32();
                    break;
                case /* int32 amount */ 5:
                    message.amount = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MoveCoin, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 from_slot = 1; */
        if (message.fromSlot !== 0)
            writer.tag(1, WireType.Varint).int32(message.fromSlot);
        /* int32 to_slot = 2; */
        if (message.toSlot !== 0)
            writer.tag(2, WireType.Varint).int32(message.toSlot);
        /* int32 cointype1 = 3; */
        if (message.cointype1 !== 0)
            writer.tag(3, WireType.Varint).int32(message.cointype1);
        /* int32 cointype2 = 4; */
        if (message.cointype2 !== 0)
            writer.tag(4, WireType.Varint).int32(message.cointype2);
        /* int32 amount = 5; */
        if (message.amount !== 0)
            writer.tag(5, WireType.Varint).int32(message.amount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.MoveCoin
 */
export const MoveCoin = new MoveCoin$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradeBusy$Type extends MessageType<TradeBusy> {
    constructor() {
        super("eq.TradeBusy", [
            { no: 1, name: "to_mob_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "from_mob_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TradeBusy>): TradeBusy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.toMobId = 0;
        message.fromMobId = 0;
        if (value !== undefined)
            reflectionMergePartial<TradeBusy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradeBusy): TradeBusy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 to_mob_id */ 1:
                    message.toMobId = reader.int32();
                    break;
                case /* int32 from_mob_id */ 2:
                    message.fromMobId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradeBusy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 to_mob_id = 1; */
        if (message.toMobId !== 0)
            writer.tag(1, WireType.Varint).int32(message.toMobId);
        /* int32 from_mob_id = 2; */
        if (message.fromMobId !== 0)
            writer.tag(2, WireType.Varint).int32(message.fromMobId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.TradeBusy
 */
export const TradeBusy = new TradeBusy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradeCoin$Type extends MessageType<TradeCoin> {
    constructor() {
        super("eq.TradeCoin", [
            { no: 1, name: "trader", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "slot", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "amount", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TradeCoin>): TradeCoin {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.trader = 0;
        message.slot = 0;
        message.amount = 0;
        if (value !== undefined)
            reflectionMergePartial<TradeCoin>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradeCoin): TradeCoin {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 trader */ 1:
                    message.trader = reader.int32();
                    break;
                case /* int32 slot */ 2:
                    message.slot = reader.int32();
                    break;
                case /* int32 amount */ 3:
                    message.amount = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradeCoin, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 trader = 1; */
        if (message.trader !== 0)
            writer.tag(1, WireType.Varint).int32(message.trader);
        /* int32 slot = 2; */
        if (message.slot !== 0)
            writer.tag(2, WireType.Varint).int32(message.slot);
        /* int32 amount = 3; */
        if (message.amount !== 0)
            writer.tag(3, WireType.Varint).int32(message.amount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.TradeCoin
 */
export const TradeCoin = new TradeCoin$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradeMoneyUpdate$Type extends MessageType<TradeMoneyUpdate> {
    constructor() {
        super("eq.TradeMoneyUpdate", [
            { no: 1, name: "trader", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "amount", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TradeMoneyUpdate>): TradeMoneyUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.trader = 0;
        message.type = 0;
        message.amount = 0;
        if (value !== undefined)
            reflectionMergePartial<TradeMoneyUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradeMoneyUpdate): TradeMoneyUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 trader */ 1:
                    message.trader = reader.int32();
                    break;
                case /* int32 type */ 2:
                    message.type = reader.int32();
                    break;
                case /* int32 amount */ 3:
                    message.amount = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradeMoneyUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 trader = 1; */
        if (message.trader !== 0)
            writer.tag(1, WireType.Varint).int32(message.trader);
        /* int32 type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* int32 amount = 3; */
        if (message.amount !== 0)
            writer.tag(3, WireType.Varint).int32(message.amount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.TradeMoneyUpdate
 */
export const TradeMoneyUpdate = new TradeMoneyUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Surname$Type extends MessageType<Surname> {
    constructor() {
        super("eq.Surname", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "lastname", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Surname>): Surname {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.lastname = "";
        if (value !== undefined)
            reflectionMergePartial<Surname>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Surname): Surname {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string lastname */ 2:
                    message.lastname = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Surname, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string lastname = 2; */
        if (message.lastname !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.lastname);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Surname
 */
export const Surname = new Surname$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GuildsList$Type extends MessageType<GuildsList> {
    constructor() {
        super("eq.GuildsList", [
            { no: 1, name: "guilds", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => StringList }
        ]);
    }
    create(value?: PartialMessage<GuildsList>): GuildsList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.guilds = [];
        if (value !== undefined)
            reflectionMergePartial<GuildsList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GuildsList): GuildsList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eq.StringList guilds */ 1:
                    message.guilds.push(StringList.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GuildsList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated eq.StringList guilds = 1; */
        for (let i = 0; i < message.guilds.length; i++)
            StringList.internalBinaryWrite(message.guilds[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.GuildsList
 */
export const GuildsList = new GuildsList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MoneyOnCorpse$Type extends MessageType<MoneyOnCorpse> {
    constructor() {
        super("eq.MoneyOnCorpse", [
            { no: 1, name: "response", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "platinum", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "gold", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "silver", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "copper", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<MoneyOnCorpse>): MoneyOnCorpse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.response = 0;
        message.platinum = 0;
        message.gold = 0;
        message.silver = 0;
        message.copper = 0;
        if (value !== undefined)
            reflectionMergePartial<MoneyOnCorpse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MoneyOnCorpse): MoneyOnCorpse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 response */ 1:
                    message.response = reader.int32();
                    break;
                case /* int32 platinum */ 2:
                    message.platinum = reader.int32();
                    break;
                case /* int32 gold */ 3:
                    message.gold = reader.int32();
                    break;
                case /* int32 silver */ 4:
                    message.silver = reader.int32();
                    break;
                case /* int32 copper */ 5:
                    message.copper = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MoneyOnCorpse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 response = 1; */
        if (message.response !== 0)
            writer.tag(1, WireType.Varint).int32(message.response);
        /* int32 platinum = 2; */
        if (message.platinum !== 0)
            writer.tag(2, WireType.Varint).int32(message.platinum);
        /* int32 gold = 3; */
        if (message.gold !== 0)
            writer.tag(3, WireType.Varint).int32(message.gold);
        /* int32 silver = 4; */
        if (message.silver !== 0)
            writer.tag(4, WireType.Varint).int32(message.silver);
        /* int32 copper = 5; */
        if (message.copper !== 0)
            writer.tag(5, WireType.Varint).int32(message.copper);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.MoneyOnCorpse
 */
export const MoneyOnCorpse = new MoneyOnCorpse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LootingItem$Type extends MessageType<LootingItem> {
    constructor() {
        super("eq.LootingItem", [
            { no: 1, name: "lootee", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "looter", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "slot_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "auto_loot", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<LootingItem>): LootingItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.lootee = 0;
        message.looter = 0;
        message.slotId = 0;
        message.autoLoot = 0;
        if (value !== undefined)
            reflectionMergePartial<LootingItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LootingItem): LootingItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 lootee */ 1:
                    message.lootee = reader.int32();
                    break;
                case /* int32 looter */ 2:
                    message.looter = reader.int32();
                    break;
                case /* int32 slot_id */ 3:
                    message.slotId = reader.int32();
                    break;
                case /* int32 auto_loot */ 4:
                    message.autoLoot = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LootingItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 lootee = 1; */
        if (message.lootee !== 0)
            writer.tag(1, WireType.Varint).int32(message.lootee);
        /* int32 looter = 2; */
        if (message.looter !== 0)
            writer.tag(2, WireType.Varint).int32(message.looter);
        /* int32 slot_id = 3; */
        if (message.slotId !== 0)
            writer.tag(3, WireType.Varint).int32(message.slotId);
        /* int32 auto_loot = 4; */
        if (message.autoLoot !== 0)
            writer.tag(4, WireType.Varint).int32(message.autoLoot);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.LootingItem
 */
export const LootingItem = new LootingItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GuildManageStatus$Type extends MessageType<GuildManageStatus> {
    constructor() {
        super("eq.GuildManageStatus", [
            { no: 1, name: "guildid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "oldrank", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "newrank", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GuildManageStatus>): GuildManageStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.guildid = 0;
        message.oldrank = 0;
        message.newrank = 0;
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<GuildManageStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GuildManageStatus): GuildManageStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 guildid */ 1:
                    message.guildid = reader.int32();
                    break;
                case /* int32 oldrank */ 2:
                    message.oldrank = reader.int32();
                    break;
                case /* int32 newrank */ 3:
                    message.newrank = reader.int32();
                    break;
                case /* string name */ 4:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GuildManageStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 guildid = 1; */
        if (message.guildid !== 0)
            writer.tag(1, WireType.Varint).int32(message.guildid);
        /* int32 oldrank = 2; */
        if (message.oldrank !== 0)
            writer.tag(2, WireType.Varint).int32(message.oldrank);
        /* int32 newrank = 3; */
        if (message.newrank !== 0)
            writer.tag(3, WireType.Varint).int32(message.newrank);
        /* string name = 4; */
        if (message.name !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.GuildManageStatus
 */
export const GuildManageStatus = new GuildManageStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GuildJoin$Type extends MessageType<GuildJoin> {
    constructor() {
        super("eq.GuildJoin", [
            { no: 1, name: "guildid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "level", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "char_class", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "rank", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "zoneid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GuildJoin>): GuildJoin {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.guildid = 0;
        message.level = 0;
        message.charClass = 0;
        message.rank = 0;
        message.zoneid = 0;
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<GuildJoin>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GuildJoin): GuildJoin {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 guildid */ 1:
                    message.guildid = reader.int32();
                    break;
                case /* int32 level */ 2:
                    message.level = reader.int32();
                    break;
                case /* int32 char_class */ 3:
                    message.charClass = reader.int32();
                    break;
                case /* int32 rank */ 4:
                    message.rank = reader.int32();
                    break;
                case /* int32 zoneid */ 5:
                    message.zoneid = reader.int32();
                    break;
                case /* string name */ 6:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GuildJoin, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 guildid = 1; */
        if (message.guildid !== 0)
            writer.tag(1, WireType.Varint).int32(message.guildid);
        /* int32 level = 2; */
        if (message.level !== 0)
            writer.tag(2, WireType.Varint).int32(message.level);
        /* int32 char_class = 3; */
        if (message.charClass !== 0)
            writer.tag(3, WireType.Varint).int32(message.charClass);
        /* int32 rank = 4; */
        if (message.rank !== 0)
            writer.tag(4, WireType.Varint).int32(message.rank);
        /* int32 zoneid = 5; */
        if (message.zoneid !== 0)
            writer.tag(5, WireType.Varint).int32(message.zoneid);
        /* string name = 6; */
        if (message.name !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.GuildJoin
 */
export const GuildJoin = new GuildJoin$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GuildInviteAccept$Type extends MessageType<GuildInviteAccept> {
    constructor() {
        super("eq.GuildInviteAccept", [
            { no: 1, name: "inviter", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "newmember", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "response", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "guildeqid", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GuildInviteAccept>): GuildInviteAccept {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.inviter = "";
        message.newmember = "";
        message.response = 0;
        message.guildeqid = 0;
        if (value !== undefined)
            reflectionMergePartial<GuildInviteAccept>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GuildInviteAccept): GuildInviteAccept {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string inviter */ 1:
                    message.inviter = reader.string();
                    break;
                case /* string newmember */ 2:
                    message.newmember = reader.string();
                    break;
                case /* int32 response */ 3:
                    message.response = reader.int32();
                    break;
                case /* int32 guildeqid */ 4:
                    message.guildeqid = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GuildInviteAccept, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string inviter = 1; */
        if (message.inviter !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.inviter);
        /* string newmember = 2; */
        if (message.newmember !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.newmember);
        /* int32 response = 3; */
        if (message.response !== 0)
            writer.tag(3, WireType.Varint).int32(message.response);
        /* int32 guildeqid = 4; */
        if (message.guildeqid !== 0)
            writer.tag(4, WireType.Varint).int32(message.guildeqid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.GuildInviteAccept
 */
export const GuildInviteAccept = new GuildInviteAccept$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GuildManageRemove$Type extends MessageType<GuildManageRemove> {
    constructor() {
        super("eq.GuildManageRemove", [
            { no: 1, name: "guildeqid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "member", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GuildManageRemove>): GuildManageRemove {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.guildeqid = 0;
        message.member = "";
        if (value !== undefined)
            reflectionMergePartial<GuildManageRemove>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GuildManageRemove): GuildManageRemove {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 guildeqid */ 1:
                    message.guildeqid = reader.int32();
                    break;
                case /* string member */ 2:
                    message.member = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GuildManageRemove, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 guildeqid = 1; */
        if (message.guildeqid !== 0)
            writer.tag(1, WireType.Varint).int32(message.guildeqid);
        /* string member = 2; */
        if (message.member !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.member);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.GuildManageRemove
 */
export const GuildManageRemove = new GuildManageRemove$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Guildcommand$Type extends MessageType<Guildcommand> {
    constructor() {
        super("eq.Guildcommand", [
            { no: 1, name: "othername", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "myname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "guildeqid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "officer", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Guildcommand>): Guildcommand {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.othername = "";
        message.myname = "";
        message.guildeqid = 0;
        message.officer = 0;
        if (value !== undefined)
            reflectionMergePartial<Guildcommand>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Guildcommand): Guildcommand {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string othername */ 1:
                    message.othername = reader.string();
                    break;
                case /* string myname */ 2:
                    message.myname = reader.string();
                    break;
                case /* int32 guildeqid */ 3:
                    message.guildeqid = reader.int32();
                    break;
                case /* int32 officer */ 4:
                    message.officer = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Guildcommand, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string othername = 1; */
        if (message.othername !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.othername);
        /* string myname = 2; */
        if (message.myname !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.myname);
        /* int32 guildeqid = 3; */
        if (message.guildeqid !== 0)
            writer.tag(3, WireType.Varint).int32(message.guildeqid);
        /* int32 officer = 4; */
        if (message.officer !== 0)
            writer.tag(4, WireType.Varint).int32(message.officer);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Guildcommand
 */
export const Guildcommand = new Guildcommand$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OnLevelMessage$Type extends MessageType<OnLevelMessage> {
    constructor() {
        super("eq.OnLevelMessage", [
            { no: 1, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "buttons", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "duration", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "popup_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<OnLevelMessage>): OnLevelMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.title = "";
        message.text = "";
        message.buttons = 0;
        message.duration = 0;
        message.popupId = 0;
        if (value !== undefined)
            reflectionMergePartial<OnLevelMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OnLevelMessage): OnLevelMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string title */ 1:
                    message.title = reader.string();
                    break;
                case /* string text */ 2:
                    message.text = reader.string();
                    break;
                case /* int32 buttons */ 3:
                    message.buttons = reader.int32();
                    break;
                case /* int32 duration */ 4:
                    message.duration = reader.int32();
                    break;
                case /* int32 popup_id */ 5:
                    message.popupId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OnLevelMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string title = 1; */
        if (message.title !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.title);
        /* string text = 2; */
        if (message.text !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.text);
        /* int32 buttons = 3; */
        if (message.buttons !== 0)
            writer.tag(3, WireType.Varint).int32(message.buttons);
        /* int32 duration = 4; */
        if (message.duration !== 0)
            writer.tag(4, WireType.Varint).int32(message.duration);
        /* int32 popup_id = 5; */
        if (message.popupId !== 0)
            writer.tag(5, WireType.Varint).int32(message.popupId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.OnLevelMessage
 */
export const OnLevelMessage = new OnLevelMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GMZoneRequest$Type extends MessageType<GMZoneRequest> {
    constructor() {
        super("eq.GMZoneRequest", [
            { no: 1, name: "charname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "zone_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "z", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "heading", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "success", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GMZoneRequest>): GMZoneRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.charname = "";
        message.zoneId = 0;
        message.x = 0;
        message.y = 0;
        message.z = 0;
        message.heading = 0;
        message.success = 0;
        if (value !== undefined)
            reflectionMergePartial<GMZoneRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GMZoneRequest): GMZoneRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string charname */ 1:
                    message.charname = reader.string();
                    break;
                case /* int32 zone_id */ 2:
                    message.zoneId = reader.int32();
                    break;
                case /* float x */ 3:
                    message.x = reader.float();
                    break;
                case /* float y */ 4:
                    message.y = reader.float();
                    break;
                case /* float z */ 5:
                    message.z = reader.float();
                    break;
                case /* float heading */ 6:
                    message.heading = reader.float();
                    break;
                case /* int32 success */ 7:
                    message.success = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GMZoneRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string charname = 1; */
        if (message.charname !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.charname);
        /* int32 zone_id = 2; */
        if (message.zoneId !== 0)
            writer.tag(2, WireType.Varint).int32(message.zoneId);
        /* float x = 3; */
        if (message.x !== 0)
            writer.tag(3, WireType.Bit32).float(message.x);
        /* float y = 4; */
        if (message.y !== 0)
            writer.tag(4, WireType.Bit32).float(message.y);
        /* float z = 5; */
        if (message.z !== 0)
            writer.tag(5, WireType.Bit32).float(message.z);
        /* float heading = 6; */
        if (message.heading !== 0)
            writer.tag(6, WireType.Bit32).float(message.heading);
        /* int32 success = 7; */
        if (message.success !== 0)
            writer.tag(7, WireType.Varint).int32(message.success);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.GMZoneRequest
 */
export const GMZoneRequest = new GMZoneRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GMSummon$Type extends MessageType<GMSummon> {
    constructor() {
        super("eq.GMSummon", [
            { no: 1, name: "charname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "gmname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "success", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "zone_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "y", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "x", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "z", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GMSummon>): GMSummon {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.charname = "";
        message.gmname = "";
        message.success = 0;
        message.zoneId = 0;
        message.y = 0;
        message.x = 0;
        message.z = 0;
        if (value !== undefined)
            reflectionMergePartial<GMSummon>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GMSummon): GMSummon {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string charname */ 1:
                    message.charname = reader.string();
                    break;
                case /* string gmname */ 2:
                    message.gmname = reader.string();
                    break;
                case /* int32 success */ 3:
                    message.success = reader.int32();
                    break;
                case /* int32 zone_id */ 4:
                    message.zoneId = reader.int32();
                    break;
                case /* int32 y */ 5:
                    message.y = reader.int32();
                    break;
                case /* int32 x */ 6:
                    message.x = reader.int32();
                    break;
                case /* int32 z */ 7:
                    message.z = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GMSummon, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string charname = 1; */
        if (message.charname !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.charname);
        /* string gmname = 2; */
        if (message.gmname !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.gmname);
        /* int32 success = 3; */
        if (message.success !== 0)
            writer.tag(3, WireType.Varint).int32(message.success);
        /* int32 zone_id = 4; */
        if (message.zoneId !== 0)
            writer.tag(4, WireType.Varint).int32(message.zoneId);
        /* int32 y = 5; */
        if (message.y !== 0)
            writer.tag(5, WireType.Varint).int32(message.y);
        /* int32 x = 6; */
        if (message.x !== 0)
            writer.tag(6, WireType.Varint).int32(message.x);
        /* int32 z = 7; */
        if (message.z !== 0)
            writer.tag(7, WireType.Varint).int32(message.z);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.GMSummon
 */
export const GMSummon = new GMSummon$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GMGoto$Type extends MessageType<GMGoto> {
    constructor() {
        super("eq.GMGoto", [
            { no: 1, name: "charname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "gmname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "success", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "zone_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "y", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "x", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "z", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GMGoto>): GMGoto {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.charname = "";
        message.gmname = "";
        message.success = 0;
        message.zoneId = 0;
        message.y = 0;
        message.x = 0;
        message.z = 0;
        if (value !== undefined)
            reflectionMergePartial<GMGoto>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GMGoto): GMGoto {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string charname */ 1:
                    message.charname = reader.string();
                    break;
                case /* string gmname */ 2:
                    message.gmname = reader.string();
                    break;
                case /* int32 success */ 3:
                    message.success = reader.int32();
                    break;
                case /* int32 zone_id */ 4:
                    message.zoneId = reader.int32();
                    break;
                case /* int32 y */ 5:
                    message.y = reader.int32();
                    break;
                case /* int32 x */ 6:
                    message.x = reader.int32();
                    break;
                case /* int32 z */ 7:
                    message.z = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GMGoto, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string charname = 1; */
        if (message.charname !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.charname);
        /* string gmname = 2; */
        if (message.gmname !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.gmname);
        /* int32 success = 3; */
        if (message.success !== 0)
            writer.tag(3, WireType.Varint).int32(message.success);
        /* int32 zone_id = 4; */
        if (message.zoneId !== 0)
            writer.tag(4, WireType.Varint).int32(message.zoneId);
        /* int32 y = 5; */
        if (message.y !== 0)
            writer.tag(5, WireType.Varint).int32(message.y);
        /* int32 x = 6; */
        if (message.x !== 0)
            writer.tag(6, WireType.Varint).int32(message.x);
        /* int32 z = 7; */
        if (message.z !== 0)
            writer.tag(7, WireType.Varint).int32(message.z);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.GMGoto
 */
export const GMGoto = new GMGoto$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GMLastName$Type extends MessageType<GMLastName> {
    constructor() {
        super("eq.GMLastName", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "gmname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "lastname", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GMLastName>): GMLastName {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.gmname = "";
        message.lastname = "";
        if (value !== undefined)
            reflectionMergePartial<GMLastName>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GMLastName): GMLastName {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string gmname */ 2:
                    message.gmname = reader.string();
                    break;
                case /* string lastname */ 3:
                    message.lastname = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GMLastName, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string gmname = 2; */
        if (message.gmname !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.gmname);
        /* string lastname = 3; */
        if (message.lastname !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.lastname);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.GMLastName
 */
export const GMLastName = new GMLastName$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CombatAbility$Type extends MessageType<CombatAbility> {
    constructor() {
        super("eq.CombatAbility", [
            { no: 1, name: "m_target", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "m_atk", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "m_skill", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CombatAbility>): CombatAbility {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mTarget = 0;
        message.mAtk = 0;
        message.mSkill = 0;
        if (value !== undefined)
            reflectionMergePartial<CombatAbility>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CombatAbility): CombatAbility {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 m_target */ 1:
                    message.mTarget = reader.int32();
                    break;
                case /* int32 m_atk */ 2:
                    message.mAtk = reader.int32();
                    break;
                case /* int32 m_skill */ 3:
                    message.mSkill = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CombatAbility, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 m_target = 1; */
        if (message.mTarget !== 0)
            writer.tag(1, WireType.Varint).int32(message.mTarget);
        /* int32 m_atk = 2; */
        if (message.mAtk !== 0)
            writer.tag(2, WireType.Varint).int32(message.mAtk);
        /* int32 m_skill = 3; */
        if (message.mSkill !== 0)
            writer.tag(3, WireType.Varint).int32(message.mSkill);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.CombatAbility
 */
export const CombatAbility = new CombatAbility$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Instill_Doubt$Type extends MessageType<Instill_Doubt> {
    constructor() {
        super("eq.Instill_Doubt", [
            { no: 1, name: "i_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "i_atk", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "i_type", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Instill_Doubt>): Instill_Doubt {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.iId = 0;
        message.iAtk = 0;
        message.iType = 0;
        if (value !== undefined)
            reflectionMergePartial<Instill_Doubt>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Instill_Doubt): Instill_Doubt {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 i_id */ 1:
                    message.iId = reader.int32();
                    break;
                case /* int32 i_atk */ 2:
                    message.iAtk = reader.int32();
                    break;
                case /* int32 i_type */ 3:
                    message.iType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Instill_Doubt, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 i_id = 1; */
        if (message.iId !== 0)
            writer.tag(1, WireType.Varint).int32(message.iId);
        /* int32 i_atk = 2; */
        if (message.iAtk !== 0)
            writer.tag(2, WireType.Varint).int32(message.iAtk);
        /* int32 i_type = 3; */
        if (message.iType !== 0)
            writer.tag(3, WireType.Varint).int32(message.iType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Instill_Doubt
 */
export const Instill_Doubt = new Instill_Doubt$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GiveItem$Type extends MessageType<GiveItem> {
    constructor() {
        super("eq.GiveItem", [
            { no: 1, name: "to_entity", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "to_equip_slot", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "from_entity", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "from_equip_slot", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GiveItem>): GiveItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.toEntity = 0;
        message.toEquipSlot = 0;
        message.fromEntity = 0;
        message.fromEquipSlot = 0;
        if (value !== undefined)
            reflectionMergePartial<GiveItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GiveItem): GiveItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 to_entity */ 1:
                    message.toEntity = reader.int32();
                    break;
                case /* int32 to_equip_slot */ 2:
                    message.toEquipSlot = reader.int32();
                    break;
                case /* int32 from_entity */ 3:
                    message.fromEntity = reader.int32();
                    break;
                case /* int32 from_equip_slot */ 4:
                    message.fromEquipSlot = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GiveItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 to_entity = 1; */
        if (message.toEntity !== 0)
            writer.tag(1, WireType.Varint).int32(message.toEntity);
        /* int32 to_equip_slot = 2; */
        if (message.toEquipSlot !== 0)
            writer.tag(2, WireType.Varint).int32(message.toEquipSlot);
        /* int32 from_entity = 3; */
        if (message.fromEntity !== 0)
            writer.tag(3, WireType.Varint).int32(message.fromEntity);
        /* int32 from_equip_slot = 4; */
        if (message.fromEquipSlot !== 0)
            writer.tag(4, WireType.Varint).int32(message.fromEquipSlot);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.GiveItem
 */
export const GiveItem = new GiveItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RandomReq$Type extends MessageType<RandomReq> {
    constructor() {
        super("eq.RandomReq", [
            { no: 1, name: "low", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "high", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<RandomReq>): RandomReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.low = 0;
        message.high = 0;
        if (value !== undefined)
            reflectionMergePartial<RandomReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RandomReq): RandomReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 low */ 1:
                    message.low = reader.int32();
                    break;
                case /* int32 high */ 2:
                    message.high = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RandomReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 low = 1; */
        if (message.low !== 0)
            writer.tag(1, WireType.Varint).int32(message.low);
        /* int32 high = 2; */
        if (message.high !== 0)
            writer.tag(2, WireType.Varint).int32(message.high);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.RandomReq
 */
export const RandomReq = new RandomReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RandomReply$Type extends MessageType<RandomReply> {
    constructor() {
        super("eq.RandomReply", [
            { no: 1, name: "low", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "high", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "result", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RandomReply>): RandomReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.low = 0;
        message.high = 0;
        message.result = 0;
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<RandomReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RandomReply): RandomReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 low */ 1:
                    message.low = reader.int32();
                    break;
                case /* int32 high */ 2:
                    message.high = reader.int32();
                    break;
                case /* int32 result */ 3:
                    message.result = reader.int32();
                    break;
                case /* string name */ 4:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RandomReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 low = 1; */
        if (message.low !== 0)
            writer.tag(1, WireType.Varint).int32(message.low);
        /* int32 high = 2; */
        if (message.high !== 0)
            writer.tag(2, WireType.Varint).int32(message.high);
        /* int32 result = 3; */
        if (message.result !== 0)
            writer.tag(3, WireType.Varint).int32(message.result);
        /* string name = 4; */
        if (message.name !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.RandomReply
 */
export const RandomReply = new RandomReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LFG$Type extends MessageType<LFG> {
    constructor() {
        super("eq.LFG", [
            { no: 1, name: "value", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LFG>): LFG {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = 0;
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<LFG>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LFG): LFG {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 value */ 1:
                    message.value = reader.int32();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LFG, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 value = 1; */
        if (message.value !== 0)
            writer.tag(1, WireType.Varint).int32(message.value);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.LFG
 */
export const LFG = new LFG$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LFG_Appearance$Type extends MessageType<LFG_Appearance> {
    constructor() {
        super("eq.LFG_Appearance", [
            { no: 1, name: "spawn_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "lfg", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<LFG_Appearance>): LFG_Appearance {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.spawnId = 0;
        message.lfg = 0;
        if (value !== undefined)
            reflectionMergePartial<LFG_Appearance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LFG_Appearance): LFG_Appearance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 spawn_id */ 1:
                    message.spawnId = reader.int32();
                    break;
                case /* int32 lfg */ 2:
                    message.lfg = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LFG_Appearance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 spawn_id = 1; */
        if (message.spawnId !== 0)
            writer.tag(1, WireType.Varint).int32(message.spawnId);
        /* int32 lfg = 2; */
        if (message.lfg !== 0)
            writer.tag(2, WireType.Varint).int32(message.lfg);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.LFG_Appearance
 */
export const LFG_Appearance = new LFG_Appearance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TimeOfDay$Type extends MessageType<TimeOfDay> {
    constructor() {
        super("eq.TimeOfDay", [
            { no: 1, name: "hour", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "minute", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "day", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "month", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "year", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TimeOfDay>): TimeOfDay {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hour = 0;
        message.minute = 0;
        message.day = 0;
        message.month = 0;
        message.year = 0;
        if (value !== undefined)
            reflectionMergePartial<TimeOfDay>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TimeOfDay): TimeOfDay {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 hour */ 1:
                    message.hour = reader.int32();
                    break;
                case /* int32 minute */ 2:
                    message.minute = reader.int32();
                    break;
                case /* int32 day */ 3:
                    message.day = reader.int32();
                    break;
                case /* int32 month */ 4:
                    message.month = reader.int32();
                    break;
                case /* int32 year */ 5:
                    message.year = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TimeOfDay, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 hour = 1; */
        if (message.hour !== 0)
            writer.tag(1, WireType.Varint).int32(message.hour);
        /* int32 minute = 2; */
        if (message.minute !== 0)
            writer.tag(2, WireType.Varint).int32(message.minute);
        /* int32 day = 3; */
        if (message.day !== 0)
            writer.tag(3, WireType.Varint).int32(message.day);
        /* int32 month = 4; */
        if (message.month !== 0)
            writer.tag(4, WireType.Varint).int32(message.month);
        /* int32 year = 5; */
        if (message.year !== 0)
            writer.tag(5, WireType.Varint).int32(message.year);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.TimeOfDay
 */
export const TimeOfDay = new TimeOfDay$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Merchant_Click$Type extends MessageType<Merchant_Click> {
    constructor() {
        super("eq.Merchant_Click", [
            { no: 1, name: "npcid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "playerid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "command", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "rate", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Merchant_Click>): Merchant_Click {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.npcid = 0;
        message.playerid = 0;
        message.command = 0;
        message.rate = 0;
        if (value !== undefined)
            reflectionMergePartial<Merchant_Click>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Merchant_Click): Merchant_Click {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 npcid */ 1:
                    message.npcid = reader.int32();
                    break;
                case /* int32 playerid */ 2:
                    message.playerid = reader.int32();
                    break;
                case /* int32 command */ 3:
                    message.command = reader.int32();
                    break;
                case /* float rate */ 4:
                    message.rate = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Merchant_Click, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 npcid = 1; */
        if (message.npcid !== 0)
            writer.tag(1, WireType.Varint).int32(message.npcid);
        /* int32 playerid = 2; */
        if (message.playerid !== 0)
            writer.tag(2, WireType.Varint).int32(message.playerid);
        /* int32 command = 3; */
        if (message.command !== 0)
            writer.tag(3, WireType.Varint).int32(message.command);
        /* float rate = 4; */
        if (message.rate !== 0)
            writer.tag(4, WireType.Bit32).float(message.rate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Merchant_Click
 */
export const Merchant_Click = new Merchant_Click$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Merchant_Sell$Type extends MessageType<Merchant_Sell> {
    constructor() {
        super("eq.Merchant_Sell", [
            { no: 1, name: "npcid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "playerid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "itemslot", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "quantity", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "price", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Merchant_Sell>): Merchant_Sell {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.npcid = 0;
        message.playerid = 0;
        message.itemslot = 0;
        message.quantity = 0;
        message.price = 0;
        if (value !== undefined)
            reflectionMergePartial<Merchant_Sell>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Merchant_Sell): Merchant_Sell {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 npcid */ 1:
                    message.npcid = reader.int32();
                    break;
                case /* int32 playerid */ 2:
                    message.playerid = reader.int32();
                    break;
                case /* int32 itemslot */ 3:
                    message.itemslot = reader.int32();
                    break;
                case /* int32 quantity */ 4:
                    message.quantity = reader.int32();
                    break;
                case /* int32 price */ 5:
                    message.price = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Merchant_Sell, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 npcid = 1; */
        if (message.npcid !== 0)
            writer.tag(1, WireType.Varint).int32(message.npcid);
        /* int32 playerid = 2; */
        if (message.playerid !== 0)
            writer.tag(2, WireType.Varint).int32(message.playerid);
        /* int32 itemslot = 3; */
        if (message.itemslot !== 0)
            writer.tag(3, WireType.Varint).int32(message.itemslot);
        /* int32 quantity = 4; */
        if (message.quantity !== 0)
            writer.tag(4, WireType.Varint).int32(message.quantity);
        /* int32 price = 5; */
        if (message.price !== 0)
            writer.tag(5, WireType.Varint).int32(message.price);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Merchant_Sell
 */
export const Merchant_Sell = new Merchant_Sell$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Merchant_Purchase$Type extends MessageType<Merchant_Purchase> {
    constructor() {
        super("eq.Merchant_Purchase", [
            { no: 1, name: "npcid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "itemslot", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "quantity", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "price", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Merchant_Purchase>): Merchant_Purchase {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.npcid = 0;
        message.itemslot = 0;
        message.quantity = 0;
        message.price = 0;
        if (value !== undefined)
            reflectionMergePartial<Merchant_Purchase>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Merchant_Purchase): Merchant_Purchase {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 npcid */ 1:
                    message.npcid = reader.int32();
                    break;
                case /* int32 itemslot */ 2:
                    message.itemslot = reader.int32();
                    break;
                case /* int32 quantity */ 3:
                    message.quantity = reader.int32();
                    break;
                case /* int32 price */ 4:
                    message.price = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Merchant_Purchase, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 npcid = 1; */
        if (message.npcid !== 0)
            writer.tag(1, WireType.Varint).int32(message.npcid);
        /* int32 itemslot = 2; */
        if (message.itemslot !== 0)
            writer.tag(2, WireType.Varint).int32(message.itemslot);
        /* int32 quantity = 3; */
        if (message.quantity !== 0)
            writer.tag(3, WireType.Varint).int32(message.quantity);
        /* int32 price = 4; */
        if (message.price !== 0)
            writer.tag(4, WireType.Varint).int32(message.price);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Merchant_Purchase
 */
export const Merchant_Purchase = new Merchant_Purchase$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Merchant_DelItem$Type extends MessageType<Merchant_DelItem> {
    constructor() {
        super("eq.Merchant_DelItem", [
            { no: 1, name: "npcid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "playerid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "itemslot", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Merchant_DelItem>): Merchant_DelItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.npcid = 0;
        message.playerid = 0;
        message.itemslot = 0;
        if (value !== undefined)
            reflectionMergePartial<Merchant_DelItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Merchant_DelItem): Merchant_DelItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 npcid */ 1:
                    message.npcid = reader.int32();
                    break;
                case /* int32 playerid */ 2:
                    message.playerid = reader.int32();
                    break;
                case /* int32 itemslot */ 3:
                    message.itemslot = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Merchant_DelItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 npcid = 1; */
        if (message.npcid !== 0)
            writer.tag(1, WireType.Varint).int32(message.npcid);
        /* int32 playerid = 2; */
        if (message.playerid !== 0)
            writer.tag(2, WireType.Varint).int32(message.playerid);
        /* int32 itemslot = 3; */
        if (message.itemslot !== 0)
            writer.tag(3, WireType.Varint).int32(message.itemslot);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Merchant_DelItem
 */
export const Merchant_DelItem = new Merchant_DelItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Adventure_Purchase$Type extends MessageType<Adventure_Purchase> {
    constructor() {
        super("eq.Adventure_Purchase", [
            { no: 1, name: "some_flag", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "npcid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "itemid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "variable", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Adventure_Purchase>): Adventure_Purchase {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.someFlag = 0;
        message.npcid = 0;
        message.itemid = 0;
        message.variable = 0;
        if (value !== undefined)
            reflectionMergePartial<Adventure_Purchase>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Adventure_Purchase): Adventure_Purchase {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 some_flag */ 1:
                    message.someFlag = reader.int32();
                    break;
                case /* int32 npcid */ 2:
                    message.npcid = reader.int32();
                    break;
                case /* int32 itemid */ 3:
                    message.itemid = reader.int32();
                    break;
                case /* int32 variable */ 4:
                    message.variable = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Adventure_Purchase, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 some_flag = 1; */
        if (message.someFlag !== 0)
            writer.tag(1, WireType.Varint).int32(message.someFlag);
        /* int32 npcid = 2; */
        if (message.npcid !== 0)
            writer.tag(2, WireType.Varint).int32(message.npcid);
        /* int32 itemid = 3; */
        if (message.itemid !== 0)
            writer.tag(3, WireType.Varint).int32(message.itemid);
        /* int32 variable = 4; */
        if (message.variable !== 0)
            writer.tag(4, WireType.Varint).int32(message.variable);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Adventure_Purchase
 */
export const Adventure_Purchase = new Adventure_Purchase$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Adventure_Sell$Type extends MessageType<Adventure_Sell> {
    constructor() {
        super("eq.Adventure_Sell", [
            { no: 1, name: "npcid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "slot", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "charges", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "sell_price", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Adventure_Sell>): Adventure_Sell {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.npcid = 0;
        message.slot = 0;
        message.charges = 0;
        message.sellPrice = 0;
        if (value !== undefined)
            reflectionMergePartial<Adventure_Sell>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Adventure_Sell): Adventure_Sell {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 npcid */ 1:
                    message.npcid = reader.int32();
                    break;
                case /* int32 slot */ 2:
                    message.slot = reader.int32();
                    break;
                case /* int32 charges */ 3:
                    message.charges = reader.int32();
                    break;
                case /* int32 sell_price */ 4:
                    message.sellPrice = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Adventure_Sell, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 npcid = 1; */
        if (message.npcid !== 0)
            writer.tag(1, WireType.Varint).int32(message.npcid);
        /* int32 slot = 2; */
        if (message.slot !== 0)
            writer.tag(2, WireType.Varint).int32(message.slot);
        /* int32 charges = 3; */
        if (message.charges !== 0)
            writer.tag(3, WireType.Varint).int32(message.charges);
        /* int32 sell_price = 4; */
        if (message.sellPrice !== 0)
            writer.tag(4, WireType.Varint).int32(message.sellPrice);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Adventure_Sell
 */
export const Adventure_Sell = new Adventure_Sell$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventurePoints_Update$Type extends MessageType<AdventurePoints_Update> {
    constructor() {
        super("eq.AdventurePoints_Update", [
            { no: 1, name: "ldon_available_points", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "unkown_apu", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "ldon_guk_points", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "ldon_mirugal_points", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "ldon_mistmoore_points", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "ldon_rujarkian_points", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "ldon_takish_points", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AdventurePoints_Update>): AdventurePoints_Update {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ldonAvailablePoints = 0;
        message.unkownApu = [];
        message.ldonGukPoints = 0;
        message.ldonMirugalPoints = 0;
        message.ldonMistmoorePoints = 0;
        message.ldonRujarkianPoints = 0;
        message.ldonTakishPoints = 0;
        if (value !== undefined)
            reflectionMergePartial<AdventurePoints_Update>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventurePoints_Update): AdventurePoints_Update {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 ldon_available_points */ 1:
                    message.ldonAvailablePoints = reader.int32();
                    break;
                case /* repeated int32 unkown_apu */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.unkownApu.push(reader.int32());
                    else
                        message.unkownApu.push(reader.int32());
                    break;
                case /* int32 ldon_guk_points */ 3:
                    message.ldonGukPoints = reader.int32();
                    break;
                case /* int32 ldon_mirugal_points */ 4:
                    message.ldonMirugalPoints = reader.int32();
                    break;
                case /* int32 ldon_mistmoore_points */ 5:
                    message.ldonMistmoorePoints = reader.int32();
                    break;
                case /* int32 ldon_rujarkian_points */ 6:
                    message.ldonRujarkianPoints = reader.int32();
                    break;
                case /* int32 ldon_takish_points */ 7:
                    message.ldonTakishPoints = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdventurePoints_Update, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 ldon_available_points = 1; */
        if (message.ldonAvailablePoints !== 0)
            writer.tag(1, WireType.Varint).int32(message.ldonAvailablePoints);
        /* repeated int32 unkown_apu = 2; */
        if (message.unkownApu.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.unkownApu.length; i++)
                writer.int32(message.unkownApu[i]);
            writer.join();
        }
        /* int32 ldon_guk_points = 3; */
        if (message.ldonGukPoints !== 0)
            writer.tag(3, WireType.Varint).int32(message.ldonGukPoints);
        /* int32 ldon_mirugal_points = 4; */
        if (message.ldonMirugalPoints !== 0)
            writer.tag(4, WireType.Varint).int32(message.ldonMirugalPoints);
        /* int32 ldon_mistmoore_points = 5; */
        if (message.ldonMistmoorePoints !== 0)
            writer.tag(5, WireType.Varint).int32(message.ldonMistmoorePoints);
        /* int32 ldon_rujarkian_points = 6; */
        if (message.ldonRujarkianPoints !== 0)
            writer.tag(6, WireType.Varint).int32(message.ldonRujarkianPoints);
        /* int32 ldon_takish_points = 7; */
        if (message.ldonTakishPoints !== 0)
            writer.tag(7, WireType.Varint).int32(message.ldonTakishPoints);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.AdventurePoints_Update
 */
export const AdventurePoints_Update = new AdventurePoints_Update$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventureFinish$Type extends MessageType<AdventureFinish> {
    constructor() {
        super("eq.AdventureFinish", [
            { no: 1, name: "win_lose", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "points", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AdventureFinish>): AdventureFinish {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.winLose = 0;
        message.points = 0;
        if (value !== undefined)
            reflectionMergePartial<AdventureFinish>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureFinish): AdventureFinish {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 win_lose */ 1:
                    message.winLose = reader.int32();
                    break;
                case /* int32 points */ 2:
                    message.points = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdventureFinish, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 win_lose = 1; */
        if (message.winLose !== 0)
            writer.tag(1, WireType.Varint).int32(message.winLose);
        /* int32 points = 2; */
        if (message.points !== 0)
            writer.tag(2, WireType.Varint).int32(message.points);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.AdventureFinish
 */
export const AdventureFinish = new AdventureFinish$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventureRequest$Type extends MessageType<AdventureRequest> {
    constructor() {
        super("eq.AdventureRequest", [
            { no: 1, name: "risk", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "entity_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AdventureRequest>): AdventureRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.risk = 0;
        message.entityId = 0;
        if (value !== undefined)
            reflectionMergePartial<AdventureRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureRequest): AdventureRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 risk */ 1:
                    message.risk = reader.int32();
                    break;
                case /* int32 entity_id */ 2:
                    message.entityId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdventureRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 risk = 1; */
        if (message.risk !== 0)
            writer.tag(1, WireType.Varint).int32(message.risk);
        /* int32 entity_id = 2; */
        if (message.entityId !== 0)
            writer.tag(2, WireType.Varint).int32(message.entityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.AdventureRequest
 */
export const AdventureRequest = new AdventureRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventureRequestResponse$Type extends MessageType<AdventureRequestResponse> {
    constructor() {
        super("eq.AdventureRequestResponse", [
            { no: 1, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "timetoenter", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "timeleft", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "risk", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "z", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "showcompass", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AdventureRequestResponse>): AdventureRequestResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.text = "";
        message.timetoenter = 0;
        message.timeleft = 0;
        message.risk = 0;
        message.x = 0;
        message.y = 0;
        message.z = 0;
        message.showcompass = 0;
        if (value !== undefined)
            reflectionMergePartial<AdventureRequestResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureRequestResponse): AdventureRequestResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string text */ 1:
                    message.text = reader.string();
                    break;
                case /* int32 timetoenter */ 2:
                    message.timetoenter = reader.int32();
                    break;
                case /* int32 timeleft */ 3:
                    message.timeleft = reader.int32();
                    break;
                case /* int32 risk */ 4:
                    message.risk = reader.int32();
                    break;
                case /* float x */ 5:
                    message.x = reader.float();
                    break;
                case /* float y */ 6:
                    message.y = reader.float();
                    break;
                case /* float z */ 7:
                    message.z = reader.float();
                    break;
                case /* int32 showcompass */ 8:
                    message.showcompass = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdventureRequestResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string text = 1; */
        if (message.text !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.text);
        /* int32 timetoenter = 2; */
        if (message.timetoenter !== 0)
            writer.tag(2, WireType.Varint).int32(message.timetoenter);
        /* int32 timeleft = 3; */
        if (message.timeleft !== 0)
            writer.tag(3, WireType.Varint).int32(message.timeleft);
        /* int32 risk = 4; */
        if (message.risk !== 0)
            writer.tag(4, WireType.Varint).int32(message.risk);
        /* float x = 5; */
        if (message.x !== 0)
            writer.tag(5, WireType.Bit32).float(message.x);
        /* float y = 6; */
        if (message.y !== 0)
            writer.tag(6, WireType.Bit32).float(message.y);
        /* float z = 7; */
        if (message.z !== 0)
            writer.tag(7, WireType.Bit32).float(message.z);
        /* int32 showcompass = 8; */
        if (message.showcompass !== 0)
            writer.tag(8, WireType.Varint).int32(message.showcompass);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.AdventureRequestResponse
 */
export const AdventureRequestResponse = new AdventureRequestResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Illusion$Type extends MessageType<Illusion> {
    constructor() {
        super("eq.Illusion", [
            { no: 1, name: "spawnid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "charname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "race", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "gender", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "texture", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "helmtexture", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "face", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "hairstyle", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "haircolor", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "beard", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "beardcolor", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "size", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Illusion>): Illusion {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.spawnid = 0;
        message.charname = "";
        message.race = 0;
        message.gender = 0;
        message.texture = 0;
        message.helmtexture = 0;
        message.face = 0;
        message.hairstyle = 0;
        message.haircolor = 0;
        message.beard = 0;
        message.beardcolor = 0;
        message.size = 0;
        if (value !== undefined)
            reflectionMergePartial<Illusion>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Illusion): Illusion {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 spawnid */ 1:
                    message.spawnid = reader.int32();
                    break;
                case /* string charname */ 2:
                    message.charname = reader.string();
                    break;
                case /* int32 race */ 3:
                    message.race = reader.int32();
                    break;
                case /* int32 gender */ 4:
                    message.gender = reader.int32();
                    break;
                case /* int32 texture */ 5:
                    message.texture = reader.int32();
                    break;
                case /* int32 helmtexture */ 6:
                    message.helmtexture = reader.int32();
                    break;
                case /* int32 face */ 7:
                    message.face = reader.int32();
                    break;
                case /* int32 hairstyle */ 8:
                    message.hairstyle = reader.int32();
                    break;
                case /* int32 haircolor */ 9:
                    message.haircolor = reader.int32();
                    break;
                case /* int32 beard */ 10:
                    message.beard = reader.int32();
                    break;
                case /* int32 beardcolor */ 11:
                    message.beardcolor = reader.int32();
                    break;
                case /* float size */ 12:
                    message.size = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Illusion, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 spawnid = 1; */
        if (message.spawnid !== 0)
            writer.tag(1, WireType.Varint).int32(message.spawnid);
        /* string charname = 2; */
        if (message.charname !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.charname);
        /* int32 race = 3; */
        if (message.race !== 0)
            writer.tag(3, WireType.Varint).int32(message.race);
        /* int32 gender = 4; */
        if (message.gender !== 0)
            writer.tag(4, WireType.Varint).int32(message.gender);
        /* int32 texture = 5; */
        if (message.texture !== 0)
            writer.tag(5, WireType.Varint).int32(message.texture);
        /* int32 helmtexture = 6; */
        if (message.helmtexture !== 0)
            writer.tag(6, WireType.Varint).int32(message.helmtexture);
        /* int32 face = 7; */
        if (message.face !== 0)
            writer.tag(7, WireType.Varint).int32(message.face);
        /* int32 hairstyle = 8; */
        if (message.hairstyle !== 0)
            writer.tag(8, WireType.Varint).int32(message.hairstyle);
        /* int32 haircolor = 9; */
        if (message.haircolor !== 0)
            writer.tag(9, WireType.Varint).int32(message.haircolor);
        /* int32 beard = 10; */
        if (message.beard !== 0)
            writer.tag(10, WireType.Varint).int32(message.beard);
        /* int32 beardcolor = 11; */
        if (message.beardcolor !== 0)
            writer.tag(11, WireType.Varint).int32(message.beardcolor);
        /* float size = 12; */
        if (message.size !== 0)
            writer.tag(12, WireType.Bit32).float(message.size);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Illusion
 */
export const Illusion = new Illusion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ZonePoint_Entry$Type extends MessageType<ZonePoint_Entry> {
    constructor() {
        super("eq.ZonePoint_Entry", [
            { no: 1, name: "iterator", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "z", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "heading", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "zoneid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "zoneinstance", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ZonePoint_Entry>): ZonePoint_Entry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.iterator = 0;
        message.y = 0;
        message.x = 0;
        message.z = 0;
        message.heading = 0;
        message.zoneid = 0;
        message.zoneinstance = 0;
        if (value !== undefined)
            reflectionMergePartial<ZonePoint_Entry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ZonePoint_Entry): ZonePoint_Entry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 iterator */ 1:
                    message.iterator = reader.int32();
                    break;
                case /* float y */ 2:
                    message.y = reader.float();
                    break;
                case /* float x */ 3:
                    message.x = reader.float();
                    break;
                case /* float z */ 4:
                    message.z = reader.float();
                    break;
                case /* float heading */ 5:
                    message.heading = reader.float();
                    break;
                case /* int32 zoneid */ 6:
                    message.zoneid = reader.int32();
                    break;
                case /* int32 zoneinstance */ 7:
                    message.zoneinstance = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ZonePoint_Entry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 iterator = 1; */
        if (message.iterator !== 0)
            writer.tag(1, WireType.Varint).int32(message.iterator);
        /* float y = 2; */
        if (message.y !== 0)
            writer.tag(2, WireType.Bit32).float(message.y);
        /* float x = 3; */
        if (message.x !== 0)
            writer.tag(3, WireType.Bit32).float(message.x);
        /* float z = 4; */
        if (message.z !== 0)
            writer.tag(4, WireType.Bit32).float(message.z);
        /* float heading = 5; */
        if (message.heading !== 0)
            writer.tag(5, WireType.Bit32).float(message.heading);
        /* int32 zoneid = 6; */
        if (message.zoneid !== 0)
            writer.tag(6, WireType.Varint).int32(message.zoneid);
        /* int32 zoneinstance = 7; */
        if (message.zoneinstance !== 0)
            writer.tag(7, WireType.Varint).int32(message.zoneinstance);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.ZonePoint_Entry
 */
export const ZonePoint_Entry = new ZonePoint_Entry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ZonePoints$Type extends MessageType<ZonePoints> {
    constructor() {
        super("eq.ZonePoints", [
            { no: 1, name: "count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "zpe", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ZonePoint_Entry }
        ]);
    }
    create(value?: PartialMessage<ZonePoints>): ZonePoints {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.count = 0;
        message.zpe = [];
        if (value !== undefined)
            reflectionMergePartial<ZonePoints>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ZonePoints): ZonePoints {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 count */ 1:
                    message.count = reader.int32();
                    break;
                case /* repeated eq.ZonePoint_Entry zpe */ 2:
                    message.zpe.push(ZonePoint_Entry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ZonePoints, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 count = 1; */
        if (message.count !== 0)
            writer.tag(1, WireType.Varint).int32(message.count);
        /* repeated eq.ZonePoint_Entry zpe = 2; */
        for (let i = 0; i < message.zpe.length; i++)
            ZonePoint_Entry.internalBinaryWrite(message.zpe[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.ZonePoints
 */
export const ZonePoints = new ZonePoints$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SkillUpdate$Type extends MessageType<SkillUpdate> {
    constructor() {
        super("eq.SkillUpdate", [
            { no: 1, name: "skill_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "value", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SkillUpdate>): SkillUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.skillId = 0;
        message.value = 0;
        if (value !== undefined)
            reflectionMergePartial<SkillUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SkillUpdate): SkillUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 skill_id */ 1:
                    message.skillId = reader.int32();
                    break;
                case /* int32 value */ 2:
                    message.value = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SkillUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 skill_id = 1; */
        if (message.skillId !== 0)
            writer.tag(1, WireType.Varint).int32(message.skillId);
        /* int32 value = 2; */
        if (message.value !== 0)
            writer.tag(2, WireType.Varint).int32(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.SkillUpdate
 */
export const SkillUpdate = new SkillUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ZoneUnavail$Type extends MessageType<ZoneUnavail> {
    constructor() {
        super("eq.ZoneUnavail", [
            { no: 1, name: "zonename", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ZoneUnavail>): ZoneUnavail {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.zonename = "";
        if (value !== undefined)
            reflectionMergePartial<ZoneUnavail>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ZoneUnavail): ZoneUnavail {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string zonename */ 1:
                    message.zonename = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ZoneUnavail, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string zonename = 1; */
        if (message.zonename !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.zonename);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.ZoneUnavail
 */
export const ZoneUnavail = new ZoneUnavail$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroupGeneric$Type extends MessageType<GroupGeneric> {
    constructor() {
        super("eq.GroupGeneric", [
            { no: 1, name: "name1", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name2", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GroupGeneric>): GroupGeneric {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name1 = "";
        message.name2 = "";
        if (value !== undefined)
            reflectionMergePartial<GroupGeneric>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GroupGeneric): GroupGeneric {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name1 */ 1:
                    message.name1 = reader.string();
                    break;
                case /* string name2 */ 2:
                    message.name2 = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GroupGeneric, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name1 = 1; */
        if (message.name1 !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name1);
        /* string name2 = 2; */
        if (message.name2 !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name2);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.GroupGeneric
 */
export const GroupGeneric = new GroupGeneric$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroupCancel$Type extends MessageType<GroupCancel> {
    constructor() {
        super("eq.GroupCancel", [
            { no: 1, name: "name1", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name2", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "toggle", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GroupCancel>): GroupCancel {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name1 = "";
        message.name2 = "";
        message.toggle = 0;
        if (value !== undefined)
            reflectionMergePartial<GroupCancel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GroupCancel): GroupCancel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name1 */ 1:
                    message.name1 = reader.string();
                    break;
                case /* string name2 */ 2:
                    message.name2 = reader.string();
                    break;
                case /* int32 toggle */ 3:
                    message.toggle = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GroupCancel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name1 = 1; */
        if (message.name1 !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name1);
        /* string name2 = 2; */
        if (message.name2 !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name2);
        /* int32 toggle = 3; */
        if (message.toggle !== 0)
            writer.tag(3, WireType.Varint).int32(message.toggle);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.GroupCancel
 */
export const GroupCancel = new GroupCancel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroupUpdate$Type extends MessageType<GroupUpdate> {
    constructor() {
        super("eq.GroupUpdate", [
            { no: 1, name: "action", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "yourname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "membername", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => StringList },
            { no: 4, name: "leadersname", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GroupUpdate>): GroupUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.action = 0;
        message.yourname = "";
        message.membername = [];
        message.leadersname = "";
        if (value !== undefined)
            reflectionMergePartial<GroupUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GroupUpdate): GroupUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 action */ 1:
                    message.action = reader.int32();
                    break;
                case /* string yourname */ 2:
                    message.yourname = reader.string();
                    break;
                case /* repeated eq.StringList membername */ 3:
                    message.membername.push(StringList.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string leadersname */ 4:
                    message.leadersname = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GroupUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 action = 1; */
        if (message.action !== 0)
            writer.tag(1, WireType.Varint).int32(message.action);
        /* string yourname = 2; */
        if (message.yourname !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.yourname);
        /* repeated eq.StringList membername = 3; */
        for (let i = 0; i < message.membername.length; i++)
            StringList.internalBinaryWrite(message.membername[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string leadersname = 4; */
        if (message.leadersname !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.leadersname);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.GroupUpdate
 */
export const GroupUpdate = new GroupUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroupUpdate2$Type extends MessageType<GroupUpdate2> {
    constructor() {
        super("eq.GroupUpdate2", [
            { no: 1, name: "action", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "yourname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "membername", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => StringList },
            { no: 4, name: "leadersname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "leader_aas", kind: "message", T: () => GroupLeadershipAA }
        ]);
    }
    create(value?: PartialMessage<GroupUpdate2>): GroupUpdate2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.action = 0;
        message.yourname = "";
        message.membername = [];
        message.leadersname = "";
        if (value !== undefined)
            reflectionMergePartial<GroupUpdate2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GroupUpdate2): GroupUpdate2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 action */ 1:
                    message.action = reader.int32();
                    break;
                case /* string yourname */ 2:
                    message.yourname = reader.string();
                    break;
                case /* repeated eq.StringList membername */ 3:
                    message.membername.push(StringList.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string leadersname */ 4:
                    message.leadersname = reader.string();
                    break;
                case /* eq.GroupLeadershipAA leader_aas */ 5:
                    message.leaderAas = GroupLeadershipAA.internalBinaryRead(reader, reader.uint32(), options, message.leaderAas);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GroupUpdate2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 action = 1; */
        if (message.action !== 0)
            writer.tag(1, WireType.Varint).int32(message.action);
        /* string yourname = 2; */
        if (message.yourname !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.yourname);
        /* repeated eq.StringList membername = 3; */
        for (let i = 0; i < message.membername.length; i++)
            StringList.internalBinaryWrite(message.membername[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string leadersname = 4; */
        if (message.leadersname !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.leadersname);
        /* eq.GroupLeadershipAA leader_aas = 5; */
        if (message.leaderAas)
            GroupLeadershipAA.internalBinaryWrite(message.leaderAas, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.GroupUpdate2
 */
export const GroupUpdate2 = new GroupUpdate2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroupJoin$Type extends MessageType<GroupJoin> {
    constructor() {
        super("eq.GroupJoin", [
            { no: 1, name: "action", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "yourname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "membername", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GroupJoin>): GroupJoin {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.action = 0;
        message.yourname = "";
        message.membername = "";
        if (value !== undefined)
            reflectionMergePartial<GroupJoin>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GroupJoin): GroupJoin {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 action */ 1:
                    message.action = reader.int32();
                    break;
                case /* string yourname */ 2:
                    message.yourname = reader.string();
                    break;
                case /* string membername */ 3:
                    message.membername = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GroupJoin, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 action = 1; */
        if (message.action !== 0)
            writer.tag(1, WireType.Varint).int32(message.action);
        /* string yourname = 2; */
        if (message.yourname !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.yourname);
        /* string membername = 3; */
        if (message.membername !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.membername);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.GroupJoin
 */
export const GroupJoin = new GroupJoin$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FaceChange$Type extends MessageType<FaceChange> {
    constructor() {
        super("eq.FaceChange", [
            { no: 1, name: "haircolor", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "beardcolor", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "eyecolor1", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "eyecolor2", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "hairstyle", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "beard", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "face", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<FaceChange>): FaceChange {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.haircolor = 0;
        message.beardcolor = 0;
        message.eyecolor1 = 0;
        message.eyecolor2 = 0;
        message.hairstyle = 0;
        message.beard = 0;
        message.face = 0;
        if (value !== undefined)
            reflectionMergePartial<FaceChange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FaceChange): FaceChange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 haircolor */ 1:
                    message.haircolor = reader.int32();
                    break;
                case /* int32 beardcolor */ 2:
                    message.beardcolor = reader.int32();
                    break;
                case /* int32 eyecolor1 */ 3:
                    message.eyecolor1 = reader.int32();
                    break;
                case /* int32 eyecolor2 */ 4:
                    message.eyecolor2 = reader.int32();
                    break;
                case /* int32 hairstyle */ 5:
                    message.hairstyle = reader.int32();
                    break;
                case /* int32 beard */ 6:
                    message.beard = reader.int32();
                    break;
                case /* int32 face */ 7:
                    message.face = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FaceChange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 haircolor = 1; */
        if (message.haircolor !== 0)
            writer.tag(1, WireType.Varint).int32(message.haircolor);
        /* int32 beardcolor = 2; */
        if (message.beardcolor !== 0)
            writer.tag(2, WireType.Varint).int32(message.beardcolor);
        /* int32 eyecolor1 = 3; */
        if (message.eyecolor1 !== 0)
            writer.tag(3, WireType.Varint).int32(message.eyecolor1);
        /* int32 eyecolor2 = 4; */
        if (message.eyecolor2 !== 0)
            writer.tag(4, WireType.Varint).int32(message.eyecolor2);
        /* int32 hairstyle = 5; */
        if (message.hairstyle !== 0)
            writer.tag(5, WireType.Varint).int32(message.hairstyle);
        /* int32 beard = 6; */
        if (message.beard !== 0)
            writer.tag(6, WireType.Varint).int32(message.beard);
        /* int32 face = 7; */
        if (message.face !== 0)
            writer.tag(7, WireType.Varint).int32(message.face);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.FaceChange
 */
export const FaceChange = new FaceChange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradeRequest$Type extends MessageType<TradeRequest> {
    constructor() {
        super("eq.TradeRequest", [
            { no: 1, name: "to_mob_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "from_mob_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TradeRequest>): TradeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.toMobId = 0;
        message.fromMobId = 0;
        if (value !== undefined)
            reflectionMergePartial<TradeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradeRequest): TradeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 to_mob_id */ 1:
                    message.toMobId = reader.int32();
                    break;
                case /* int32 from_mob_id */ 2:
                    message.fromMobId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 to_mob_id = 1; */
        if (message.toMobId !== 0)
            writer.tag(1, WireType.Varint).int32(message.toMobId);
        /* int32 from_mob_id = 2; */
        if (message.fromMobId !== 0)
            writer.tag(2, WireType.Varint).int32(message.fromMobId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.TradeRequest
 */
export const TradeRequest = new TradeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradeAccept$Type extends MessageType<TradeAccept> {
    constructor() {
        super("eq.TradeAccept", [
            { no: 1, name: "from_mob_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TradeAccept>): TradeAccept {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fromMobId = 0;
        if (value !== undefined)
            reflectionMergePartial<TradeAccept>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradeAccept): TradeAccept {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 from_mob_id */ 1:
                    message.fromMobId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradeAccept, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 from_mob_id = 1; */
        if (message.fromMobId !== 0)
            writer.tag(1, WireType.Varint).int32(message.fromMobId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.TradeAccept
 */
export const TradeAccept = new TradeAccept$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CancelTrade$Type extends MessageType<CancelTrade> {
    constructor() {
        super("eq.CancelTrade", [
            { no: 1, name: "fromid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "action", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CancelTrade>): CancelTrade {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fromid = 0;
        message.action = 0;
        if (value !== undefined)
            reflectionMergePartial<CancelTrade>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CancelTrade): CancelTrade {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 fromid */ 1:
                    message.fromid = reader.int32();
                    break;
                case /* int32 action */ 2:
                    message.action = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CancelTrade, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 fromid = 1; */
        if (message.fromid !== 0)
            writer.tag(1, WireType.Varint).int32(message.fromid);
        /* int32 action = 2; */
        if (message.action !== 0)
            writer.tag(2, WireType.Varint).int32(message.action);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.CancelTrade
 */
export const CancelTrade = new CancelTrade$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PetitionUpdate$Type extends MessageType<PetitionUpdate> {
    constructor() {
        super("eq.PetitionUpdate", [
            { no: 1, name: "petnumber", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "color", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "status", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "senttime", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "accountid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "gmsenttoo", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "quetotal", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "charname", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PetitionUpdate>): PetitionUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.petnumber = 0;
        message.color = 0;
        message.status = 0;
        message.senttime = 0;
        message.accountid = "";
        message.gmsenttoo = "";
        message.quetotal = 0;
        message.charname = "";
        if (value !== undefined)
            reflectionMergePartial<PetitionUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PetitionUpdate): PetitionUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 petnumber */ 1:
                    message.petnumber = reader.int32();
                    break;
                case /* int32 color */ 2:
                    message.color = reader.int32();
                    break;
                case /* int32 status */ 3:
                    message.status = reader.int32();
                    break;
                case /* int32 senttime */ 4:
                    message.senttime = reader.int32();
                    break;
                case /* string accountid */ 5:
                    message.accountid = reader.string();
                    break;
                case /* string gmsenttoo */ 6:
                    message.gmsenttoo = reader.string();
                    break;
                case /* int32 quetotal */ 7:
                    message.quetotal = reader.int32();
                    break;
                case /* string charname */ 8:
                    message.charname = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PetitionUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 petnumber = 1; */
        if (message.petnumber !== 0)
            writer.tag(1, WireType.Varint).int32(message.petnumber);
        /* int32 color = 2; */
        if (message.color !== 0)
            writer.tag(2, WireType.Varint).int32(message.color);
        /* int32 status = 3; */
        if (message.status !== 0)
            writer.tag(3, WireType.Varint).int32(message.status);
        /* int32 senttime = 4; */
        if (message.senttime !== 0)
            writer.tag(4, WireType.Varint).int32(message.senttime);
        /* string accountid = 5; */
        if (message.accountid !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.accountid);
        /* string gmsenttoo = 6; */
        if (message.gmsenttoo !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.gmsenttoo);
        /* int32 quetotal = 7; */
        if (message.quetotal !== 0)
            writer.tag(7, WireType.Varint).int32(message.quetotal);
        /* string charname = 8; */
        if (message.charname !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.charname);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.PetitionUpdate
 */
export const PetitionUpdate = new PetitionUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Petition$Type extends MessageType<Petition> {
    constructor() {
        super("eq.Petition", [
            { no: 1, name: "petnumber", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "urgency", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "accountid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "lastgm", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "zone", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "charname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "charlevel", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "charclass", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "charrace", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "checkouts", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "unavail", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "senttime", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "petitiontext", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "gmtext", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Petition>): Petition {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.petnumber = 0;
        message.urgency = 0;
        message.accountid = "";
        message.lastgm = "";
        message.zone = 0;
        message.charname = "";
        message.charlevel = 0;
        message.charclass = 0;
        message.charrace = 0;
        message.checkouts = 0;
        message.unavail = 0;
        message.senttime = 0;
        message.petitiontext = "";
        message.gmtext = "";
        if (value !== undefined)
            reflectionMergePartial<Petition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Petition): Petition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 petnumber */ 1:
                    message.petnumber = reader.int32();
                    break;
                case /* int32 urgency */ 2:
                    message.urgency = reader.int32();
                    break;
                case /* string accountid */ 3:
                    message.accountid = reader.string();
                    break;
                case /* string lastgm */ 4:
                    message.lastgm = reader.string();
                    break;
                case /* int32 zone */ 5:
                    message.zone = reader.int32();
                    break;
                case /* string charname */ 6:
                    message.charname = reader.string();
                    break;
                case /* int32 charlevel */ 7:
                    message.charlevel = reader.int32();
                    break;
                case /* int32 charclass */ 8:
                    message.charclass = reader.int32();
                    break;
                case /* int32 charrace */ 9:
                    message.charrace = reader.int32();
                    break;
                case /* int32 checkouts */ 10:
                    message.checkouts = reader.int32();
                    break;
                case /* int32 unavail */ 11:
                    message.unavail = reader.int32();
                    break;
                case /* int32 senttime */ 12:
                    message.senttime = reader.int32();
                    break;
                case /* string petitiontext */ 13:
                    message.petitiontext = reader.string();
                    break;
                case /* string gmtext */ 14:
                    message.gmtext = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Petition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 petnumber = 1; */
        if (message.petnumber !== 0)
            writer.tag(1, WireType.Varint).int32(message.petnumber);
        /* int32 urgency = 2; */
        if (message.urgency !== 0)
            writer.tag(2, WireType.Varint).int32(message.urgency);
        /* string accountid = 3; */
        if (message.accountid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.accountid);
        /* string lastgm = 4; */
        if (message.lastgm !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.lastgm);
        /* int32 zone = 5; */
        if (message.zone !== 0)
            writer.tag(5, WireType.Varint).int32(message.zone);
        /* string charname = 6; */
        if (message.charname !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.charname);
        /* int32 charlevel = 7; */
        if (message.charlevel !== 0)
            writer.tag(7, WireType.Varint).int32(message.charlevel);
        /* int32 charclass = 8; */
        if (message.charclass !== 0)
            writer.tag(8, WireType.Varint).int32(message.charclass);
        /* int32 charrace = 9; */
        if (message.charrace !== 0)
            writer.tag(9, WireType.Varint).int32(message.charrace);
        /* int32 checkouts = 10; */
        if (message.checkouts !== 0)
            writer.tag(10, WireType.Varint).int32(message.checkouts);
        /* int32 unavail = 11; */
        if (message.unavail !== 0)
            writer.tag(11, WireType.Varint).int32(message.unavail);
        /* int32 senttime = 12; */
        if (message.senttime !== 0)
            writer.tag(12, WireType.Varint).int32(message.senttime);
        /* string petitiontext = 13; */
        if (message.petitiontext !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.petitiontext);
        /* string gmtext = 14; */
        if (message.gmtext !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.gmtext);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Petition
 */
export const Petition = new Petition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Who_All$Type extends MessageType<Who_All> {
    constructor() {
        super("eq.Who_All", [
            { no: 1, name: "whom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "wrace", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "wclass", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "lvllow", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "lvlhigh", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "gmlookup", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Who_All>): Who_All {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.whom = "";
        message.wrace = 0;
        message.wclass = 0;
        message.lvllow = 0;
        message.lvlhigh = 0;
        message.gmlookup = 0;
        if (value !== undefined)
            reflectionMergePartial<Who_All>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Who_All): Who_All {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string whom */ 1:
                    message.whom = reader.string();
                    break;
                case /* int32 wrace */ 2:
                    message.wrace = reader.int32();
                    break;
                case /* int32 wclass */ 3:
                    message.wclass = reader.int32();
                    break;
                case /* int32 lvllow */ 4:
                    message.lvllow = reader.int32();
                    break;
                case /* int32 lvlhigh */ 5:
                    message.lvlhigh = reader.int32();
                    break;
                case /* int32 gmlookup */ 6:
                    message.gmlookup = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Who_All, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string whom = 1; */
        if (message.whom !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.whom);
        /* int32 wrace = 2; */
        if (message.wrace !== 0)
            writer.tag(2, WireType.Varint).int32(message.wrace);
        /* int32 wclass = 3; */
        if (message.wclass !== 0)
            writer.tag(3, WireType.Varint).int32(message.wclass);
        /* int32 lvllow = 4; */
        if (message.lvllow !== 0)
            writer.tag(4, WireType.Varint).int32(message.lvllow);
        /* int32 lvlhigh = 5; */
        if (message.lvlhigh !== 0)
            writer.tag(5, WireType.Varint).int32(message.lvlhigh);
        /* int32 gmlookup = 6; */
        if (message.gmlookup !== 0)
            writer.tag(6, WireType.Varint).int32(message.gmlookup);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Who_All
 */
export const Who_All = new Who_All$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Stun$Type extends MessageType<Stun> {
    constructor() {
        super("eq.Stun", [
            { no: 1, name: "duration", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Stun>): Stun {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.duration = 0;
        if (value !== undefined)
            reflectionMergePartial<Stun>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Stun): Stun {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 duration */ 1:
                    message.duration = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Stun, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 duration = 1; */
        if (message.duration !== 0)
            writer.tag(1, WireType.Varint).int32(message.duration);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Stun
 */
export const Stun = new Stun$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AugmentItem$Type extends MessageType<AugmentItem> {
    constructor() {
        super("eq.AugmentItem", [
            { no: 1, name: "container_slot", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "augment_slot", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AugmentItem>): AugmentItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.containerSlot = 0;
        message.augmentSlot = 0;
        if (value !== undefined)
            reflectionMergePartial<AugmentItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AugmentItem): AugmentItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 container_slot */ 1:
                    message.containerSlot = reader.int32();
                    break;
                case /* int32 augment_slot */ 2:
                    message.augmentSlot = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AugmentItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 container_slot = 1; */
        if (message.containerSlot !== 0)
            writer.tag(1, WireType.Varint).int32(message.containerSlot);
        /* int32 augment_slot = 2; */
        if (message.augmentSlot !== 0)
            writer.tag(2, WireType.Varint).int32(message.augmentSlot);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.AugmentItem
 */
export const AugmentItem = new AugmentItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Emote$Type extends MessageType<Emote> {
    constructor() {
        super("eq.Emote", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Emote>): Emote {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<Emote>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Emote): Emote {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Emote, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Emote
 */
export const Emote = new Emote$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Inspect$Type extends MessageType<Inspect> {
    constructor() {
        super("eq.Inspect", [
            { no: 1, name: "target_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "player_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Inspect>): Inspect {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.targetId = 0;
        message.playerId = 0;
        if (value !== undefined)
            reflectionMergePartial<Inspect>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Inspect): Inspect {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 target_id */ 1:
                    message.targetId = reader.int32();
                    break;
                case /* int32 player_id */ 2:
                    message.playerId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Inspect, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 target_id = 1; */
        if (message.targetId !== 0)
            writer.tag(1, WireType.Varint).int32(message.targetId);
        /* int32 player_id = 2; */
        if (message.playerId !== 0)
            writer.tag(2, WireType.Varint).int32(message.playerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Inspect
 */
export const Inspect = new Inspect$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InspectResponse$Type extends MessageType<InspectResponse> {
    constructor() {
        super("eq.InspectResponse", [
            { no: 1, name: "target_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "playerid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "itemnames", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => StringList },
            { no: 4, name: "itemicons", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<InspectResponse>): InspectResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.targetId = 0;
        message.playerid = 0;
        message.itemnames = [];
        message.itemicons = [];
        message.text = "";
        if (value !== undefined)
            reflectionMergePartial<InspectResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InspectResponse): InspectResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 target_id */ 1:
                    message.targetId = reader.int32();
                    break;
                case /* int32 playerid */ 2:
                    message.playerid = reader.int32();
                    break;
                case /* repeated eq.StringList itemnames */ 3:
                    message.itemnames.push(StringList.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated int32 itemicons */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.itemicons.push(reader.int32());
                    else
                        message.itemicons.push(reader.int32());
                    break;
                case /* string text */ 5:
                    message.text = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InspectResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 target_id = 1; */
        if (message.targetId !== 0)
            writer.tag(1, WireType.Varint).int32(message.targetId);
        /* int32 playerid = 2; */
        if (message.playerid !== 0)
            writer.tag(2, WireType.Varint).int32(message.playerid);
        /* repeated eq.StringList itemnames = 3; */
        for (let i = 0; i < message.itemnames.length; i++)
            StringList.internalBinaryWrite(message.itemnames[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated int32 itemicons = 4; */
        if (message.itemicons.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.itemicons.length; i++)
                writer.int32(message.itemicons[i]);
            writer.join();
        }
        /* string text = 5; */
        if (message.text !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.text);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.InspectResponse
 */
export const InspectResponse = new InspectResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetDataRate$Type extends MessageType<SetDataRate> {
    constructor() {
        super("eq.SetDataRate", [
            { no: 1, name: "newdatarate", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<SetDataRate>): SetDataRate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.newdatarate = 0;
        if (value !== undefined)
            reflectionMergePartial<SetDataRate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetDataRate): SetDataRate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float newdatarate */ 1:
                    message.newdatarate = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetDataRate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float newdatarate = 1; */
        if (message.newdatarate !== 0)
            writer.tag(1, WireType.Bit32).float(message.newdatarate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.SetDataRate
 */
export const SetDataRate = new SetDataRate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetServerFilter$Type extends MessageType<SetServerFilter> {
    constructor() {
        super("eq.SetServerFilter", [
            { no: 1, name: "filters", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SetServerFilter>): SetServerFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.filters = [];
        if (value !== undefined)
            reflectionMergePartial<SetServerFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetServerFilter): SetServerFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 filters */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.filters.push(reader.int32());
                    else
                        message.filters.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetServerFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 filters = 1; */
        if (message.filters.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.filters.length; i++)
                writer.int32(message.filters[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.SetServerFilter
 */
export const SetServerFilter = new SetServerFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetServerFilterAck$Type extends MessageType<SetServerFilterAck> {
    constructor() {
        super("eq.SetServerFilterAck", [
            { no: 1, name: "blank", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SetServerFilterAck>): SetServerFilterAck {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.blank = [];
        if (value !== undefined)
            reflectionMergePartial<SetServerFilterAck>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetServerFilterAck): SetServerFilterAck {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 blank */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.blank.push(reader.int32());
                    else
                        message.blank.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetServerFilterAck, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 blank = 1; */
        if (message.blank.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.blank.length; i++)
                writer.int32(message.blank[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.SetServerFilterAck
 */
export const SetServerFilterAck = new SetServerFilterAck$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IncreaseStat$Type extends MessageType<IncreaseStat> {
    constructor() {
        super("eq.IncreaseStat", [
            { no: 1, name: "str", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "sta", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "agi", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "dex", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "int_", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "wis", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "cha", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "fire", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "cold", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "magic", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "poison", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "disease", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "str2", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "sta2", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "agi2", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 16, name: "dex2", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 17, name: "int2_", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 18, name: "wis2", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 19, name: "cha2", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 20, name: "fire2", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 21, name: "cold2", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 22, name: "magic2", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 23, name: "poison2", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 24, name: "disease2", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<IncreaseStat>): IncreaseStat {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.str = 0;
        message.sta = 0;
        message.agi = 0;
        message.dex = 0;
        message.int = 0;
        message.wis = 0;
        message.cha = 0;
        message.fire = 0;
        message.cold = 0;
        message.magic = 0;
        message.poison = 0;
        message.disease = 0;
        message.str2 = 0;
        message.sta2 = 0;
        message.agi2 = 0;
        message.dex2 = 0;
        message.int2 = 0;
        message.wis2 = 0;
        message.cha2 = 0;
        message.fire2 = 0;
        message.cold2 = 0;
        message.magic2 = 0;
        message.poison2 = 0;
        message.disease2 = 0;
        if (value !== undefined)
            reflectionMergePartial<IncreaseStat>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IncreaseStat): IncreaseStat {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 str */ 1:
                    message.str = reader.int32();
                    break;
                case /* int32 sta */ 2:
                    message.sta = reader.int32();
                    break;
                case /* int32 agi */ 3:
                    message.agi = reader.int32();
                    break;
                case /* int32 dex */ 4:
                    message.dex = reader.int32();
                    break;
                case /* int32 int_ */ 5:
                    message.int = reader.int32();
                    break;
                case /* int32 wis */ 6:
                    message.wis = reader.int32();
                    break;
                case /* int32 cha */ 7:
                    message.cha = reader.int32();
                    break;
                case /* int32 fire */ 8:
                    message.fire = reader.int32();
                    break;
                case /* int32 cold */ 9:
                    message.cold = reader.int32();
                    break;
                case /* int32 magic */ 10:
                    message.magic = reader.int32();
                    break;
                case /* int32 poison */ 11:
                    message.poison = reader.int32();
                    break;
                case /* int32 disease */ 12:
                    message.disease = reader.int32();
                    break;
                case /* int32 str2 */ 13:
                    message.str2 = reader.int32();
                    break;
                case /* int32 sta2 */ 14:
                    message.sta2 = reader.int32();
                    break;
                case /* int32 agi2 */ 15:
                    message.agi2 = reader.int32();
                    break;
                case /* int32 dex2 */ 16:
                    message.dex2 = reader.int32();
                    break;
                case /* int32 int2_ */ 17:
                    message.int2 = reader.int32();
                    break;
                case /* int32 wis2 */ 18:
                    message.wis2 = reader.int32();
                    break;
                case /* int32 cha2 */ 19:
                    message.cha2 = reader.int32();
                    break;
                case /* int32 fire2 */ 20:
                    message.fire2 = reader.int32();
                    break;
                case /* int32 cold2 */ 21:
                    message.cold2 = reader.int32();
                    break;
                case /* int32 magic2 */ 22:
                    message.magic2 = reader.int32();
                    break;
                case /* int32 poison2 */ 23:
                    message.poison2 = reader.int32();
                    break;
                case /* int32 disease2 */ 24:
                    message.disease2 = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IncreaseStat, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 str = 1; */
        if (message.str !== 0)
            writer.tag(1, WireType.Varint).int32(message.str);
        /* int32 sta = 2; */
        if (message.sta !== 0)
            writer.tag(2, WireType.Varint).int32(message.sta);
        /* int32 agi = 3; */
        if (message.agi !== 0)
            writer.tag(3, WireType.Varint).int32(message.agi);
        /* int32 dex = 4; */
        if (message.dex !== 0)
            writer.tag(4, WireType.Varint).int32(message.dex);
        /* int32 int_ = 5; */
        if (message.int !== 0)
            writer.tag(5, WireType.Varint).int32(message.int);
        /* int32 wis = 6; */
        if (message.wis !== 0)
            writer.tag(6, WireType.Varint).int32(message.wis);
        /* int32 cha = 7; */
        if (message.cha !== 0)
            writer.tag(7, WireType.Varint).int32(message.cha);
        /* int32 fire = 8; */
        if (message.fire !== 0)
            writer.tag(8, WireType.Varint).int32(message.fire);
        /* int32 cold = 9; */
        if (message.cold !== 0)
            writer.tag(9, WireType.Varint).int32(message.cold);
        /* int32 magic = 10; */
        if (message.magic !== 0)
            writer.tag(10, WireType.Varint).int32(message.magic);
        /* int32 poison = 11; */
        if (message.poison !== 0)
            writer.tag(11, WireType.Varint).int32(message.poison);
        /* int32 disease = 12; */
        if (message.disease !== 0)
            writer.tag(12, WireType.Varint).int32(message.disease);
        /* int32 str2 = 13; */
        if (message.str2 !== 0)
            writer.tag(13, WireType.Varint).int32(message.str2);
        /* int32 sta2 = 14; */
        if (message.sta2 !== 0)
            writer.tag(14, WireType.Varint).int32(message.sta2);
        /* int32 agi2 = 15; */
        if (message.agi2 !== 0)
            writer.tag(15, WireType.Varint).int32(message.agi2);
        /* int32 dex2 = 16; */
        if (message.dex2 !== 0)
            writer.tag(16, WireType.Varint).int32(message.dex2);
        /* int32 int2_ = 17; */
        if (message.int2 !== 0)
            writer.tag(17, WireType.Varint).int32(message.int2);
        /* int32 wis2 = 18; */
        if (message.wis2 !== 0)
            writer.tag(18, WireType.Varint).int32(message.wis2);
        /* int32 cha2 = 19; */
        if (message.cha2 !== 0)
            writer.tag(19, WireType.Varint).int32(message.cha2);
        /* int32 fire2 = 20; */
        if (message.fire2 !== 0)
            writer.tag(20, WireType.Varint).int32(message.fire2);
        /* int32 cold2 = 21; */
        if (message.cold2 !== 0)
            writer.tag(21, WireType.Varint).int32(message.cold2);
        /* int32 magic2 = 22; */
        if (message.magic2 !== 0)
            writer.tag(22, WireType.Varint).int32(message.magic2);
        /* int32 poison2 = 23; */
        if (message.poison2 !== 0)
            writer.tag(23, WireType.Varint).int32(message.poison2);
        /* int32 disease2 = 24; */
        if (message.disease2 !== 0)
            writer.tag(24, WireType.Varint).int32(message.disease2);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.IncreaseStat
 */
export const IncreaseStat = new IncreaseStat$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GMName$Type extends MessageType<GMName> {
    constructor() {
        super("eq.GMName", [
            { no: 1, name: "oldname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "gmname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "newname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "badname", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GMName>): GMName {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.oldname = "";
        message.gmname = "";
        message.newname = "";
        message.badname = 0;
        if (value !== undefined)
            reflectionMergePartial<GMName>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GMName): GMName {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string oldname */ 1:
                    message.oldname = reader.string();
                    break;
                case /* string gmname */ 2:
                    message.gmname = reader.string();
                    break;
                case /* string newname */ 3:
                    message.newname = reader.string();
                    break;
                case /* int32 badname */ 4:
                    message.badname = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GMName, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string oldname = 1; */
        if (message.oldname !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.oldname);
        /* string gmname = 2; */
        if (message.gmname !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.gmname);
        /* string newname = 3; */
        if (message.newname !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.newname);
        /* int32 badname = 4; */
        if (message.badname !== 0)
            writer.tag(4, WireType.Varint).int32(message.badname);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.GMName
 */
export const GMName = new GMName$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GMDelCorpse$Type extends MessageType<GMDelCorpse> {
    constructor() {
        super("eq.GMDelCorpse", [
            { no: 1, name: "corpsename", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "gmname", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GMDelCorpse>): GMDelCorpse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.corpsename = "";
        message.gmname = "";
        if (value !== undefined)
            reflectionMergePartial<GMDelCorpse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GMDelCorpse): GMDelCorpse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string corpsename */ 1:
                    message.corpsename = reader.string();
                    break;
                case /* string gmname */ 2:
                    message.gmname = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GMDelCorpse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string corpsename = 1; */
        if (message.corpsename !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.corpsename);
        /* string gmname = 2; */
        if (message.gmname !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.gmname);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.GMDelCorpse
 */
export const GMDelCorpse = new GMDelCorpse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GMKick$Type extends MessageType<GMKick> {
    constructor() {
        super("eq.GMKick", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "gmname", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GMKick>): GMKick {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.gmname = "";
        if (value !== undefined)
            reflectionMergePartial<GMKick>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GMKick): GMKick {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string gmname */ 2:
                    message.gmname = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GMKick, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string gmname = 2; */
        if (message.gmname !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.gmname);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.GMKick
 */
export const GMKick = new GMKick$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GMKill$Type extends MessageType<GMKill> {
    constructor() {
        super("eq.GMKill", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "gmname", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GMKill>): GMKill {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.gmname = "";
        if (value !== undefined)
            reflectionMergePartial<GMKill>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GMKill): GMKill {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string gmname */ 2:
                    message.gmname = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GMKill, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string gmname = 2; */
        if (message.gmname !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.gmname);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.GMKill
 */
export const GMKill = new GMKill$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GMEmoteZone$Type extends MessageType<GMEmoteZone> {
    constructor() {
        super("eq.GMEmoteZone", [
            { no: 1, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GMEmoteZone>): GMEmoteZone {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.text = "";
        if (value !== undefined)
            reflectionMergePartial<GMEmoteZone>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GMEmoteZone): GMEmoteZone {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string text */ 1:
                    message.text = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GMEmoteZone, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string text = 1; */
        if (message.text !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.text);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.GMEmoteZone
 */
export const GMEmoteZone = new GMEmoteZone$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BookText$Type extends MessageType<BookText> {
    constructor() {
        super("eq.BookText", [
            { no: 1, name: "window", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "booktext", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BookText>): BookText {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.window = 0;
        message.type = 0;
        message.booktext = "";
        if (value !== undefined)
            reflectionMergePartial<BookText>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BookText): BookText {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 window */ 1:
                    message.window = reader.int32();
                    break;
                case /* int32 type */ 2:
                    message.type = reader.int32();
                    break;
                case /* string booktext */ 3:
                    message.booktext = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BookText, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 window = 1; */
        if (message.window !== 0)
            writer.tag(1, WireType.Varint).int32(message.window);
        /* int32 type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* string booktext = 3; */
        if (message.booktext !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.booktext);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.BookText
 */
export const BookText = new BookText$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BookRequest$Type extends MessageType<BookRequest> {
    constructor() {
        super("eq.BookRequest", [
            { no: 1, name: "window", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "txtfile", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BookRequest>): BookRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.window = 0;
        message.type = 0;
        message.txtfile = "";
        if (value !== undefined)
            reflectionMergePartial<BookRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BookRequest): BookRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 window */ 1:
                    message.window = reader.int32();
                    break;
                case /* int32 type */ 2:
                    message.type = reader.int32();
                    break;
                case /* string txtfile */ 3:
                    message.txtfile = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BookRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 window = 1; */
        if (message.window !== 0)
            writer.tag(1, WireType.Varint).int32(message.window);
        /* int32 type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* string txtfile = 3; */
        if (message.txtfile !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.txtfile);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.BookRequest
 */
export const BookRequest = new BookRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object$Type extends MessageType<Object> {
    constructor() {
        super("eq.Object", [
            { no: 1, name: "linked_list_addr", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "drop_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "zone_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "zone_instance", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "heading", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "z", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "object_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "object_type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "spawn_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Object>): Object {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.linkedListAddr = [];
        message.dropId = 0;
        message.zoneId = 0;
        message.zoneInstance = 0;
        message.heading = 0;
        message.z = 0;
        message.x = 0;
        message.y = 0;
        message.objectName = "";
        message.objectType = 0;
        message.spawnId = 0;
        if (value !== undefined)
            reflectionMergePartial<Object>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Object): Object {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 linked_list_addr */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.linkedListAddr.push(reader.int32());
                    else
                        message.linkedListAddr.push(reader.int32());
                    break;
                case /* int32 drop_id */ 2:
                    message.dropId = reader.int32();
                    break;
                case /* int32 zone_id */ 3:
                    message.zoneId = reader.int32();
                    break;
                case /* int32 zone_instance */ 4:
                    message.zoneInstance = reader.int32();
                    break;
                case /* float heading */ 5:
                    message.heading = reader.float();
                    break;
                case /* float z */ 6:
                    message.z = reader.float();
                    break;
                case /* float x */ 7:
                    message.x = reader.float();
                    break;
                case /* float y */ 8:
                    message.y = reader.float();
                    break;
                case /* string object_name */ 9:
                    message.objectName = reader.string();
                    break;
                case /* int32 object_type */ 10:
                    message.objectType = reader.int32();
                    break;
                case /* int32 spawn_id */ 11:
                    message.spawnId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Object, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 linked_list_addr = 1; */
        if (message.linkedListAddr.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.linkedListAddr.length; i++)
                writer.int32(message.linkedListAddr[i]);
            writer.join();
        }
        /* int32 drop_id = 2; */
        if (message.dropId !== 0)
            writer.tag(2, WireType.Varint).int32(message.dropId);
        /* int32 zone_id = 3; */
        if (message.zoneId !== 0)
            writer.tag(3, WireType.Varint).int32(message.zoneId);
        /* int32 zone_instance = 4; */
        if (message.zoneInstance !== 0)
            writer.tag(4, WireType.Varint).int32(message.zoneInstance);
        /* float heading = 5; */
        if (message.heading !== 0)
            writer.tag(5, WireType.Bit32).float(message.heading);
        /* float z = 6; */
        if (message.z !== 0)
            writer.tag(6, WireType.Bit32).float(message.z);
        /* float x = 7; */
        if (message.x !== 0)
            writer.tag(7, WireType.Bit32).float(message.x);
        /* float y = 8; */
        if (message.y !== 0)
            writer.tag(8, WireType.Bit32).float(message.y);
        /* string object_name = 9; */
        if (message.objectName !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.objectName);
        /* int32 object_type = 10; */
        if (message.objectType !== 0)
            writer.tag(10, WireType.Varint).int32(message.objectType);
        /* int32 spawn_id = 11; */
        if (message.spawnId !== 0)
            writer.tag(11, WireType.Varint).int32(message.spawnId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Object
 */
export const Object = new Object$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClickObject$Type extends MessageType<ClickObject> {
    constructor() {
        super("eq.ClickObject", [
            { no: 1, name: "drop_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "player_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ClickObject>): ClickObject {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.dropId = 0;
        message.playerId = 0;
        if (value !== undefined)
            reflectionMergePartial<ClickObject>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClickObject): ClickObject {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 drop_id */ 1:
                    message.dropId = reader.int32();
                    break;
                case /* int32 player_id */ 2:
                    message.playerId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClickObject, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 drop_id = 1; */
        if (message.dropId !== 0)
            writer.tag(1, WireType.Varint).int32(message.dropId);
        /* int32 player_id = 2; */
        if (message.playerId !== 0)
            writer.tag(2, WireType.Varint).int32(message.playerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.ClickObject
 */
export const ClickObject = new ClickObject$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClickObjectAction$Type extends MessageType<ClickObjectAction> {
    constructor() {
        super("eq.ClickObjectAction", [
            { no: 1, name: "player_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "drop_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "open", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "icon", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "object_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ClickObjectAction>): ClickObjectAction {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.playerId = 0;
        message.dropId = 0;
        message.open = 0;
        message.type = 0;
        message.icon = 0;
        message.objectName = "";
        if (value !== undefined)
            reflectionMergePartial<ClickObjectAction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClickObjectAction): ClickObjectAction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 player_id */ 1:
                    message.playerId = reader.int32();
                    break;
                case /* int32 drop_id */ 2:
                    message.dropId = reader.int32();
                    break;
                case /* int32 open */ 3:
                    message.open = reader.int32();
                    break;
                case /* int32 type */ 4:
                    message.type = reader.int32();
                    break;
                case /* int32 icon */ 5:
                    message.icon = reader.int32();
                    break;
                case /* string object_name */ 6:
                    message.objectName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClickObjectAction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 player_id = 1; */
        if (message.playerId !== 0)
            writer.tag(1, WireType.Varint).int32(message.playerId);
        /* int32 drop_id = 2; */
        if (message.dropId !== 0)
            writer.tag(2, WireType.Varint).int32(message.dropId);
        /* int32 open = 3; */
        if (message.open !== 0)
            writer.tag(3, WireType.Varint).int32(message.open);
        /* int32 type = 4; */
        if (message.type !== 0)
            writer.tag(4, WireType.Varint).int32(message.type);
        /* int32 icon = 5; */
        if (message.icon !== 0)
            writer.tag(5, WireType.Varint).int32(message.icon);
        /* string object_name = 6; */
        if (message.objectName !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.objectName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.ClickObjectAction
 */
export const ClickObjectAction = new ClickObjectAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Shielding$Type extends MessageType<Shielding> {
    constructor() {
        super("eq.Shielding", [
            { no: 1, name: "target_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Shielding>): Shielding {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.targetId = 0;
        if (value !== undefined)
            reflectionMergePartial<Shielding>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Shielding): Shielding {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 target_id */ 1:
                    message.targetId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Shielding, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 target_id = 1; */
        if (message.targetId !== 0)
            writer.tag(1, WireType.Varint).int32(message.targetId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Shielding
 */
export const Shielding = new Shielding$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClickObjectAck$Type extends MessageType<ClickObjectAck> {
    constructor() {
        super("eq.ClickObjectAck", [
            { no: 1, name: "player_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "drop_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "open", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "icon", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "object_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ClickObjectAck>): ClickObjectAck {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.playerId = 0;
        message.dropId = 0;
        message.open = 0;
        message.type = 0;
        message.icon = 0;
        message.objectName = "";
        if (value !== undefined)
            reflectionMergePartial<ClickObjectAck>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClickObjectAck): ClickObjectAck {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 player_id */ 1:
                    message.playerId = reader.int32();
                    break;
                case /* int32 drop_id */ 2:
                    message.dropId = reader.int32();
                    break;
                case /* int32 open */ 3:
                    message.open = reader.int32();
                    break;
                case /* int32 type */ 4:
                    message.type = reader.int32();
                    break;
                case /* int32 icon */ 5:
                    message.icon = reader.int32();
                    break;
                case /* string object_name */ 6:
                    message.objectName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClickObjectAck, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 player_id = 1; */
        if (message.playerId !== 0)
            writer.tag(1, WireType.Varint).int32(message.playerId);
        /* int32 drop_id = 2; */
        if (message.dropId !== 0)
            writer.tag(2, WireType.Varint).int32(message.dropId);
        /* int32 open = 3; */
        if (message.open !== 0)
            writer.tag(3, WireType.Varint).int32(message.open);
        /* int32 type = 4; */
        if (message.type !== 0)
            writer.tag(4, WireType.Varint).int32(message.type);
        /* int32 icon = 5; */
        if (message.icon !== 0)
            writer.tag(5, WireType.Varint).int32(message.icon);
        /* string object_name = 6; */
        if (message.objectName !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.objectName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.ClickObjectAck
 */
export const ClickObjectAck = new ClickObjectAck$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CloseContainer$Type extends MessageType<CloseContainer> {
    constructor() {
        super("eq.CloseContainer", [
            { no: 1, name: "player_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "drop_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "open", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CloseContainer>): CloseContainer {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.playerId = 0;
        message.dropId = 0;
        message.open = 0;
        if (value !== undefined)
            reflectionMergePartial<CloseContainer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CloseContainer): CloseContainer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 player_id */ 1:
                    message.playerId = reader.int32();
                    break;
                case /* int32 drop_id */ 2:
                    message.dropId = reader.int32();
                    break;
                case /* int32 open */ 3:
                    message.open = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CloseContainer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 player_id = 1; */
        if (message.playerId !== 0)
            writer.tag(1, WireType.Varint).int32(message.playerId);
        /* int32 drop_id = 2; */
        if (message.dropId !== 0)
            writer.tag(2, WireType.Varint).int32(message.dropId);
        /* int32 open = 3; */
        if (message.open !== 0)
            writer.tag(3, WireType.Varint).int32(message.open);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.CloseContainer
 */
export const CloseContainer = new CloseContainer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Door$Type extends MessageType<Door> {
    constructor() {
        super("eq.Door", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "y_pos", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "x_pos", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "z_pos", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "heading", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "incline", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "size", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "door_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "opentype", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "state_at_spawn", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "invert_state", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "door_param", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Door>): Door {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.yPos = 0;
        message.xPos = 0;
        message.zPos = 0;
        message.heading = 0;
        message.incline = 0;
        message.size = 0;
        message.doorId = 0;
        message.opentype = 0;
        message.stateAtSpawn = 0;
        message.invertState = 0;
        message.doorParam = 0;
        if (value !== undefined)
            reflectionMergePartial<Door>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Door): Door {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* float y_pos */ 2:
                    message.yPos = reader.float();
                    break;
                case /* float x_pos */ 3:
                    message.xPos = reader.float();
                    break;
                case /* float z_pos */ 4:
                    message.zPos = reader.float();
                    break;
                case /* float heading */ 5:
                    message.heading = reader.float();
                    break;
                case /* int32 incline */ 6:
                    message.incline = reader.int32();
                    break;
                case /* int32 size */ 7:
                    message.size = reader.int32();
                    break;
                case /* int32 door_id */ 8:
                    message.doorId = reader.int32();
                    break;
                case /* int32 opentype */ 9:
                    message.opentype = reader.int32();
                    break;
                case /* int32 state_at_spawn */ 10:
                    message.stateAtSpawn = reader.int32();
                    break;
                case /* int32 invert_state */ 11:
                    message.invertState = reader.int32();
                    break;
                case /* int32 door_param */ 12:
                    message.doorParam = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Door, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* float y_pos = 2; */
        if (message.yPos !== 0)
            writer.tag(2, WireType.Bit32).float(message.yPos);
        /* float x_pos = 3; */
        if (message.xPos !== 0)
            writer.tag(3, WireType.Bit32).float(message.xPos);
        /* float z_pos = 4; */
        if (message.zPos !== 0)
            writer.tag(4, WireType.Bit32).float(message.zPos);
        /* float heading = 5; */
        if (message.heading !== 0)
            writer.tag(5, WireType.Bit32).float(message.heading);
        /* int32 incline = 6; */
        if (message.incline !== 0)
            writer.tag(6, WireType.Varint).int32(message.incline);
        /* int32 size = 7; */
        if (message.size !== 0)
            writer.tag(7, WireType.Varint).int32(message.size);
        /* int32 door_id = 8; */
        if (message.doorId !== 0)
            writer.tag(8, WireType.Varint).int32(message.doorId);
        /* int32 opentype = 9; */
        if (message.opentype !== 0)
            writer.tag(9, WireType.Varint).int32(message.opentype);
        /* int32 state_at_spawn = 10; */
        if (message.stateAtSpawn !== 0)
            writer.tag(10, WireType.Varint).int32(message.stateAtSpawn);
        /* int32 invert_state = 11; */
        if (message.invertState !== 0)
            writer.tag(11, WireType.Varint).int32(message.invertState);
        /* int32 door_param = 12; */
        if (message.doorParam !== 0)
            writer.tag(12, WireType.Varint).int32(message.doorParam);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Door
 */
export const Door = new Door$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DoorSpawns$Type extends MessageType<DoorSpawns> {
    constructor() {
        super("eq.DoorSpawns", [
            { no: 1, name: "count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "doors", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Door }
        ]);
    }
    create(value?: PartialMessage<DoorSpawns>): DoorSpawns {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.count = 0;
        message.doors = [];
        if (value !== undefined)
            reflectionMergePartial<DoorSpawns>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DoorSpawns): DoorSpawns {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 count */ 1:
                    message.count = reader.int32();
                    break;
                case /* repeated eq.Door doors */ 2:
                    message.doors.push(Door.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DoorSpawns, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 count = 1; */
        if (message.count !== 0)
            writer.tag(1, WireType.Varint).int32(message.count);
        /* repeated eq.Door doors = 2; */
        for (let i = 0; i < message.doors.length; i++)
            Door.internalBinaryWrite(message.doors[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.DoorSpawns
 */
export const DoorSpawns = new DoorSpawns$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClickDoor$Type extends MessageType<ClickDoor> {
    constructor() {
        super("eq.ClickDoor", [
            { no: 1, name: "doorid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "picklockskill", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "item_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "player_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ClickDoor>): ClickDoor {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.doorid = 0;
        message.picklockskill = 0;
        message.itemId = 0;
        message.playerId = 0;
        if (value !== undefined)
            reflectionMergePartial<ClickDoor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClickDoor): ClickDoor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 doorid */ 1:
                    message.doorid = reader.int32();
                    break;
                case /* int32 picklockskill */ 2:
                    message.picklockskill = reader.int32();
                    break;
                case /* int32 item_id */ 3:
                    message.itemId = reader.int32();
                    break;
                case /* int32 player_id */ 4:
                    message.playerId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClickDoor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 doorid = 1; */
        if (message.doorid !== 0)
            writer.tag(1, WireType.Varint).int32(message.doorid);
        /* int32 picklockskill = 2; */
        if (message.picklockskill !== 0)
            writer.tag(2, WireType.Varint).int32(message.picklockskill);
        /* int32 item_id = 3; */
        if (message.itemId !== 0)
            writer.tag(3, WireType.Varint).int32(message.itemId);
        /* int32 player_id = 4; */
        if (message.playerId !== 0)
            writer.tag(4, WireType.Varint).int32(message.playerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.ClickDoor
 */
export const ClickDoor = new ClickDoor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MoveDoor$Type extends MessageType<MoveDoor> {
    constructor() {
        super("eq.MoveDoor", [
            { no: 1, name: "doorid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "action", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<MoveDoor>): MoveDoor {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.doorid = 0;
        message.action = 0;
        if (value !== undefined)
            reflectionMergePartial<MoveDoor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MoveDoor): MoveDoor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 doorid */ 1:
                    message.doorid = reader.int32();
                    break;
                case /* int32 action */ 2:
                    message.action = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MoveDoor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 doorid = 1; */
        if (message.doorid !== 0)
            writer.tag(1, WireType.Varint).int32(message.doorid);
        /* int32 action = 2; */
        if (message.action !== 0)
            writer.tag(2, WireType.Varint).int32(message.action);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.MoveDoor
 */
export const MoveDoor = new MoveDoor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ControlBoat$Type extends MessageType<ControlBoat> {
    constructor() {
        super("eq.ControlBoat", [
            { no: 1, name: "boat_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "take_control", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ControlBoat>): ControlBoat {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.boatId = 0;
        message.takeControl = false;
        if (value !== undefined)
            reflectionMergePartial<ControlBoat>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ControlBoat): ControlBoat {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 boat_id */ 1:
                    message.boatId = reader.int32();
                    break;
                case /* bool take_control */ 2:
                    message.takeControl = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ControlBoat, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 boat_id = 1; */
        if (message.boatId !== 0)
            writer.tag(1, WireType.Varint).int32(message.boatId);
        /* bool take_control = 2; */
        if (message.takeControl !== false)
            writer.tag(2, WireType.Varint).bool(message.takeControl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.ControlBoat
 */
export const ControlBoat = new ControlBoat$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BecomeNPC$Type extends MessageType<BecomeNPC> {
    constructor() {
        super("eq.BecomeNPC", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "maxlevel", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<BecomeNPC>): BecomeNPC {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.maxlevel = 0;
        if (value !== undefined)
            reflectionMergePartial<BecomeNPC>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BecomeNPC): BecomeNPC {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* int32 maxlevel */ 2:
                    message.maxlevel = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BecomeNPC, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* int32 maxlevel = 2; */
        if (message.maxlevel !== 0)
            writer.tag(2, WireType.Varint).int32(message.maxlevel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.BecomeNPC
 */
export const BecomeNPC = new BecomeNPC$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Underworld$Type extends MessageType<Underworld> {
    constructor() {
        super("eq.Underworld", [
            { no: 1, name: "speed", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "z", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Underworld>): Underworld {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.speed = 0;
        message.y = 0;
        message.x = 0;
        message.z = 0;
        if (value !== undefined)
            reflectionMergePartial<Underworld>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Underworld): Underworld {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float speed */ 1:
                    message.speed = reader.float();
                    break;
                case /* float y */ 2:
                    message.y = reader.float();
                    break;
                case /* float x */ 3:
                    message.x = reader.float();
                    break;
                case /* float z */ 4:
                    message.z = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Underworld, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float speed = 1; */
        if (message.speed !== 0)
            writer.tag(1, WireType.Bit32).float(message.speed);
        /* float y = 2; */
        if (message.y !== 0)
            writer.tag(2, WireType.Bit32).float(message.y);
        /* float x = 3; */
        if (message.x !== 0)
            writer.tag(3, WireType.Bit32).float(message.x);
        /* float z = 4; */
        if (message.z !== 0)
            writer.tag(4, WireType.Bit32).float(message.z);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Underworld
 */
export const Underworld = new Underworld$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Resurrect$Type extends MessageType<Resurrect> {
    constructor() {
        super("eq.Resurrect", [
            { no: 1, name: "zone_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "instance_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "z", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "your_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "rezzer_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "spellid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "corpse_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "action", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Resurrect>): Resurrect {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.zoneId = 0;
        message.instanceId = 0;
        message.y = 0;
        message.x = 0;
        message.z = 0;
        message.yourName = "";
        message.rezzerName = "";
        message.spellid = 0;
        message.corpseName = "";
        message.action = 0;
        if (value !== undefined)
            reflectionMergePartial<Resurrect>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Resurrect): Resurrect {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 zone_id */ 1:
                    message.zoneId = reader.int32();
                    break;
                case /* int32 instance_id */ 2:
                    message.instanceId = reader.int32();
                    break;
                case /* float y */ 3:
                    message.y = reader.float();
                    break;
                case /* float x */ 4:
                    message.x = reader.float();
                    break;
                case /* float z */ 5:
                    message.z = reader.float();
                    break;
                case /* string your_name */ 6:
                    message.yourName = reader.string();
                    break;
                case /* string rezzer_name */ 7:
                    message.rezzerName = reader.string();
                    break;
                case /* int32 spellid */ 8:
                    message.spellid = reader.int32();
                    break;
                case /* string corpse_name */ 9:
                    message.corpseName = reader.string();
                    break;
                case /* int32 action */ 10:
                    message.action = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Resurrect, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 zone_id = 1; */
        if (message.zoneId !== 0)
            writer.tag(1, WireType.Varint).int32(message.zoneId);
        /* int32 instance_id = 2; */
        if (message.instanceId !== 0)
            writer.tag(2, WireType.Varint).int32(message.instanceId);
        /* float y = 3; */
        if (message.y !== 0)
            writer.tag(3, WireType.Bit32).float(message.y);
        /* float x = 4; */
        if (message.x !== 0)
            writer.tag(4, WireType.Bit32).float(message.x);
        /* float z = 5; */
        if (message.z !== 0)
            writer.tag(5, WireType.Bit32).float(message.z);
        /* string your_name = 6; */
        if (message.yourName !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.yourName);
        /* string rezzer_name = 7; */
        if (message.rezzerName !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.rezzerName);
        /* int32 spellid = 8; */
        if (message.spellid !== 0)
            writer.tag(8, WireType.Varint).int32(message.spellid);
        /* string corpse_name = 9; */
        if (message.corpseName !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.corpseName);
        /* int32 action = 10; */
        if (message.action !== 0)
            writer.tag(10, WireType.Varint).int32(message.action);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Resurrect
 */
export const Resurrect = new Resurrect$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRunMode$Type extends MessageType<SetRunMode> {
    constructor() {
        super("eq.SetRunMode", [
            { no: 1, name: "mode", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SetRunMode>): SetRunMode {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mode = 0;
        if (value !== undefined)
            reflectionMergePartial<SetRunMode>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRunMode): SetRunMode {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 mode */ 1:
                    message.mode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRunMode, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 mode = 1; */
        if (message.mode !== 0)
            writer.tag(1, WireType.Varint).int32(message.mode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.SetRunMode
 */
export const SetRunMode = new SetRunMode$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EnvDamage2$Type extends MessageType<EnvDamage2> {
    constructor() {
        super("eq.EnvDamage2", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "damage", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "dmgtype", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "constant", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<EnvDamage2>): EnvDamage2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.damage = 0;
        message.dmgtype = 0;
        message.constant = 0;
        if (value !== undefined)
            reflectionMergePartial<EnvDamage2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EnvDamage2): EnvDamage2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* int32 damage */ 2:
                    message.damage = reader.int32();
                    break;
                case /* int32 dmgtype */ 3:
                    message.dmgtype = reader.int32();
                    break;
                case /* int32 constant */ 4:
                    message.constant = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EnvDamage2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* int32 damage = 2; */
        if (message.damage !== 0)
            writer.tag(2, WireType.Varint).int32(message.damage);
        /* int32 dmgtype = 3; */
        if (message.dmgtype !== 0)
            writer.tag(3, WireType.Varint).int32(message.dmgtype);
        /* int32 constant = 4; */
        if (message.constant !== 0)
            writer.tag(4, WireType.Varint).int32(message.constant);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.EnvDamage2
 */
export const EnvDamage2 = new EnvDamage2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BazaarWindowStart$Type extends MessageType<BazaarWindowStart> {
    constructor() {
        super("eq.BazaarWindowStart", [
            { no: 1, name: "action", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<BazaarWindowStart>): BazaarWindowStart {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.action = 0;
        if (value !== undefined)
            reflectionMergePartial<BazaarWindowStart>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BazaarWindowStart): BazaarWindowStart {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 action */ 1:
                    message.action = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BazaarWindowStart, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 action = 1; */
        if (message.action !== 0)
            writer.tag(1, WireType.Varint).int32(message.action);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.BazaarWindowStart
 */
export const BazaarWindowStart = new BazaarWindowStart$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BazaarWelcome$Type extends MessageType<BazaarWelcome> {
    constructor() {
        super("eq.BazaarWelcome", [
            { no: 1, name: "beginning", kind: "message", T: () => BazaarWindowStart },
            { no: 2, name: "traders", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "items", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<BazaarWelcome>): BazaarWelcome {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.traders = 0;
        message.items = 0;
        if (value !== undefined)
            reflectionMergePartial<BazaarWelcome>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BazaarWelcome): BazaarWelcome {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* eq.BazaarWindowStart beginning */ 1:
                    message.beginning = BazaarWindowStart.internalBinaryRead(reader, reader.uint32(), options, message.beginning);
                    break;
                case /* int32 traders */ 2:
                    message.traders = reader.int32();
                    break;
                case /* int32 items */ 3:
                    message.items = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BazaarWelcome, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* eq.BazaarWindowStart beginning = 1; */
        if (message.beginning)
            BazaarWindowStart.internalBinaryWrite(message.beginning, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 traders = 2; */
        if (message.traders !== 0)
            writer.tag(2, WireType.Varint).int32(message.traders);
        /* int32 items = 3; */
        if (message.items !== 0)
            writer.tag(3, WireType.Varint).int32(message.items);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.BazaarWelcome
 */
export const BazaarWelcome = new BazaarWelcome$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BazaarSearch$Type extends MessageType<BazaarSearch> {
    constructor() {
        super("eq.BazaarSearch", [
            { no: 1, name: "beginning", kind: "message", T: () => BazaarWindowStart },
            { no: 2, name: "traderid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "char_class", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "race", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "stat", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "slot", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "minprice", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "maxprice", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "minlevel", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "maxlevel", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<BazaarSearch>): BazaarSearch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.traderid = 0;
        message.charClass = 0;
        message.race = 0;
        message.stat = 0;
        message.slot = 0;
        message.type = 0;
        message.name = "";
        message.minprice = 0;
        message.maxprice = 0;
        message.minlevel = 0;
        message.maxlevel = 0;
        if (value !== undefined)
            reflectionMergePartial<BazaarSearch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BazaarSearch): BazaarSearch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* eq.BazaarWindowStart beginning */ 1:
                    message.beginning = BazaarWindowStart.internalBinaryRead(reader, reader.uint32(), options, message.beginning);
                    break;
                case /* int32 traderid */ 2:
                    message.traderid = reader.int32();
                    break;
                case /* int32 char_class */ 3:
                    message.charClass = reader.int32();
                    break;
                case /* int32 race */ 4:
                    message.race = reader.int32();
                    break;
                case /* int32 stat */ 5:
                    message.stat = reader.int32();
                    break;
                case /* int32 slot */ 6:
                    message.slot = reader.int32();
                    break;
                case /* int32 type */ 7:
                    message.type = reader.int32();
                    break;
                case /* string name */ 8:
                    message.name = reader.string();
                    break;
                case /* int32 minprice */ 9:
                    message.minprice = reader.int32();
                    break;
                case /* int32 maxprice */ 10:
                    message.maxprice = reader.int32();
                    break;
                case /* int32 minlevel */ 11:
                    message.minlevel = reader.int32();
                    break;
                case /* int32 maxlevel */ 12:
                    message.maxlevel = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BazaarSearch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* eq.BazaarWindowStart beginning = 1; */
        if (message.beginning)
            BazaarWindowStart.internalBinaryWrite(message.beginning, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 traderid = 2; */
        if (message.traderid !== 0)
            writer.tag(2, WireType.Varint).int32(message.traderid);
        /* int32 char_class = 3; */
        if (message.charClass !== 0)
            writer.tag(3, WireType.Varint).int32(message.charClass);
        /* int32 race = 4; */
        if (message.race !== 0)
            writer.tag(4, WireType.Varint).int32(message.race);
        /* int32 stat = 5; */
        if (message.stat !== 0)
            writer.tag(5, WireType.Varint).int32(message.stat);
        /* int32 slot = 6; */
        if (message.slot !== 0)
            writer.tag(6, WireType.Varint).int32(message.slot);
        /* int32 type = 7; */
        if (message.type !== 0)
            writer.tag(7, WireType.Varint).int32(message.type);
        /* string name = 8; */
        if (message.name !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.name);
        /* int32 minprice = 9; */
        if (message.minprice !== 0)
            writer.tag(9, WireType.Varint).int32(message.minprice);
        /* int32 maxprice = 10; */
        if (message.maxprice !== 0)
            writer.tag(10, WireType.Varint).int32(message.maxprice);
        /* int32 minlevel = 11; */
        if (message.minlevel !== 0)
            writer.tag(11, WireType.Varint).int32(message.minlevel);
        /* int32 maxlevel = 12; */
        if (message.maxlevel !== 0)
            writer.tag(12, WireType.Varint).int32(message.maxlevel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.BazaarSearch
 */
export const BazaarSearch = new BazaarSearch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BazaarInspect$Type extends MessageType<BazaarInspect> {
    constructor() {
        super("eq.BazaarInspect", [
            { no: 1, name: "item_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BazaarInspect>): BazaarInspect {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.itemId = 0;
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<BazaarInspect>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BazaarInspect): BazaarInspect {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 item_id */ 1:
                    message.itemId = reader.int32();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BazaarInspect, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 item_id = 1; */
        if (message.itemId !== 0)
            writer.tag(1, WireType.Varint).int32(message.itemId);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.BazaarInspect
 */
export const BazaarInspect = new BazaarInspect$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BazaarReturnDone$Type extends MessageType<BazaarReturnDone> {
    constructor() {
        super("eq.BazaarReturnDone", [
            { no: 1, name: "type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "traderid", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<BazaarReturnDone>): BazaarReturnDone {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.traderid = 0;
        if (value !== undefined)
            reflectionMergePartial<BazaarReturnDone>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BazaarReturnDone): BazaarReturnDone {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 type */ 1:
                    message.type = reader.int32();
                    break;
                case /* int32 traderid */ 2:
                    message.traderid = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BazaarReturnDone, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* int32 traderid = 2; */
        if (message.traderid !== 0)
            writer.tag(2, WireType.Varint).int32(message.traderid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.BazaarReturnDone
 */
export const BazaarReturnDone = new BazaarReturnDone$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BazaarSearchResults$Type extends MessageType<BazaarSearchResults> {
    constructor() {
        super("eq.BazaarSearchResults", [
            { no: 1, name: "beginning", kind: "message", T: () => BazaarWindowStart },
            { no: 2, name: "seller_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "num_items", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "serial_number", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "item_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "cost", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "item_stat", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<BazaarSearchResults>): BazaarSearchResults {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sellerId = 0;
        message.numItems = 0;
        message.serialNumber = 0;
        message.itemName = "";
        message.cost = 0;
        message.itemStat = 0;
        if (value !== undefined)
            reflectionMergePartial<BazaarSearchResults>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BazaarSearchResults): BazaarSearchResults {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* eq.BazaarWindowStart beginning */ 1:
                    message.beginning = BazaarWindowStart.internalBinaryRead(reader, reader.uint32(), options, message.beginning);
                    break;
                case /* int32 seller_id */ 2:
                    message.sellerId = reader.int32();
                    break;
                case /* int32 num_items */ 3:
                    message.numItems = reader.int32();
                    break;
                case /* int32 serial_number */ 4:
                    message.serialNumber = reader.int32();
                    break;
                case /* string item_name */ 5:
                    message.itemName = reader.string();
                    break;
                case /* int32 cost */ 6:
                    message.cost = reader.int32();
                    break;
                case /* int32 item_stat */ 7:
                    message.itemStat = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BazaarSearchResults, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* eq.BazaarWindowStart beginning = 1; */
        if (message.beginning)
            BazaarWindowStart.internalBinaryWrite(message.beginning, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 seller_id = 2; */
        if (message.sellerId !== 0)
            writer.tag(2, WireType.Varint).int32(message.sellerId);
        /* int32 num_items = 3; */
        if (message.numItems !== 0)
            writer.tag(3, WireType.Varint).int32(message.numItems);
        /* int32 serial_number = 4; */
        if (message.serialNumber !== 0)
            writer.tag(4, WireType.Varint).int32(message.serialNumber);
        /* string item_name = 5; */
        if (message.itemName !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.itemName);
        /* int32 cost = 6; */
        if (message.cost !== 0)
            writer.tag(6, WireType.Varint).int32(message.cost);
        /* int32 item_stat = 7; */
        if (message.itemStat !== 0)
            writer.tag(7, WireType.Varint).int32(message.itemStat);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.BazaarSearchResults
 */
export const BazaarSearchResults = new BazaarSearchResults$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServerSideFilters$Type extends MessageType<ServerSideFilters> {
    constructor() {
        super("eq.ServerSideFilters", [
            { no: 1, name: "clientattackfilters", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "npcattackfilters", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "clientcastfilters", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "npccastfilters", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ServerSideFilters>): ServerSideFilters {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clientattackfilters = 0;
        message.npcattackfilters = 0;
        message.clientcastfilters = 0;
        message.npccastfilters = 0;
        if (value !== undefined)
            reflectionMergePartial<ServerSideFilters>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServerSideFilters): ServerSideFilters {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 clientattackfilters */ 1:
                    message.clientattackfilters = reader.int32();
                    break;
                case /* int32 npcattackfilters */ 2:
                    message.npcattackfilters = reader.int32();
                    break;
                case /* int32 clientcastfilters */ 3:
                    message.clientcastfilters = reader.int32();
                    break;
                case /* int32 npccastfilters */ 4:
                    message.npccastfilters = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServerSideFilters, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 clientattackfilters = 1; */
        if (message.clientattackfilters !== 0)
            writer.tag(1, WireType.Varint).int32(message.clientattackfilters);
        /* int32 npcattackfilters = 2; */
        if (message.npcattackfilters !== 0)
            writer.tag(2, WireType.Varint).int32(message.npcattackfilters);
        /* int32 clientcastfilters = 3; */
        if (message.clientcastfilters !== 0)
            writer.tag(3, WireType.Varint).int32(message.clientcastfilters);
        /* int32 npccastfilters = 4; */
        if (message.npccastfilters !== 0)
            writer.tag(4, WireType.Varint).int32(message.npccastfilters);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.ServerSideFilters
 */
export const ServerSideFilters = new ServerSideFilters$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ItemViewRequest$Type extends MessageType<ItemViewRequest> {
    constructor() {
        super("eq.ItemViewRequest", [
            { no: 1, name: "item_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "augments", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "link_hash", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ItemViewRequest>): ItemViewRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.itemId = 0;
        message.augments = [];
        message.linkHash = 0;
        if (value !== undefined)
            reflectionMergePartial<ItemViewRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ItemViewRequest): ItemViewRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 item_id */ 1:
                    message.itemId = reader.int32();
                    break;
                case /* repeated int32 augments */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.augments.push(reader.int32());
                    else
                        message.augments.push(reader.int32());
                    break;
                case /* int32 link_hash */ 3:
                    message.linkHash = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ItemViewRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 item_id = 1; */
        if (message.itemId !== 0)
            writer.tag(1, WireType.Varint).int32(message.itemId);
        /* repeated int32 augments = 2; */
        if (message.augments.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.augments.length; i++)
                writer.int32(message.augments[i]);
            writer.join();
        }
        /* int32 link_hash = 3; */
        if (message.linkHash !== 0)
            writer.tag(3, WireType.Varint).int32(message.linkHash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.ItemViewRequest
 */
export const ItemViewRequest = new ItemViewRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ItemVerifyRequest$Type extends MessageType<ItemVerifyRequest> {
    constructor() {
        super("eq.ItemVerifyRequest", [
            { no: 1, name: "slot", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "target", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ItemVerifyRequest>): ItemVerifyRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.slot = 0;
        message.target = 0;
        if (value !== undefined)
            reflectionMergePartial<ItemVerifyRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ItemVerifyRequest): ItemVerifyRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 slot */ 1:
                    message.slot = reader.int32();
                    break;
                case /* int32 target */ 2:
                    message.target = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ItemVerifyRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 slot = 1; */
        if (message.slot !== 0)
            writer.tag(1, WireType.Varint).int32(message.slot);
        /* int32 target = 2; */
        if (message.target !== 0)
            writer.tag(2, WireType.Varint).int32(message.target);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.ItemVerifyRequest
 */
export const ItemVerifyRequest = new ItemVerifyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PickPocket$Type extends MessageType<PickPocket> {
    constructor() {
        super("eq.PickPocket", [
            { no: 1, name: "to", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "from", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "myskill", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "coin", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "lastsix", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<PickPocket>): PickPocket {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.to = 0;
        message.from = 0;
        message.myskill = 0;
        message.type = 0;
        message.coin = 0;
        message.lastsix = [];
        if (value !== undefined)
            reflectionMergePartial<PickPocket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PickPocket): PickPocket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 to */ 1:
                    message.to = reader.int32();
                    break;
                case /* int32 from */ 2:
                    message.from = reader.int32();
                    break;
                case /* int32 myskill */ 3:
                    message.myskill = reader.int32();
                    break;
                case /* int32 type */ 4:
                    message.type = reader.int32();
                    break;
                case /* int32 coin */ 5:
                    message.coin = reader.int32();
                    break;
                case /* repeated int32 lastsix */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.lastsix.push(reader.int32());
                    else
                        message.lastsix.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PickPocket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 to = 1; */
        if (message.to !== 0)
            writer.tag(1, WireType.Varint).int32(message.to);
        /* int32 from = 2; */
        if (message.from !== 0)
            writer.tag(2, WireType.Varint).int32(message.from);
        /* int32 myskill = 3; */
        if (message.myskill !== 0)
            writer.tag(3, WireType.Varint).int32(message.myskill);
        /* int32 type = 4; */
        if (message.type !== 0)
            writer.tag(4, WireType.Varint).int32(message.type);
        /* int32 coin = 5; */
        if (message.coin !== 0)
            writer.tag(5, WireType.Varint).int32(message.coin);
        /* repeated int32 lastsix = 6; */
        if (message.lastsix.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.lastsix.length; i++)
                writer.int32(message.lastsix[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.PickPocket
 */
export const PickPocket = new PickPocket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class sPickPocket$Type extends MessageType<sPickPocket> {
    constructor() {
        super("eq.sPickPocket", [
            { no: 1, name: "to", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "from", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "myskill", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "coin", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "itemname", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<sPickPocket>): sPickPocket {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.to = 0;
        message.from = 0;
        message.myskill = 0;
        message.type = 0;
        message.coin = 0;
        message.itemname = "";
        if (value !== undefined)
            reflectionMergePartial<sPickPocket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: sPickPocket): sPickPocket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 to */ 1:
                    message.to = reader.int32();
                    break;
                case /* int32 from */ 2:
                    message.from = reader.int32();
                    break;
                case /* int32 myskill */ 3:
                    message.myskill = reader.int32();
                    break;
                case /* int32 type */ 4:
                    message.type = reader.int32();
                    break;
                case /* int32 coin */ 5:
                    message.coin = reader.int32();
                    break;
                case /* string itemname */ 6:
                    message.itemname = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: sPickPocket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 to = 1; */
        if (message.to !== 0)
            writer.tag(1, WireType.Varint).int32(message.to);
        /* int32 from = 2; */
        if (message.from !== 0)
            writer.tag(2, WireType.Varint).int32(message.from);
        /* int32 myskill = 3; */
        if (message.myskill !== 0)
            writer.tag(3, WireType.Varint).int32(message.myskill);
        /* int32 type = 4; */
        if (message.type !== 0)
            writer.tag(4, WireType.Varint).int32(message.type);
        /* int32 coin = 5; */
        if (message.coin !== 0)
            writer.tag(5, WireType.Varint).int32(message.coin);
        /* string itemname = 6; */
        if (message.itemname !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.itemname);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.sPickPocket
 */
export const sPickPocket = new sPickPocket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LogServer$Type extends MessageType<LogServer> {
    constructor() {
        super("eq.LogServer", [
            { no: 1, name: "worldshortname", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LogServer>): LogServer {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.worldshortname = "";
        if (value !== undefined)
            reflectionMergePartial<LogServer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LogServer): LogServer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string worldshortname */ 1:
                    message.worldshortname = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LogServer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string worldshortname = 1; */
        if (message.worldshortname !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.worldshortname);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.LogServer
 */
export const LogServer = new LogServer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ApproveWorld$Type extends MessageType<ApproveWorld> {
    constructor() {
        super("eq.ApproveWorld", []);
    }
    create(value?: PartialMessage<ApproveWorld>): ApproveWorld {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ApproveWorld>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ApproveWorld): ApproveWorld {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ApproveWorld, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.ApproveWorld
 */
export const ApproveWorld = new ApproveWorld$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClientError$Type extends MessageType<ClientError> {
    constructor() {
        super("eq.ClientError", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "character_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ClientError>): ClientError {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.characterName = "";
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<ClientError>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClientError): ClientError {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string character_name */ 2:
                    message.characterName = reader.string();
                    break;
                case /* string message */ 3:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClientError, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string character_name = 2; */
        if (message.characterName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.characterName);
        /* string message = 3; */
        if (message.message !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.ClientError
 */
export const ClientError = new ClientError$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MobHealth$Type extends MessageType<MobHealth> {
    constructor() {
        super("eq.MobHealth", [
            { no: 1, name: "hp", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<MobHealth>): MobHealth {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hp = 0;
        message.id = 0;
        if (value !== undefined)
            reflectionMergePartial<MobHealth>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MobHealth): MobHealth {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 hp */ 1:
                    message.hp = reader.int32();
                    break;
                case /* int32 id */ 2:
                    message.id = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MobHealth, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 hp = 1; */
        if (message.hp !== 0)
            writer.tag(1, WireType.Varint).int32(message.hp);
        /* int32 id = 2; */
        if (message.id !== 0)
            writer.tag(2, WireType.Varint).int32(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.MobHealth
 */
export const MobHealth = new MobHealth$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Track$Type extends MessageType<Track> {
    constructor() {
        super("eq.Track", [
            { no: 1, name: "entityid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "distance", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Track>): Track {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entityid = 0;
        message.distance = 0;
        if (value !== undefined)
            reflectionMergePartial<Track>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Track): Track {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 entityid */ 1:
                    message.entityid = reader.int32();
                    break;
                case /* float distance */ 2:
                    message.distance = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Track, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 entityid = 1; */
        if (message.entityid !== 0)
            writer.tag(1, WireType.Varint).int32(message.entityid);
        /* float distance = 2; */
        if (message.distance !== 0)
            writer.tag(2, WireType.Bit32).float(message.distance);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Track
 */
export const Track = new Track$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackTarget$Type extends MessageType<TrackTarget> {
    constructor() {
        super("eq.TrackTarget", [
            { no: 1, name: "entityid", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TrackTarget>): TrackTarget {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entityid = 0;
        if (value !== undefined)
            reflectionMergePartial<TrackTarget>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrackTarget): TrackTarget {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 entityid */ 1:
                    message.entityid = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrackTarget, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 entityid = 1; */
        if (message.entityid !== 0)
            writer.tag(1, WireType.Varint).int32(message.entityid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.TrackTarget
 */
export const TrackTarget = new TrackTarget$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Tracking$Type extends MessageType<Tracking> {
    constructor() {
        super("eq.Tracking", [
            { no: 1, name: "count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "entries", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Track }
        ]);
    }
    create(value?: PartialMessage<Tracking>): Tracking {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.count = 0;
        message.entries = [];
        if (value !== undefined)
            reflectionMergePartial<Tracking>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Tracking): Tracking {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 count */ 1:
                    message.count = reader.int32();
                    break;
                case /* repeated eq.Track entries */ 2:
                    message.entries.push(Track.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Tracking, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 count = 1; */
        if (message.count !== 0)
            writer.tag(1, WireType.Varint).int32(message.count);
        /* repeated eq.Track entries = 2; */
        for (let i = 0; i < message.entries.length; i++)
            Track.internalBinaryWrite(message.entries[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Tracking
 */
export const Tracking = new Tracking$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ZoneServerInfo$Type extends MessageType<ZoneServerInfo> {
    constructor() {
        super("eq.ZoneServerInfo", [
            { no: 1, name: "ip", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "port", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ZoneServerInfo>): ZoneServerInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ip = "";
        message.port = 0;
        if (value !== undefined)
            reflectionMergePartial<ZoneServerInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ZoneServerInfo): ZoneServerInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ip */ 1:
                    message.ip = reader.string();
                    break;
                case /* int32 port */ 2:
                    message.port = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ZoneServerInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ip = 1; */
        if (message.ip !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.ip);
        /* int32 port = 2; */
        if (message.port !== 0)
            writer.tag(2, WireType.Varint).int32(message.port);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.ZoneServerInfo
 */
export const ZoneServerInfo = new ZoneServerInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WhoAllPlayer$Type extends MessageType<WhoAllPlayer> {
    constructor() {
        super("eq.WhoAllPlayer", [
            { no: 1, name: "formatstring", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "pidstring", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "rankstring", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "guild", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "zonestring", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "zone", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "char_class", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "level", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "race", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "account", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WhoAllPlayer>): WhoAllPlayer {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.formatstring = 0;
        message.pidstring = 0;
        message.name = "";
        message.rankstring = 0;
        message.guild = "";
        message.zonestring = 0;
        message.zone = 0;
        message.charClass = 0;
        message.level = 0;
        message.race = 0;
        message.account = "";
        if (value !== undefined)
            reflectionMergePartial<WhoAllPlayer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WhoAllPlayer): WhoAllPlayer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 formatstring */ 1:
                    message.formatstring = reader.int32();
                    break;
                case /* int32 pidstring */ 2:
                    message.pidstring = reader.int32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* int32 rankstring */ 4:
                    message.rankstring = reader.int32();
                    break;
                case /* string guild */ 5:
                    message.guild = reader.string();
                    break;
                case /* int32 zonestring */ 6:
                    message.zonestring = reader.int32();
                    break;
                case /* int32 zone */ 7:
                    message.zone = reader.int32();
                    break;
                case /* int32 char_class */ 8:
                    message.charClass = reader.int32();
                    break;
                case /* int32 level */ 9:
                    message.level = reader.int32();
                    break;
                case /* int32 race */ 10:
                    message.race = reader.int32();
                    break;
                case /* string account */ 11:
                    message.account = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WhoAllPlayer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 formatstring = 1; */
        if (message.formatstring !== 0)
            writer.tag(1, WireType.Varint).int32(message.formatstring);
        /* int32 pidstring = 2; */
        if (message.pidstring !== 0)
            writer.tag(2, WireType.Varint).int32(message.pidstring);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* int32 rankstring = 4; */
        if (message.rankstring !== 0)
            writer.tag(4, WireType.Varint).int32(message.rankstring);
        /* string guild = 5; */
        if (message.guild !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.guild);
        /* int32 zonestring = 6; */
        if (message.zonestring !== 0)
            writer.tag(6, WireType.Varint).int32(message.zonestring);
        /* int32 zone = 7; */
        if (message.zone !== 0)
            writer.tag(7, WireType.Varint).int32(message.zone);
        /* int32 char_class = 8; */
        if (message.charClass !== 0)
            writer.tag(8, WireType.Varint).int32(message.charClass);
        /* int32 level = 9; */
        if (message.level !== 0)
            writer.tag(9, WireType.Varint).int32(message.level);
        /* int32 race = 10; */
        if (message.race !== 0)
            writer.tag(10, WireType.Varint).int32(message.race);
        /* string account = 11; */
        if (message.account !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.account);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.WhoAllPlayer
 */
export const WhoAllPlayer = new WhoAllPlayer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WhoAllReturn$Type extends MessageType<WhoAllReturn> {
    constructor() {
        super("eq.WhoAllReturn", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "playerineqstring", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "line", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "playersinzonestring", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "player", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => WhoAllPlayer }
        ]);
    }
    create(value?: PartialMessage<WhoAllReturn>): WhoAllReturn {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.playerineqstring = 0;
        message.line = "";
        message.playersinzonestring = 0;
        message.count = 0;
        message.player = [];
        if (value !== undefined)
            reflectionMergePartial<WhoAllReturn>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WhoAllReturn): WhoAllReturn {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* int32 playerineqstring */ 2:
                    message.playerineqstring = reader.int32();
                    break;
                case /* string line */ 3:
                    message.line = reader.string();
                    break;
                case /* int32 playersinzonestring */ 4:
                    message.playersinzonestring = reader.int32();
                    break;
                case /* int32 count */ 5:
                    message.count = reader.int32();
                    break;
                case /* repeated eq.WhoAllPlayer player */ 6:
                    message.player.push(WhoAllPlayer.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WhoAllReturn, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* int32 playerineqstring = 2; */
        if (message.playerineqstring !== 0)
            writer.tag(2, WireType.Varint).int32(message.playerineqstring);
        /* string line = 3; */
        if (message.line !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.line);
        /* int32 playersinzonestring = 4; */
        if (message.playersinzonestring !== 0)
            writer.tag(4, WireType.Varint).int32(message.playersinzonestring);
        /* int32 count = 5; */
        if (message.count !== 0)
            writer.tag(5, WireType.Varint).int32(message.count);
        /* repeated eq.WhoAllPlayer player = 6; */
        for (let i = 0; i < message.player.length; i++)
            WhoAllPlayer.internalBinaryWrite(message.player[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.WhoAllReturn
 */
export const WhoAllReturn = new WhoAllReturn$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Trader$Type extends MessageType<Trader> {
    constructor() {
        super("eq.Trader", [
            { no: 1, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "itemid", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "itemcost", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Trader>): Trader {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = 0;
        message.itemid = [];
        message.itemcost = [];
        if (value !== undefined)
            reflectionMergePartial<Trader>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Trader): Trader {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 code */ 1:
                    message.code = reader.int32();
                    break;
                case /* repeated int32 itemid */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.itemid.push(reader.int32());
                    else
                        message.itemid.push(reader.int32());
                    break;
                case /* repeated int32 itemcost */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.itemcost.push(reader.int32());
                    else
                        message.itemcost.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Trader, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).int32(message.code);
        /* repeated int32 itemid = 2; */
        if (message.itemid.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.itemid.length; i++)
                writer.int32(message.itemid[i]);
            writer.join();
        }
        /* repeated int32 itemcost = 3; */
        if (message.itemcost.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.itemcost.length; i++)
                writer.int32(message.itemcost[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Trader
 */
export const Trader = new Trader$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClickTrader$Type extends MessageType<ClickTrader> {
    constructor() {
        super("eq.ClickTrader", [
            { no: 1, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "itemcost", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ClickTrader>): ClickTrader {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = 0;
        message.itemcost = [];
        if (value !== undefined)
            reflectionMergePartial<ClickTrader>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClickTrader): ClickTrader {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 code */ 1:
                    message.code = reader.int32();
                    break;
                case /* repeated int32 itemcost */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.itemcost.push(reader.int32());
                    else
                        message.itemcost.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClickTrader, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).int32(message.code);
        /* repeated int32 itemcost = 2; */
        if (message.itemcost.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.itemcost.length; i++)
                writer.int32(message.itemcost[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.ClickTrader
 */
export const ClickTrader = new ClickTrader$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetItems$Type extends MessageType<GetItems> {
    constructor() {
        super("eq.GetItems", [
            { no: 1, name: "items", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetItems>): GetItems {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.items = [];
        if (value !== undefined)
            reflectionMergePartial<GetItems>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetItems): GetItems {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 items */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.items.push(reader.int32());
                    else
                        message.items.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetItems, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 items = 1; */
        if (message.items.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.items.length; i++)
                writer.int32(message.items[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.GetItems
 */
export const GetItems = new GetItems$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BecomeTrader$Type extends MessageType<BecomeTrader> {
    constructor() {
        super("eq.BecomeTrader", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<BecomeTrader>): BecomeTrader {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.code = 0;
        if (value !== undefined)
            reflectionMergePartial<BecomeTrader>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BecomeTrader): BecomeTrader {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BecomeTrader, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.BecomeTrader
 */
export const BecomeTrader = new BecomeTrader$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Trader_ShowItems$Type extends MessageType<Trader_ShowItems> {
    constructor() {
        super("eq.Trader_ShowItems", [
            { no: 1, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "trader_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Trader_ShowItems>): Trader_ShowItems {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = 0;
        message.traderId = 0;
        if (value !== undefined)
            reflectionMergePartial<Trader_ShowItems>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Trader_ShowItems): Trader_ShowItems {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 code */ 1:
                    message.code = reader.int32();
                    break;
                case /* int32 trader_id */ 2:
                    message.traderId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Trader_ShowItems, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).int32(message.code);
        /* int32 trader_id = 2; */
        if (message.traderId !== 0)
            writer.tag(2, WireType.Varint).int32(message.traderId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Trader_ShowItems
 */
export const Trader_ShowItems = new Trader_ShowItems$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TraderBuy$Type extends MessageType<TraderBuy> {
    constructor() {
        super("eq.TraderBuy", [
            { no: 1, name: "action", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "price", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "trader_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "item_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "item_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "already_sold", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "quantity", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TraderBuy>): TraderBuy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.action = 0;
        message.price = 0;
        message.traderId = 0;
        message.itemName = "";
        message.itemId = 0;
        message.alreadySold = 0;
        message.quantity = 0;
        if (value !== undefined)
            reflectionMergePartial<TraderBuy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TraderBuy): TraderBuy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 action */ 1:
                    message.action = reader.int32();
                    break;
                case /* int32 price */ 2:
                    message.price = reader.int32();
                    break;
                case /* int32 trader_id */ 3:
                    message.traderId = reader.int32();
                    break;
                case /* string item_name */ 4:
                    message.itemName = reader.string();
                    break;
                case /* int32 item_id */ 5:
                    message.itemId = reader.int32();
                    break;
                case /* int32 already_sold */ 6:
                    message.alreadySold = reader.int32();
                    break;
                case /* int32 quantity */ 7:
                    message.quantity = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TraderBuy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 action = 1; */
        if (message.action !== 0)
            writer.tag(1, WireType.Varint).int32(message.action);
        /* int32 price = 2; */
        if (message.price !== 0)
            writer.tag(2, WireType.Varint).int32(message.price);
        /* int32 trader_id = 3; */
        if (message.traderId !== 0)
            writer.tag(3, WireType.Varint).int32(message.traderId);
        /* string item_name = 4; */
        if (message.itemName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.itemName);
        /* int32 item_id = 5; */
        if (message.itemId !== 0)
            writer.tag(5, WireType.Varint).int32(message.itemId);
        /* int32 already_sold = 6; */
        if (message.alreadySold !== 0)
            writer.tag(6, WireType.Varint).int32(message.alreadySold);
        /* int32 quantity = 7; */
        if (message.quantity !== 0)
            writer.tag(7, WireType.Varint).int32(message.quantity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.TraderBuy
 */
export const TraderBuy = new TraderBuy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TraderItemUpdate$Type extends MessageType<TraderItemUpdate> {
    constructor() {
        super("eq.TraderItemUpdate", [
            { no: 1, name: "traderid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "fromslot", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "toslot", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "charges", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TraderItemUpdate>): TraderItemUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.traderid = 0;
        message.fromslot = 0;
        message.toslot = 0;
        message.charges = 0;
        if (value !== undefined)
            reflectionMergePartial<TraderItemUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TraderItemUpdate): TraderItemUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 traderid */ 1:
                    message.traderid = reader.int32();
                    break;
                case /* int32 fromslot */ 2:
                    message.fromslot = reader.int32();
                    break;
                case /* int32 toslot */ 3:
                    message.toslot = reader.int32();
                    break;
                case /* int32 charges */ 4:
                    message.charges = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TraderItemUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 traderid = 1; */
        if (message.traderid !== 0)
            writer.tag(1, WireType.Varint).int32(message.traderid);
        /* int32 fromslot = 2; */
        if (message.fromslot !== 0)
            writer.tag(2, WireType.Varint).int32(message.fromslot);
        /* int32 toslot = 3; */
        if (message.toslot !== 0)
            writer.tag(3, WireType.Varint).int32(message.toslot);
        /* int32 charges = 4; */
        if (message.charges !== 0)
            writer.tag(4, WireType.Varint).int32(message.charges);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.TraderItemUpdate
 */
export const TraderItemUpdate = new TraderItemUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MoneyUpdate$Type extends MessageType<MoneyUpdate> {
    constructor() {
        super("eq.MoneyUpdate", [
            { no: 1, name: "platinum", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "gold", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "silver", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "copper", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<MoneyUpdate>): MoneyUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.platinum = 0;
        message.gold = 0;
        message.silver = 0;
        message.copper = 0;
        if (value !== undefined)
            reflectionMergePartial<MoneyUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MoneyUpdate): MoneyUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 platinum */ 1:
                    message.platinum = reader.int32();
                    break;
                case /* int32 gold */ 2:
                    message.gold = reader.int32();
                    break;
                case /* int32 silver */ 3:
                    message.silver = reader.int32();
                    break;
                case /* int32 copper */ 4:
                    message.copper = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MoneyUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 platinum = 1; */
        if (message.platinum !== 0)
            writer.tag(1, WireType.Varint).int32(message.platinum);
        /* int32 gold = 2; */
        if (message.gold !== 0)
            writer.tag(2, WireType.Varint).int32(message.gold);
        /* int32 silver = 3; */
        if (message.silver !== 0)
            writer.tag(3, WireType.Varint).int32(message.silver);
        /* int32 copper = 4; */
        if (message.copper !== 0)
            writer.tag(4, WireType.Varint).int32(message.copper);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.MoneyUpdate
 */
export const MoneyUpdate = new MoneyUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TraderDelItem$Type extends MessageType<TraderDelItem> {
    constructor() {
        super("eq.TraderDelItem", [
            { no: 1, name: "slotid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "quantity", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TraderDelItem>): TraderDelItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.slotid = 0;
        message.quantity = 0;
        if (value !== undefined)
            reflectionMergePartial<TraderDelItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TraderDelItem): TraderDelItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 slotid */ 1:
                    message.slotid = reader.int32();
                    break;
                case /* int32 quantity */ 2:
                    message.quantity = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TraderDelItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 slotid = 1; */
        if (message.slotid !== 0)
            writer.tag(1, WireType.Varint).int32(message.slotid);
        /* int32 quantity = 2; */
        if (message.quantity !== 0)
            writer.tag(2, WireType.Varint).int32(message.quantity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.TraderDelItem
 */
export const TraderDelItem = new TraderDelItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TraderClick$Type extends MessageType<TraderClick> {
    constructor() {
        super("eq.TraderClick", [
            { no: 1, name: "traderid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "approval", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TraderClick>): TraderClick {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.traderid = 0;
        message.approval = 0;
        if (value !== undefined)
            reflectionMergePartial<TraderClick>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TraderClick): TraderClick {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 traderid */ 1:
                    message.traderid = reader.int32();
                    break;
                case /* int32 approval */ 2:
                    message.approval = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TraderClick, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 traderid = 1; */
        if (message.traderid !== 0)
            writer.tag(1, WireType.Varint).int32(message.traderid);
        /* int32 approval = 2; */
        if (message.approval !== 0)
            writer.tag(2, WireType.Varint).int32(message.approval);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.TraderClick
 */
export const TraderClick = new TraderClick$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FormattedMessage$Type extends MessageType<FormattedMessage> {
    constructor() {
        super("eq.FormattedMessage", [
            { no: 1, name: "string_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FormattedMessage>): FormattedMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.stringId = 0;
        message.type = 0;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<FormattedMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FormattedMessage): FormattedMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 string_id */ 1:
                    message.stringId = reader.int32();
                    break;
                case /* int32 type */ 2:
                    message.type = reader.int32();
                    break;
                case /* string message */ 3:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FormattedMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 string_id = 1; */
        if (message.stringId !== 0)
            writer.tag(1, WireType.Varint).int32(message.stringId);
        /* int32 type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* string message = 3; */
        if (message.message !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.FormattedMessage
 */
export const FormattedMessage = new FormattedMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SimpleMessage$Type extends MessageType<SimpleMessage> {
    constructor() {
        super("eq.SimpleMessage", [
            { no: 1, name: "string_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "color", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SimpleMessage>): SimpleMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.stringId = 0;
        message.color = 0;
        if (value !== undefined)
            reflectionMergePartial<SimpleMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SimpleMessage): SimpleMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 string_id */ 1:
                    message.stringId = reader.int32();
                    break;
                case /* int32 color */ 2:
                    message.color = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SimpleMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 string_id = 1; */
        if (message.stringId !== 0)
            writer.tag(1, WireType.Varint).int32(message.stringId);
        /* int32 color = 2; */
        if (message.color !== 0)
            writer.tag(2, WireType.Varint).int32(message.color);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.SimpleMessage
 */
export const SimpleMessage = new SimpleMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GuildMemberEntry$Type extends MessageType<GuildMemberEntry> {
    constructor() {
        super("eq.GuildMemberEntry", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "level", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "banker", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "char_class", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "rank", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "time_last_on", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "tribute_enable", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "total_tribute", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "last_tribute", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "public_note", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "zoneinstance", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "zone_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GuildMemberEntry>): GuildMemberEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.level = 0;
        message.banker = 0;
        message.charClass = 0;
        message.rank = 0;
        message.timeLastOn = 0;
        message.tributeEnable = 0;
        message.totalTribute = 0;
        message.lastTribute = 0;
        message.publicNote = "";
        message.zoneinstance = 0;
        message.zoneId = 0;
        if (value !== undefined)
            reflectionMergePartial<GuildMemberEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GuildMemberEntry): GuildMemberEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* int32 level */ 2:
                    message.level = reader.int32();
                    break;
                case /* int32 banker */ 3:
                    message.banker = reader.int32();
                    break;
                case /* int32 char_class */ 4:
                    message.charClass = reader.int32();
                    break;
                case /* int32 rank */ 5:
                    message.rank = reader.int32();
                    break;
                case /* int32 time_last_on */ 6:
                    message.timeLastOn = reader.int32();
                    break;
                case /* int32 tribute_enable */ 7:
                    message.tributeEnable = reader.int32();
                    break;
                case /* int32 total_tribute */ 8:
                    message.totalTribute = reader.int32();
                    break;
                case /* int32 last_tribute */ 9:
                    message.lastTribute = reader.int32();
                    break;
                case /* string public_note */ 10:
                    message.publicNote = reader.string();
                    break;
                case /* int32 zoneinstance */ 11:
                    message.zoneinstance = reader.int32();
                    break;
                case /* int32 zone_id */ 12:
                    message.zoneId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GuildMemberEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* int32 level = 2; */
        if (message.level !== 0)
            writer.tag(2, WireType.Varint).int32(message.level);
        /* int32 banker = 3; */
        if (message.banker !== 0)
            writer.tag(3, WireType.Varint).int32(message.banker);
        /* int32 char_class = 4; */
        if (message.charClass !== 0)
            writer.tag(4, WireType.Varint).int32(message.charClass);
        /* int32 rank = 5; */
        if (message.rank !== 0)
            writer.tag(5, WireType.Varint).int32(message.rank);
        /* int32 time_last_on = 6; */
        if (message.timeLastOn !== 0)
            writer.tag(6, WireType.Varint).int32(message.timeLastOn);
        /* int32 tribute_enable = 7; */
        if (message.tributeEnable !== 0)
            writer.tag(7, WireType.Varint).int32(message.tributeEnable);
        /* int32 total_tribute = 8; */
        if (message.totalTribute !== 0)
            writer.tag(8, WireType.Varint).int32(message.totalTribute);
        /* int32 last_tribute = 9; */
        if (message.lastTribute !== 0)
            writer.tag(9, WireType.Varint).int32(message.lastTribute);
        /* string public_note = 10; */
        if (message.publicNote !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.publicNote);
        /* int32 zoneinstance = 11; */
        if (message.zoneinstance !== 0)
            writer.tag(11, WireType.Varint).int32(message.zoneinstance);
        /* int32 zone_id = 12; */
        if (message.zoneId !== 0)
            writer.tag(12, WireType.Varint).int32(message.zoneId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.GuildMemberEntry
 */
export const GuildMemberEntry = new GuildMemberEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GuildMembers$Type extends MessageType<GuildMembers> {
    constructor() {
        super("eq.GuildMembers", [
            { no: 1, name: "player_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "member", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GuildMemberEntry }
        ]);
    }
    create(value?: PartialMessage<GuildMembers>): GuildMembers {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.playerName = "";
        message.count = 0;
        message.member = [];
        if (value !== undefined)
            reflectionMergePartial<GuildMembers>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GuildMembers): GuildMembers {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string player_name */ 1:
                    message.playerName = reader.string();
                    break;
                case /* int32 count */ 2:
                    message.count = reader.int32();
                    break;
                case /* repeated eq.GuildMemberEntry member */ 3:
                    message.member.push(GuildMemberEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GuildMembers, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string player_name = 1; */
        if (message.playerName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.playerName);
        /* int32 count = 2; */
        if (message.count !== 0)
            writer.tag(2, WireType.Varint).int32(message.count);
        /* repeated eq.GuildMemberEntry member = 3; */
        for (let i = 0; i < message.member.length; i++)
            GuildMemberEntry.internalBinaryWrite(message.member[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.GuildMembers
 */
export const GuildMembers = new GuildMembers$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GuildMOTD$Type extends MessageType<GuildMOTD> {
    constructor() {
        super("eq.GuildMOTD", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "setby_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "motd", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GuildMOTD>): GuildMOTD {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.setbyName = "";
        message.motd = "";
        if (value !== undefined)
            reflectionMergePartial<GuildMOTD>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GuildMOTD): GuildMOTD {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string setby_name */ 2:
                    message.setbyName = reader.string();
                    break;
                case /* string motd */ 3:
                    message.motd = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GuildMOTD, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string setby_name = 2; */
        if (message.setbyName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.setbyName);
        /* string motd = 3; */
        if (message.motd !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.motd);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.GuildMOTD
 */
export const GuildMOTD = new GuildMOTD$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GuildUpdate_PublicNote$Type extends MessageType<GuildUpdate_PublicNote> {
    constructor() {
        super("eq.GuildUpdate_PublicNote", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "target", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "note", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GuildUpdate_PublicNote>): GuildUpdate_PublicNote {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.target = "";
        message.note = "";
        if (value !== undefined)
            reflectionMergePartial<GuildUpdate_PublicNote>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GuildUpdate_PublicNote): GuildUpdate_PublicNote {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string target */ 2:
                    message.target = reader.string();
                    break;
                case /* string note */ 3:
                    message.note = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GuildUpdate_PublicNote, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string target = 2; */
        if (message.target !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.target);
        /* string note = 3; */
        if (message.note !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.note);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.GuildUpdate_PublicNote
 */
export const GuildUpdate_PublicNote = new GuildUpdate_PublicNote$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GuildDemote$Type extends MessageType<GuildDemote> {
    constructor() {
        super("eq.GuildDemote", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "target", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GuildDemote>): GuildDemote {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.target = "";
        if (value !== undefined)
            reflectionMergePartial<GuildDemote>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GuildDemote): GuildDemote {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string target */ 2:
                    message.target = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GuildDemote, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string target = 2; */
        if (message.target !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.target);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.GuildDemote
 */
export const GuildDemote = new GuildDemote$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GuildRemove$Type extends MessageType<GuildRemove> {
    constructor() {
        super("eq.GuildRemove", [
            { no: 1, name: "target", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "leaderstatus", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GuildRemove>): GuildRemove {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.target = "";
        message.name = "";
        message.leaderstatus = 0;
        if (value !== undefined)
            reflectionMergePartial<GuildRemove>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GuildRemove): GuildRemove {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string target */ 1:
                    message.target = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* int32 leaderstatus */ 3:
                    message.leaderstatus = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GuildRemove, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string target = 1; */
        if (message.target !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.target);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* int32 leaderstatus = 3; */
        if (message.leaderstatus !== 0)
            writer.tag(3, WireType.Varint).int32(message.leaderstatus);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.GuildRemove
 */
export const GuildRemove = new GuildRemove$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GuildMakeLeader$Type extends MessageType<GuildMakeLeader> {
    constructor() {
        super("eq.GuildMakeLeader", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "target", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GuildMakeLeader>): GuildMakeLeader {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.target = "";
        if (value !== undefined)
            reflectionMergePartial<GuildMakeLeader>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GuildMakeLeader): GuildMakeLeader {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string target */ 2:
                    message.target = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GuildMakeLeader, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string target = 2; */
        if (message.target !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.target);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.GuildMakeLeader
 */
export const GuildMakeLeader = new GuildMakeLeader$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Make_Pet$Type extends MessageType<Make_Pet> {
    constructor() {
        super("eq.Make_Pet", [
            { no: 1, name: "level", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "char_class", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "race", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "texture", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "pettype", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "size", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "min_dmg", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "max_dmg", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Make_Pet>): Make_Pet {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.level = 0;
        message.charClass = 0;
        message.race = 0;
        message.texture = 0;
        message.pettype = 0;
        message.size = 0;
        message.type = 0;
        message.minDmg = 0;
        message.maxDmg = 0;
        if (value !== undefined)
            reflectionMergePartial<Make_Pet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Make_Pet): Make_Pet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 level */ 1:
                    message.level = reader.int32();
                    break;
                case /* int32 char_class */ 2:
                    message.charClass = reader.int32();
                    break;
                case /* int32 race */ 3:
                    message.race = reader.int32();
                    break;
                case /* int32 texture */ 4:
                    message.texture = reader.int32();
                    break;
                case /* int32 pettype */ 5:
                    message.pettype = reader.int32();
                    break;
                case /* float size */ 6:
                    message.size = reader.float();
                    break;
                case /* int32 type */ 7:
                    message.type = reader.int32();
                    break;
                case /* int32 min_dmg */ 8:
                    message.minDmg = reader.int32();
                    break;
                case /* int32 max_dmg */ 9:
                    message.maxDmg = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Make_Pet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 level = 1; */
        if (message.level !== 0)
            writer.tag(1, WireType.Varint).int32(message.level);
        /* int32 char_class = 2; */
        if (message.charClass !== 0)
            writer.tag(2, WireType.Varint).int32(message.charClass);
        /* int32 race = 3; */
        if (message.race !== 0)
            writer.tag(3, WireType.Varint).int32(message.race);
        /* int32 texture = 4; */
        if (message.texture !== 0)
            writer.tag(4, WireType.Varint).int32(message.texture);
        /* int32 pettype = 5; */
        if (message.pettype !== 0)
            writer.tag(5, WireType.Varint).int32(message.pettype);
        /* float size = 6; */
        if (message.size !== 0)
            writer.tag(6, WireType.Bit32).float(message.size);
        /* int32 type = 7; */
        if (message.type !== 0)
            writer.tag(7, WireType.Varint).int32(message.type);
        /* int32 min_dmg = 8; */
        if (message.minDmg !== 0)
            writer.tag(8, WireType.Varint).int32(message.minDmg);
        /* int32 max_dmg = 9; */
        if (message.maxDmg !== 0)
            writer.tag(9, WireType.Varint).int32(message.maxDmg);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Make_Pet
 */
export const Make_Pet = new Make_Pet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Ground_Spawn$Type extends MessageType<Ground_Spawn> {
    constructor() {
        super("eq.Ground_Spawn", [
            { no: 1, name: "max_x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "max_y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "min_x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "min_y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "max_z", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "heading", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "item", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "max_allowed", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "respawntimer", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Ground_Spawn>): Ground_Spawn {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.maxX = 0;
        message.maxY = 0;
        message.minX = 0;
        message.minY = 0;
        message.maxZ = 0;
        message.heading = 0;
        message.name = "";
        message.item = 0;
        message.maxAllowed = 0;
        message.respawntimer = 0;
        if (value !== undefined)
            reflectionMergePartial<Ground_Spawn>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Ground_Spawn): Ground_Spawn {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float max_x */ 1:
                    message.maxX = reader.float();
                    break;
                case /* float max_y */ 2:
                    message.maxY = reader.float();
                    break;
                case /* float min_x */ 3:
                    message.minX = reader.float();
                    break;
                case /* float min_y */ 4:
                    message.minY = reader.float();
                    break;
                case /* float max_z */ 5:
                    message.maxZ = reader.float();
                    break;
                case /* float heading */ 6:
                    message.heading = reader.float();
                    break;
                case /* string name */ 7:
                    message.name = reader.string();
                    break;
                case /* int32 item */ 8:
                    message.item = reader.int32();
                    break;
                case /* int32 max_allowed */ 9:
                    message.maxAllowed = reader.int32();
                    break;
                case /* int32 respawntimer */ 10:
                    message.respawntimer = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Ground_Spawn, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float max_x = 1; */
        if (message.maxX !== 0)
            writer.tag(1, WireType.Bit32).float(message.maxX);
        /* float max_y = 2; */
        if (message.maxY !== 0)
            writer.tag(2, WireType.Bit32).float(message.maxY);
        /* float min_x = 3; */
        if (message.minX !== 0)
            writer.tag(3, WireType.Bit32).float(message.minX);
        /* float min_y = 4; */
        if (message.minY !== 0)
            writer.tag(4, WireType.Bit32).float(message.minY);
        /* float max_z = 5; */
        if (message.maxZ !== 0)
            writer.tag(5, WireType.Bit32).float(message.maxZ);
        /* float heading = 6; */
        if (message.heading !== 0)
            writer.tag(6, WireType.Bit32).float(message.heading);
        /* string name = 7; */
        if (message.name !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.name);
        /* int32 item = 8; */
        if (message.item !== 0)
            writer.tag(8, WireType.Varint).int32(message.item);
        /* int32 max_allowed = 9; */
        if (message.maxAllowed !== 0)
            writer.tag(9, WireType.Varint).int32(message.maxAllowed);
        /* int32 respawntimer = 10; */
        if (message.respawntimer !== 0)
            writer.tag(10, WireType.Varint).int32(message.respawntimer);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Ground_Spawn
 */
export const Ground_Spawn = new Ground_Spawn$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Ground_Spawns$Type extends MessageType<Ground_Spawns> {
    constructor() {
        super("eq.Ground_Spawns", [
            { no: 1, name: "spawn", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Ground_Spawn }
        ]);
    }
    create(value?: PartialMessage<Ground_Spawns>): Ground_Spawns {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.spawn = [];
        if (value !== undefined)
            reflectionMergePartial<Ground_Spawns>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Ground_Spawns): Ground_Spawns {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eq.Ground_Spawn spawn */ 1:
                    message.spawn.push(Ground_Spawn.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Ground_Spawns, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated eq.Ground_Spawn spawn = 1; */
        for (let i = 0; i < message.spawn.length; i++)
            Ground_Spawn.internalBinaryWrite(message.spawn[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Ground_Spawns
 */
export const Ground_Spawns = new Ground_Spawns$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ApproveZone$Type extends MessageType<ApproveZone> {
    constructor() {
        super("eq.ApproveZone", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "zoneid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "approve", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ApproveZone>): ApproveZone {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.zoneid = 0;
        message.approve = 0;
        if (value !== undefined)
            reflectionMergePartial<ApproveZone>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ApproveZone): ApproveZone {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* int32 zoneid */ 2:
                    message.zoneid = reader.int32();
                    break;
                case /* int32 approve */ 3:
                    message.approve = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ApproveZone, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* int32 zoneid = 2; */
        if (message.zoneid !== 0)
            writer.tag(2, WireType.Varint).int32(message.zoneid);
        /* int32 approve = 3; */
        if (message.approve !== 0)
            writer.tag(3, WireType.Varint).int32(message.approve);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.ApproveZone
 */
export const ApproveZone = new ApproveZone$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ZoneInSendName$Type extends MessageType<ZoneInSendName> {
    constructor() {
        super("eq.ZoneInSendName", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name2", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ZoneInSendName>): ZoneInSendName {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.name2 = "";
        if (value !== undefined)
            reflectionMergePartial<ZoneInSendName>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ZoneInSendName): ZoneInSendName {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string name2 */ 2:
                    message.name2 = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ZoneInSendName, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string name2 = 2; */
        if (message.name2 !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name2);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.ZoneInSendName
 */
export const ZoneInSendName = new ZoneInSendName$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ZoneInSendName2$Type extends MessageType<ZoneInSendName2> {
    constructor() {
        super("eq.ZoneInSendName2", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ZoneInSendName2>): ZoneInSendName2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<ZoneInSendName2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ZoneInSendName2): ZoneInSendName2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ZoneInSendName2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.ZoneInSendName2
 */
export const ZoneInSendName2 = new ZoneInSendName2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartTribute$Type extends MessageType<StartTribute> {
    constructor() {
        super("eq.StartTribute", [
            { no: 1, name: "client_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "tribute_master_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "response", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<StartTribute>): StartTribute {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clientId = 0;
        message.tributeMasterId = 0;
        message.response = 0;
        if (value !== undefined)
            reflectionMergePartial<StartTribute>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartTribute): StartTribute {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 client_id */ 1:
                    message.clientId = reader.int32();
                    break;
                case /* int32 tribute_master_id */ 2:
                    message.tributeMasterId = reader.int32();
                    break;
                case /* int32 response */ 3:
                    message.response = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartTribute, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 client_id = 1; */
        if (message.clientId !== 0)
            writer.tag(1, WireType.Varint).int32(message.clientId);
        /* int32 tribute_master_id = 2; */
        if (message.tributeMasterId !== 0)
            writer.tag(2, WireType.Varint).int32(message.tributeMasterId);
        /* int32 response = 3; */
        if (message.response !== 0)
            writer.tag(3, WireType.Varint).int32(message.response);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.StartTribute
 */
export const StartTribute = new StartTribute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TributeLevel$Type extends MessageType<TributeLevel> {
    constructor() {
        super("eq.TributeLevel", [
            { no: 1, name: "level", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "tribute_item_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "cost", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TributeLevel>): TributeLevel {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.level = 0;
        message.tributeItemId = 0;
        message.cost = 0;
        if (value !== undefined)
            reflectionMergePartial<TributeLevel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TributeLevel): TributeLevel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 level */ 1:
                    message.level = reader.int32();
                    break;
                case /* int32 tribute_item_id */ 2:
                    message.tributeItemId = reader.int32();
                    break;
                case /* int32 cost */ 3:
                    message.cost = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TributeLevel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 level = 1; */
        if (message.level !== 0)
            writer.tag(1, WireType.Varint).int32(message.level);
        /* int32 tribute_item_id = 2; */
        if (message.tributeItemId !== 0)
            writer.tag(2, WireType.Varint).int32(message.tributeItemId);
        /* int32 cost = 3; */
        if (message.cost !== 0)
            writer.tag(3, WireType.Varint).int32(message.cost);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.TributeLevel
 */
export const TributeLevel = new TributeLevel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TributeAbility$Type extends MessageType<TributeAbility> {
    constructor() {
        super("eq.TributeAbility", [
            { no: 1, name: "tribute_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "tier_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "tiers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TributeLevel },
            { no: 4, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TributeAbility>): TributeAbility {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tributeId = 0;
        message.tierCount = 0;
        message.tiers = [];
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<TributeAbility>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TributeAbility): TributeAbility {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 tribute_id */ 1:
                    message.tributeId = reader.int32();
                    break;
                case /* int32 tier_count */ 2:
                    message.tierCount = reader.int32();
                    break;
                case /* repeated eq.TributeLevel tiers */ 3:
                    message.tiers.push(TributeLevel.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string name */ 4:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TributeAbility, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 tribute_id = 1; */
        if (message.tributeId !== 0)
            writer.tag(1, WireType.Varint).int32(message.tributeId);
        /* int32 tier_count = 2; */
        if (message.tierCount !== 0)
            writer.tag(2, WireType.Varint).int32(message.tierCount);
        /* repeated eq.TributeLevel tiers = 3; */
        for (let i = 0; i < message.tiers.length; i++)
            TributeLevel.internalBinaryWrite(message.tiers[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string name = 4; */
        if (message.name !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.TributeAbility
 */
export const TributeAbility = new TributeAbility$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GuildTributeAbility$Type extends MessageType<GuildTributeAbility> {
    constructor() {
        super("eq.GuildTributeAbility", [
            { no: 1, name: "guild_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "ability", kind: "message", T: () => TributeAbility }
        ]);
    }
    create(value?: PartialMessage<GuildTributeAbility>): GuildTributeAbility {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.guildId = 0;
        if (value !== undefined)
            reflectionMergePartial<GuildTributeAbility>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GuildTributeAbility): GuildTributeAbility {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 guild_id */ 1:
                    message.guildId = reader.int32();
                    break;
                case /* eq.TributeAbility ability */ 2:
                    message.ability = TributeAbility.internalBinaryRead(reader, reader.uint32(), options, message.ability);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GuildTributeAbility, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 guild_id = 1; */
        if (message.guildId !== 0)
            writer.tag(1, WireType.Varint).int32(message.guildId);
        /* eq.TributeAbility ability = 2; */
        if (message.ability)
            TributeAbility.internalBinaryWrite(message.ability, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.GuildTributeAbility
 */
export const GuildTributeAbility = new GuildTributeAbility$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SelectTributeReq$Type extends MessageType<SelectTributeReq> {
    constructor() {
        super("eq.SelectTributeReq", [
            { no: 1, name: "client_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "tribute_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SelectTributeReq>): SelectTributeReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clientId = 0;
        message.tributeId = 0;
        if (value !== undefined)
            reflectionMergePartial<SelectTributeReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SelectTributeReq): SelectTributeReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 client_id */ 1:
                    message.clientId = reader.int32();
                    break;
                case /* int32 tribute_id */ 2:
                    message.tributeId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SelectTributeReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 client_id = 1; */
        if (message.clientId !== 0)
            writer.tag(1, WireType.Varint).int32(message.clientId);
        /* int32 tribute_id = 2; */
        if (message.tributeId !== 0)
            writer.tag(2, WireType.Varint).int32(message.tributeId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.SelectTributeReq
 */
export const SelectTributeReq = new SelectTributeReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SelectTributeReply$Type extends MessageType<SelectTributeReply> {
    constructor() {
        super("eq.SelectTributeReply", [
            { no: 1, name: "client_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "tribute_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "desc", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SelectTributeReply>): SelectTributeReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clientId = 0;
        message.tributeId = 0;
        message.desc = "";
        if (value !== undefined)
            reflectionMergePartial<SelectTributeReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SelectTributeReply): SelectTributeReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 client_id */ 1:
                    message.clientId = reader.int32();
                    break;
                case /* int32 tribute_id */ 2:
                    message.tributeId = reader.int32();
                    break;
                case /* string desc */ 3:
                    message.desc = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SelectTributeReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 client_id = 1; */
        if (message.clientId !== 0)
            writer.tag(1, WireType.Varint).int32(message.clientId);
        /* int32 tribute_id = 2; */
        if (message.tributeId !== 0)
            writer.tag(2, WireType.Varint).int32(message.tributeId);
        /* string desc = 3; */
        if (message.desc !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.desc);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.SelectTributeReply
 */
export const SelectTributeReply = new SelectTributeReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TributeInfo$Type extends MessageType<TributeInfo> {
    constructor() {
        super("eq.TributeInfo", [
            { no: 1, name: "active", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "tributes", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "tiers", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "tribute_master_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TributeInfo>): TributeInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.active = 0;
        message.tributes = [];
        message.tiers = [];
        message.tributeMasterId = 0;
        if (value !== undefined)
            reflectionMergePartial<TributeInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TributeInfo): TributeInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 active */ 1:
                    message.active = reader.int32();
                    break;
                case /* repeated int32 tributes */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.tributes.push(reader.int32());
                    else
                        message.tributes.push(reader.int32());
                    break;
                case /* repeated int32 tiers */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.tiers.push(reader.int32());
                    else
                        message.tiers.push(reader.int32());
                    break;
                case /* int32 tribute_master_id */ 4:
                    message.tributeMasterId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TributeInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 active = 1; */
        if (message.active !== 0)
            writer.tag(1, WireType.Varint).int32(message.active);
        /* repeated int32 tributes = 2; */
        if (message.tributes.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.tributes.length; i++)
                writer.int32(message.tributes[i]);
            writer.join();
        }
        /* repeated int32 tiers = 3; */
        if (message.tiers.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.tiers.length; i++)
                writer.int32(message.tiers[i]);
            writer.join();
        }
        /* int32 tribute_master_id = 4; */
        if (message.tributeMasterId !== 0)
            writer.tag(4, WireType.Varint).int32(message.tributeMasterId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.TributeInfo
 */
export const TributeInfo = new TributeInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TributeItem$Type extends MessageType<TributeItem> {
    constructor() {
        super("eq.TributeItem", [
            { no: 1, name: "slot", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "quantity", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "tribute_master_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "tribute_points", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TributeItem>): TributeItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.slot = 0;
        message.quantity = 0;
        message.tributeMasterId = 0;
        message.tributePoints = 0;
        if (value !== undefined)
            reflectionMergePartial<TributeItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TributeItem): TributeItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 slot */ 1:
                    message.slot = reader.int32();
                    break;
                case /* int32 quantity */ 2:
                    message.quantity = reader.int32();
                    break;
                case /* int32 tribute_master_id */ 3:
                    message.tributeMasterId = reader.int32();
                    break;
                case /* int32 tribute_points */ 4:
                    message.tributePoints = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TributeItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 slot = 1; */
        if (message.slot !== 0)
            writer.tag(1, WireType.Varint).int32(message.slot);
        /* int32 quantity = 2; */
        if (message.quantity !== 0)
            writer.tag(2, WireType.Varint).int32(message.quantity);
        /* int32 tribute_master_id = 3; */
        if (message.tributeMasterId !== 0)
            writer.tag(3, WireType.Varint).int32(message.tributeMasterId);
        /* int32 tribute_points = 4; */
        if (message.tributePoints !== 0)
            writer.tag(4, WireType.Varint).int32(message.tributePoints);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.TributeItem
 */
export const TributeItem = new TributeItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TributePoint$Type extends MessageType<TributePoint> {
    constructor() {
        super("eq.TributePoint", [
            { no: 1, name: "tribute_points", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "career_tribute_points", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TributePoint>): TributePoint {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tributePoints = 0;
        message.careerTributePoints = 0;
        if (value !== undefined)
            reflectionMergePartial<TributePoint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TributePoint): TributePoint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 tribute_points */ 1:
                    message.tributePoints = reader.int32();
                    break;
                case /* int32 career_tribute_points */ 2:
                    message.careerTributePoints = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TributePoint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 tribute_points = 1; */
        if (message.tributePoints !== 0)
            writer.tag(1, WireType.Varint).int32(message.tributePoints);
        /* int32 career_tribute_points = 2; */
        if (message.careerTributePoints !== 0)
            writer.tag(2, WireType.Varint).int32(message.careerTributePoints);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.TributePoint
 */
export const TributePoint = new TributePoint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TributeMoney$Type extends MessageType<TributeMoney> {
    constructor() {
        super("eq.TributeMoney", [
            { no: 1, name: "platinum", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "tribute_master_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "tribute_points", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TributeMoney>): TributeMoney {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.platinum = 0;
        message.tributeMasterId = 0;
        message.tributePoints = 0;
        if (value !== undefined)
            reflectionMergePartial<TributeMoney>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TributeMoney): TributeMoney {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 platinum */ 1:
                    message.platinum = reader.int32();
                    break;
                case /* int32 tribute_master_id */ 2:
                    message.tributeMasterId = reader.int32();
                    break;
                case /* int32 tribute_points */ 3:
                    message.tributePoints = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TributeMoney, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 platinum = 1; */
        if (message.platinum !== 0)
            writer.tag(1, WireType.Varint).int32(message.platinum);
        /* int32 tribute_master_id = 2; */
        if (message.tributeMasterId !== 0)
            writer.tag(2, WireType.Varint).int32(message.tributeMasterId);
        /* int32 tribute_points = 3; */
        if (message.tributePoints !== 0)
            writer.tag(3, WireType.Varint).int32(message.tributePoints);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.TributeMoney
 */
export const TributeMoney = new TributeMoney$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Split$Type extends MessageType<Split> {
    constructor() {
        super("eq.Split", [
            { no: 1, name: "platinum", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "gold", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "silver", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "copper", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Split>): Split {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.platinum = 0;
        message.gold = 0;
        message.silver = 0;
        message.copper = 0;
        if (value !== undefined)
            reflectionMergePartial<Split>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Split): Split {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 platinum */ 1:
                    message.platinum = reader.int32();
                    break;
                case /* int32 gold */ 2:
                    message.gold = reader.int32();
                    break;
                case /* int32 silver */ 3:
                    message.silver = reader.int32();
                    break;
                case /* int32 copper */ 4:
                    message.copper = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Split, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 platinum = 1; */
        if (message.platinum !== 0)
            writer.tag(1, WireType.Varint).int32(message.platinum);
        /* int32 gold = 2; */
        if (message.gold !== 0)
            writer.tag(2, WireType.Varint).int32(message.gold);
        /* int32 silver = 3; */
        if (message.silver !== 0)
            writer.tag(3, WireType.Varint).int32(message.silver);
        /* int32 copper = 4; */
        if (message.copper !== 0)
            writer.tag(4, WireType.Varint).int32(message.copper);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Split
 */
export const Split = new Split$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NewCombine$Type extends MessageType<NewCombine> {
    constructor() {
        super("eq.NewCombine", [
            { no: 1, name: "container_slot", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "guildtribute_slot", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<NewCombine>): NewCombine {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.containerSlot = 0;
        message.guildtributeSlot = 0;
        if (value !== undefined)
            reflectionMergePartial<NewCombine>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NewCombine): NewCombine {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 container_slot */ 1:
                    message.containerSlot = reader.int32();
                    break;
                case /* int32 guildtribute_slot */ 2:
                    message.guildtributeSlot = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NewCombine, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 container_slot = 1; */
        if (message.containerSlot !== 0)
            writer.tag(1, WireType.Varint).int32(message.containerSlot);
        /* int32 guildtribute_slot = 2; */
        if (message.guildtributeSlot !== 0)
            writer.tag(2, WireType.Varint).int32(message.guildtributeSlot);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.NewCombine
 */
export const NewCombine = new NewCombine$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradeskillFavorites$Type extends MessageType<TradeskillFavorites> {
    constructor() {
        super("eq.TradeskillFavorites", [
            { no: 1, name: "object_type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "some_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "favorite_recipes", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TradeskillFavorites>): TradeskillFavorites {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.objectType = 0;
        message.someId = 0;
        message.favoriteRecipes = [];
        if (value !== undefined)
            reflectionMergePartial<TradeskillFavorites>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradeskillFavorites): TradeskillFavorites {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 object_type */ 1:
                    message.objectType = reader.int32();
                    break;
                case /* int32 some_id */ 2:
                    message.someId = reader.int32();
                    break;
                case /* repeated int32 favorite_recipes */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.favoriteRecipes.push(reader.int32());
                    else
                        message.favoriteRecipes.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradeskillFavorites, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 object_type = 1; */
        if (message.objectType !== 0)
            writer.tag(1, WireType.Varint).int32(message.objectType);
        /* int32 some_id = 2; */
        if (message.someId !== 0)
            writer.tag(2, WireType.Varint).int32(message.someId);
        /* repeated int32 favorite_recipes = 3; */
        if (message.favoriteRecipes.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.favoriteRecipes.length; i++)
                writer.int32(message.favoriteRecipes[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.TradeskillFavorites
 */
export const TradeskillFavorites = new TradeskillFavorites$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecipesSearch$Type extends MessageType<RecipesSearch> {
    constructor() {
        super("eq.RecipesSearch", [
            { no: 1, name: "object_type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "some_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "mintrivial", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "maxtrivial", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "query", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RecipesSearch>): RecipesSearch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.objectType = 0;
        message.someId = 0;
        message.mintrivial = 0;
        message.maxtrivial = 0;
        message.query = "";
        if (value !== undefined)
            reflectionMergePartial<RecipesSearch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RecipesSearch): RecipesSearch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 object_type */ 1:
                    message.objectType = reader.int32();
                    break;
                case /* int32 some_id */ 2:
                    message.someId = reader.int32();
                    break;
                case /* int32 mintrivial */ 3:
                    message.mintrivial = reader.int32();
                    break;
                case /* int32 maxtrivial */ 4:
                    message.maxtrivial = reader.int32();
                    break;
                case /* string query */ 5:
                    message.query = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RecipesSearch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 object_type = 1; */
        if (message.objectType !== 0)
            writer.tag(1, WireType.Varint).int32(message.objectType);
        /* int32 some_id = 2; */
        if (message.someId !== 0)
            writer.tag(2, WireType.Varint).int32(message.someId);
        /* int32 mintrivial = 3; */
        if (message.mintrivial !== 0)
            writer.tag(3, WireType.Varint).int32(message.mintrivial);
        /* int32 maxtrivial = 4; */
        if (message.maxtrivial !== 0)
            writer.tag(4, WireType.Varint).int32(message.maxtrivial);
        /* string query = 5; */
        if (message.query !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.query);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.RecipesSearch
 */
export const RecipesSearch = new RecipesSearch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecipeReply$Type extends MessageType<RecipeReply> {
    constructor() {
        super("eq.RecipeReply", [
            { no: 1, name: "object_type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "some_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "component_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "recipe_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "trivial", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "recipe_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RecipeReply>): RecipeReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.objectType = 0;
        message.someId = 0;
        message.componentCount = 0;
        message.recipeId = 0;
        message.trivial = 0;
        message.recipeName = "";
        if (value !== undefined)
            reflectionMergePartial<RecipeReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RecipeReply): RecipeReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 object_type */ 1:
                    message.objectType = reader.int32();
                    break;
                case /* int32 some_id */ 2:
                    message.someId = reader.int32();
                    break;
                case /* int32 component_count */ 3:
                    message.componentCount = reader.int32();
                    break;
                case /* int32 recipe_id */ 4:
                    message.recipeId = reader.int32();
                    break;
                case /* int32 trivial */ 5:
                    message.trivial = reader.int32();
                    break;
                case /* string recipe_name */ 6:
                    message.recipeName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RecipeReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 object_type = 1; */
        if (message.objectType !== 0)
            writer.tag(1, WireType.Varint).int32(message.objectType);
        /* int32 some_id = 2; */
        if (message.someId !== 0)
            writer.tag(2, WireType.Varint).int32(message.someId);
        /* int32 component_count = 3; */
        if (message.componentCount !== 0)
            writer.tag(3, WireType.Varint).int32(message.componentCount);
        /* int32 recipe_id = 4; */
        if (message.recipeId !== 0)
            writer.tag(4, WireType.Varint).int32(message.recipeId);
        /* int32 trivial = 5; */
        if (message.trivial !== 0)
            writer.tag(5, WireType.Varint).int32(message.trivial);
        /* string recipe_name = 6; */
        if (message.recipeName !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.recipeName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.RecipeReply
 */
export const RecipeReply = new RecipeReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecipeAutoCombine$Type extends MessageType<RecipeAutoCombine> {
    constructor() {
        super("eq.RecipeAutoCombine", [
            { no: 1, name: "object_type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "some_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "recipe_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "reply_code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<RecipeAutoCombine>): RecipeAutoCombine {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.objectType = 0;
        message.someId = 0;
        message.recipeId = 0;
        message.replyCode = 0;
        if (value !== undefined)
            reflectionMergePartial<RecipeAutoCombine>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RecipeAutoCombine): RecipeAutoCombine {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 object_type */ 1:
                    message.objectType = reader.int32();
                    break;
                case /* int32 some_id */ 2:
                    message.someId = reader.int32();
                    break;
                case /* int32 recipe_id */ 3:
                    message.recipeId = reader.int32();
                    break;
                case /* int32 reply_code */ 4:
                    message.replyCode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RecipeAutoCombine, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 object_type = 1; */
        if (message.objectType !== 0)
            writer.tag(1, WireType.Varint).int32(message.objectType);
        /* int32 some_id = 2; */
        if (message.someId !== 0)
            writer.tag(2, WireType.Varint).int32(message.someId);
        /* int32 recipe_id = 3; */
        if (message.recipeId !== 0)
            writer.tag(3, WireType.Varint).int32(message.recipeId);
        /* int32 reply_code = 4; */
        if (message.replyCode !== 0)
            writer.tag(4, WireType.Varint).int32(message.replyCode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.RecipeAutoCombine
 */
export const RecipeAutoCombine = new RecipeAutoCombine$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LevelAppearance$Type extends MessageType<LevelAppearance> {
    constructor() {
        super("eq.LevelAppearance", [
            { no: 1, name: "spawn_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "parm1", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "value1a", kind: "scalar", jsonName: "value1a", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "value1b", kind: "scalar", jsonName: "value1b", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "parm2", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "value2a", kind: "scalar", jsonName: "value2a", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "value2b", kind: "scalar", jsonName: "value2b", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "parm3", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "value3a", kind: "scalar", jsonName: "value3a", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "value3b", kind: "scalar", jsonName: "value3b", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "parm4", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "value4a", kind: "scalar", jsonName: "value4a", T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "value4b", kind: "scalar", jsonName: "value4b", T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "parm5", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "value5a", kind: "scalar", jsonName: "value5a", T: 5 /*ScalarType.INT32*/ },
            { no: 16, name: "value5b", kind: "scalar", jsonName: "value5b", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<LevelAppearance>): LevelAppearance {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.spawnId = 0;
        message.parm1 = 0;
        message.value1A = 0;
        message.value1B = 0;
        message.parm2 = 0;
        message.value2A = 0;
        message.value2B = 0;
        message.parm3 = 0;
        message.value3A = 0;
        message.value3B = 0;
        message.parm4 = 0;
        message.value4A = 0;
        message.value4B = 0;
        message.parm5 = 0;
        message.value5A = 0;
        message.value5B = 0;
        if (value !== undefined)
            reflectionMergePartial<LevelAppearance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LevelAppearance): LevelAppearance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 spawn_id */ 1:
                    message.spawnId = reader.int32();
                    break;
                case /* int32 parm1 */ 2:
                    message.parm1 = reader.int32();
                    break;
                case /* int32 value1a = 3 [json_name = "value1a"];*/ 3:
                    message.value1A = reader.int32();
                    break;
                case /* int32 value1b = 4 [json_name = "value1b"];*/ 4:
                    message.value1B = reader.int32();
                    break;
                case /* int32 parm2 */ 5:
                    message.parm2 = reader.int32();
                    break;
                case /* int32 value2a = 6 [json_name = "value2a"];*/ 6:
                    message.value2A = reader.int32();
                    break;
                case /* int32 value2b = 7 [json_name = "value2b"];*/ 7:
                    message.value2B = reader.int32();
                    break;
                case /* int32 parm3 */ 8:
                    message.parm3 = reader.int32();
                    break;
                case /* int32 value3a = 9 [json_name = "value3a"];*/ 9:
                    message.value3A = reader.int32();
                    break;
                case /* int32 value3b = 10 [json_name = "value3b"];*/ 10:
                    message.value3B = reader.int32();
                    break;
                case /* int32 parm4 */ 11:
                    message.parm4 = reader.int32();
                    break;
                case /* int32 value4a = 12 [json_name = "value4a"];*/ 12:
                    message.value4A = reader.int32();
                    break;
                case /* int32 value4b = 13 [json_name = "value4b"];*/ 13:
                    message.value4B = reader.int32();
                    break;
                case /* int32 parm5 */ 14:
                    message.parm5 = reader.int32();
                    break;
                case /* int32 value5a = 15 [json_name = "value5a"];*/ 15:
                    message.value5A = reader.int32();
                    break;
                case /* int32 value5b = 16 [json_name = "value5b"];*/ 16:
                    message.value5B = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LevelAppearance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 spawn_id = 1; */
        if (message.spawnId !== 0)
            writer.tag(1, WireType.Varint).int32(message.spawnId);
        /* int32 parm1 = 2; */
        if (message.parm1 !== 0)
            writer.tag(2, WireType.Varint).int32(message.parm1);
        /* int32 value1a = 3 [json_name = "value1a"]; */
        if (message.value1A !== 0)
            writer.tag(3, WireType.Varint).int32(message.value1A);
        /* int32 value1b = 4 [json_name = "value1b"]; */
        if (message.value1B !== 0)
            writer.tag(4, WireType.Varint).int32(message.value1B);
        /* int32 parm2 = 5; */
        if (message.parm2 !== 0)
            writer.tag(5, WireType.Varint).int32(message.parm2);
        /* int32 value2a = 6 [json_name = "value2a"]; */
        if (message.value2A !== 0)
            writer.tag(6, WireType.Varint).int32(message.value2A);
        /* int32 value2b = 7 [json_name = "value2b"]; */
        if (message.value2B !== 0)
            writer.tag(7, WireType.Varint).int32(message.value2B);
        /* int32 parm3 = 8; */
        if (message.parm3 !== 0)
            writer.tag(8, WireType.Varint).int32(message.parm3);
        /* int32 value3a = 9 [json_name = "value3a"]; */
        if (message.value3A !== 0)
            writer.tag(9, WireType.Varint).int32(message.value3A);
        /* int32 value3b = 10 [json_name = "value3b"]; */
        if (message.value3B !== 0)
            writer.tag(10, WireType.Varint).int32(message.value3B);
        /* int32 parm4 = 11; */
        if (message.parm4 !== 0)
            writer.tag(11, WireType.Varint).int32(message.parm4);
        /* int32 value4a = 12 [json_name = "value4a"]; */
        if (message.value4A !== 0)
            writer.tag(12, WireType.Varint).int32(message.value4A);
        /* int32 value4b = 13 [json_name = "value4b"]; */
        if (message.value4B !== 0)
            writer.tag(13, WireType.Varint).int32(message.value4B);
        /* int32 parm5 = 14; */
        if (message.parm5 !== 0)
            writer.tag(14, WireType.Varint).int32(message.parm5);
        /* int32 value5a = 15 [json_name = "value5a"]; */
        if (message.value5A !== 0)
            writer.tag(15, WireType.Varint).int32(message.value5A);
        /* int32 value5b = 16 [json_name = "value5b"]; */
        if (message.value5B !== 0)
            writer.tag(16, WireType.Varint).int32(message.value5B);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.LevelAppearance
 */
export const LevelAppearance = new LevelAppearance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MerchantList$Type extends MessageType<MerchantList> {
    constructor() {
        super("eq.MerchantList", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "slot", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "item", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<MerchantList>): MerchantList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.slot = 0;
        message.item = 0;
        if (value !== undefined)
            reflectionMergePartial<MerchantList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MerchantList): MerchantList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* int32 slot */ 2:
                    message.slot = reader.int32();
                    break;
                case /* int32 item */ 3:
                    message.item = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MerchantList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* int32 slot = 2; */
        if (message.slot !== 0)
            writer.tag(2, WireType.Varint).int32(message.slot);
        /* int32 item = 3; */
        if (message.item !== 0)
            writer.tag(3, WireType.Varint).int32(message.item);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.MerchantList
 */
export const MerchantList = new MerchantList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TempMerchantList$Type extends MessageType<TempMerchantList> {
    constructor() {
        super("eq.TempMerchantList", [
            { no: 1, name: "npcid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "slot", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "item", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "charges", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "origslot", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TempMerchantList>): TempMerchantList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.npcid = 0;
        message.slot = 0;
        message.item = 0;
        message.charges = 0;
        message.origslot = 0;
        if (value !== undefined)
            reflectionMergePartial<TempMerchantList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TempMerchantList): TempMerchantList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 npcid */ 1:
                    message.npcid = reader.int32();
                    break;
                case /* int32 slot */ 2:
                    message.slot = reader.int32();
                    break;
                case /* int32 item */ 3:
                    message.item = reader.int32();
                    break;
                case /* int32 charges */ 4:
                    message.charges = reader.int32();
                    break;
                case /* int32 origslot */ 5:
                    message.origslot = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TempMerchantList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 npcid = 1; */
        if (message.npcid !== 0)
            writer.tag(1, WireType.Varint).int32(message.npcid);
        /* int32 slot = 2; */
        if (message.slot !== 0)
            writer.tag(2, WireType.Varint).int32(message.slot);
        /* int32 item = 3; */
        if (message.item !== 0)
            writer.tag(3, WireType.Varint).int32(message.item);
        /* int32 charges = 4; */
        if (message.charges !== 0)
            writer.tag(4, WireType.Varint).int32(message.charges);
        /* int32 origslot = 5; */
        if (message.origslot !== 0)
            writer.tag(5, WireType.Varint).int32(message.origslot);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.TempMerchantList
 */
export const TempMerchantList = new TempMerchantList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FindPerson_Point$Type extends MessageType<FindPerson_Point> {
    constructor() {
        super("eq.FindPerson_Point", [
            { no: 1, name: "y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "z", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<FindPerson_Point>): FindPerson_Point {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.y = 0;
        message.x = 0;
        message.z = 0;
        if (value !== undefined)
            reflectionMergePartial<FindPerson_Point>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FindPerson_Point): FindPerson_Point {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float y */ 1:
                    message.y = reader.float();
                    break;
                case /* float x */ 2:
                    message.x = reader.float();
                    break;
                case /* float z */ 3:
                    message.z = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FindPerson_Point, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float y = 1; */
        if (message.y !== 0)
            writer.tag(1, WireType.Bit32).float(message.y);
        /* float x = 2; */
        if (message.x !== 0)
            writer.tag(2, WireType.Bit32).float(message.x);
        /* float z = 3; */
        if (message.z !== 0)
            writer.tag(3, WireType.Bit32).float(message.z);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.FindPerson_Point
 */
export const FindPerson_Point = new FindPerson_Point$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FindPersonRequest$Type extends MessageType<FindPersonRequest> {
    constructor() {
        super("eq.FindPersonRequest", [
            { no: 1, name: "npc_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "client_pos", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<FindPersonRequest>): FindPersonRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.npcId = 0;
        message.clientPos = 0;
        if (value !== undefined)
            reflectionMergePartial<FindPersonRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FindPersonRequest): FindPersonRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 npc_id */ 1:
                    message.npcId = reader.int32();
                    break;
                case /* int32 client_pos */ 2:
                    message.clientPos = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FindPersonRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 npc_id = 1; */
        if (message.npcId !== 0)
            writer.tag(1, WireType.Varint).int32(message.npcId);
        /* int32 client_pos = 2; */
        if (message.clientPos !== 0)
            writer.tag(2, WireType.Varint).int32(message.clientPos);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.FindPersonRequest
 */
export const FindPersonRequest = new FindPersonRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FindPersonResult$Type extends MessageType<FindPersonResult> {
    constructor() {
        super("eq.FindPersonResult", [
            { no: 1, name: "dest", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "path", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<FindPersonResult>): FindPersonResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.dest = 0;
        message.path = [];
        if (value !== undefined)
            reflectionMergePartial<FindPersonResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FindPersonResult): FindPersonResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 dest */ 1:
                    message.dest = reader.int32();
                    break;
                case /* repeated int32 path */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.path.push(reader.int32());
                    else
                        message.path.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FindPersonResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 dest = 1; */
        if (message.dest !== 0)
            writer.tag(1, WireType.Varint).int32(message.dest);
        /* repeated int32 path = 2; */
        if (message.path.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.path.length; i++)
                writer.int32(message.path[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.FindPersonResult
 */
export const FindPersonResult = new FindPersonResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MobRename$Type extends MessageType<MobRename> {
    constructor() {
        super("eq.MobRename", [
            { no: 1, name: "old_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "old_name_again", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "new_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MobRename>): MobRename {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.oldName = "";
        message.oldNameAgain = "";
        message.newName = "";
        if (value !== undefined)
            reflectionMergePartial<MobRename>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MobRename): MobRename {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string old_name */ 1:
                    message.oldName = reader.string();
                    break;
                case /* string old_name_again */ 2:
                    message.oldNameAgain = reader.string();
                    break;
                case /* string new_name */ 3:
                    message.newName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MobRename, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string old_name = 1; */
        if (message.oldName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.oldName);
        /* string old_name_again = 2; */
        if (message.oldNameAgain !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.oldNameAgain);
        /* string new_name = 3; */
        if (message.newName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.newName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.MobRename
 */
export const MobRename = new MobRename$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayMP3$Type extends MessageType<PlayMP3> {
    constructor() {
        super("eq.PlayMP3", [
            { no: 1, name: "filename", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PlayMP3>): PlayMP3 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.filename = "";
        if (value !== undefined)
            reflectionMergePartial<PlayMP3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayMP3): PlayMP3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string filename */ 1:
                    message.filename = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayMP3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string filename = 1; */
        if (message.filename !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.filename);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.PlayMP3
 */
export const PlayMP3 = new PlayMP3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TitleEntry$Type extends MessageType<TitleEntry> {
    constructor() {
        super("eq.TitleEntry", [
            { no: 1, name: "skill_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "skill_value", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TitleEntry>): TitleEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.skillId = 0;
        message.skillValue = 0;
        message.title = "";
        if (value !== undefined)
            reflectionMergePartial<TitleEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TitleEntry): TitleEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 skill_id */ 1:
                    message.skillId = reader.int32();
                    break;
                case /* int32 skill_value */ 2:
                    message.skillValue = reader.int32();
                    break;
                case /* string title */ 3:
                    message.title = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TitleEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 skill_id = 1; */
        if (message.skillId !== 0)
            writer.tag(1, WireType.Varint).int32(message.skillId);
        /* int32 skill_value = 2; */
        if (message.skillValue !== 0)
            writer.tag(2, WireType.Varint).int32(message.skillValue);
        /* string title = 3; */
        if (message.title !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.title);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.TitleEntry
 */
export const TitleEntry = new TitleEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Titles$Type extends MessageType<Titles> {
    constructor() {
        super("eq.Titles", [
            { no: 1, name: "count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "titles", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TitleEntry }
        ]);
    }
    create(value?: PartialMessage<Titles>): Titles {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.count = 0;
        message.titles = [];
        if (value !== undefined)
            reflectionMergePartial<Titles>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Titles): Titles {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 count */ 1:
                    message.count = reader.int32();
                    break;
                case /* repeated eq.TitleEntry titles */ 2:
                    message.titles.push(TitleEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Titles, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 count = 1; */
        if (message.count !== 0)
            writer.tag(1, WireType.Varint).int32(message.count);
        /* repeated eq.TitleEntry titles = 2; */
        for (let i = 0; i < message.titles.length; i++)
            TitleEntry.internalBinaryWrite(message.titles[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Titles
 */
export const Titles = new Titles$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TitleListEntry$Type extends MessageType<TitleListEntry> {
    constructor() {
        super("eq.TitleListEntry", [
            { no: 1, name: "prefix", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "postfix", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TitleListEntry>): TitleListEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.prefix = "";
        message.postfix = "";
        if (value !== undefined)
            reflectionMergePartial<TitleListEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TitleListEntry): TitleListEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string prefix */ 1:
                    message.prefix = reader.string();
                    break;
                case /* string postfix */ 2:
                    message.postfix = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TitleListEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string prefix = 1; */
        if (message.prefix !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.prefix);
        /* string postfix = 2; */
        if (message.postfix !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.postfix);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.TitleListEntry
 */
export const TitleListEntry = new TitleListEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TitleList$Type extends MessageType<TitleList> {
    constructor() {
        super("eq.TitleList", [
            { no: 1, name: "count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "titles", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TitleListEntry }
        ]);
    }
    create(value?: PartialMessage<TitleList>): TitleList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.count = 0;
        message.titles = [];
        if (value !== undefined)
            reflectionMergePartial<TitleList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TitleList): TitleList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 count */ 1:
                    message.count = reader.int32();
                    break;
                case /* repeated eq.TitleListEntry titles */ 2:
                    message.titles.push(TitleListEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TitleList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 count = 1; */
        if (message.count !== 0)
            writer.tag(1, WireType.Varint).int32(message.count);
        /* repeated eq.TitleListEntry titles = 2; */
        for (let i = 0; i < message.titles.length; i++)
            TitleListEntry.internalBinaryWrite(message.titles[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.TitleList
 */
export const TitleList = new TitleList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetTitle$Type extends MessageType<SetTitle> {
    constructor() {
        super("eq.SetTitle", [
            { no: 1, name: "is_suffix", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "title_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SetTitle>): SetTitle {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isSuffix = 0;
        message.titleId = 0;
        if (value !== undefined)
            reflectionMergePartial<SetTitle>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetTitle): SetTitle {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 is_suffix */ 1:
                    message.isSuffix = reader.int32();
                    break;
                case /* int32 title_id */ 2:
                    message.titleId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetTitle, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 is_suffix = 1; */
        if (message.isSuffix !== 0)
            writer.tag(1, WireType.Varint).int32(message.isSuffix);
        /* int32 title_id = 2; */
        if (message.titleId !== 0)
            writer.tag(2, WireType.Varint).int32(message.titleId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.SetTitle
 */
export const SetTitle = new SetTitle$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetTitleReply$Type extends MessageType<SetTitleReply> {
    constructor() {
        super("eq.SetTitleReply", [
            { no: 1, name: "is_suffix", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "entity_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SetTitleReply>): SetTitleReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isSuffix = 0;
        message.title = "";
        message.entityId = 0;
        if (value !== undefined)
            reflectionMergePartial<SetTitleReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetTitleReply): SetTitleReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 is_suffix */ 1:
                    message.isSuffix = reader.int32();
                    break;
                case /* string title */ 2:
                    message.title = reader.string();
                    break;
                case /* int32 entity_id */ 3:
                    message.entityId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetTitleReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 is_suffix = 1; */
        if (message.isSuffix !== 0)
            writer.tag(1, WireType.Varint).int32(message.isSuffix);
        /* string title = 2; */
        if (message.title !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.title);
        /* int32 entity_id = 3; */
        if (message.entityId !== 0)
            writer.tag(3, WireType.Varint).int32(message.entityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.SetTitleReply
 */
export const SetTitleReply = new SetTitleReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TaskDescription$Type extends MessageType<TaskDescription> {
    constructor() {
        super("eq.TaskDescription", [
            { no: 1, name: "activity_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "taskid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "unk", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "desc", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "reward_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "reward_link", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TaskDescription>): TaskDescription {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.activityCount = 0;
        message.taskid = 0;
        message.unk = 0;
        message.id = 0;
        message.name = "";
        message.desc = "";
        message.rewardCount = 0;
        message.rewardLink = "";
        if (value !== undefined)
            reflectionMergePartial<TaskDescription>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskDescription): TaskDescription {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 activity_count */ 1:
                    message.activityCount = reader.int32();
                    break;
                case /* int32 taskid */ 2:
                    message.taskid = reader.int32();
                    break;
                case /* int32 unk */ 3:
                    message.unk = reader.int32();
                    break;
                case /* int32 id */ 4:
                    message.id = reader.int32();
                    break;
                case /* string name */ 5:
                    message.name = reader.string();
                    break;
                case /* string desc */ 6:
                    message.desc = reader.string();
                    break;
                case /* int32 reward_count */ 7:
                    message.rewardCount = reader.int32();
                    break;
                case /* string reward_link */ 8:
                    message.rewardLink = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TaskDescription, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 activity_count = 1; */
        if (message.activityCount !== 0)
            writer.tag(1, WireType.Varint).int32(message.activityCount);
        /* int32 taskid = 2; */
        if (message.taskid !== 0)
            writer.tag(2, WireType.Varint).int32(message.taskid);
        /* int32 unk = 3; */
        if (message.unk !== 0)
            writer.tag(3, WireType.Varint).int32(message.unk);
        /* int32 id = 4; */
        if (message.id !== 0)
            writer.tag(4, WireType.Varint).int32(message.id);
        /* string name = 5; */
        if (message.name !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.name);
        /* string desc = 6; */
        if (message.desc !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.desc);
        /* int32 reward_count = 7; */
        if (message.rewardCount !== 0)
            writer.tag(7, WireType.Varint).int32(message.rewardCount);
        /* string reward_link = 8; */
        if (message.rewardLink !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.rewardLink);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.TaskDescription
 */
export const TaskDescription = new TaskDescription$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TaskMemberList$Type extends MessageType<TaskMemberList> {
    constructor() {
        super("eq.TaskMemberList", [
            { no: 1, name: "gopher_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "member_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "list_pointer", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TaskMemberList>): TaskMemberList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.gopherId = 0;
        message.memberCount = 0;
        message.listPointer = "";
        if (value !== undefined)
            reflectionMergePartial<TaskMemberList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskMemberList): TaskMemberList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 gopher_id */ 1:
                    message.gopherId = reader.int32();
                    break;
                case /* int32 member_count */ 2:
                    message.memberCount = reader.int32();
                    break;
                case /* string list_pointer */ 3:
                    message.listPointer = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TaskMemberList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 gopher_id = 1; */
        if (message.gopherId !== 0)
            writer.tag(1, WireType.Varint).int32(message.gopherId);
        /* int32 member_count = 2; */
        if (message.memberCount !== 0)
            writer.tag(2, WireType.Varint).int32(message.memberCount);
        /* string list_pointer = 3; */
        if (message.listPointer !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.listPointer);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.TaskMemberList
 */
export const TaskMemberList = new TaskMemberList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TaskActivity$Type extends MessageType<TaskActivity> {
    constructor() {
        super("eq.TaskActivity", [
            { no: 1, name: "activity_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "taskid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "activity_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "activity_type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "mob_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "item_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "goal_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "activity_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "done_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TaskActivity>): TaskActivity {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.activityCount = 0;
        message.id = 0;
        message.taskid = 0;
        message.activityId = 0;
        message.activityType = 0;
        message.mobName = "";
        message.itemName = "";
        message.goalCount = 0;
        message.activityName = "";
        message.doneCount = 0;
        if (value !== undefined)
            reflectionMergePartial<TaskActivity>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskActivity): TaskActivity {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 activity_count */ 1:
                    message.activityCount = reader.int32();
                    break;
                case /* int32 id */ 2:
                    message.id = reader.int32();
                    break;
                case /* int32 taskid */ 3:
                    message.taskid = reader.int32();
                    break;
                case /* int32 activity_id */ 4:
                    message.activityId = reader.int32();
                    break;
                case /* int32 activity_type */ 5:
                    message.activityType = reader.int32();
                    break;
                case /* string mob_name */ 6:
                    message.mobName = reader.string();
                    break;
                case /* string item_name */ 7:
                    message.itemName = reader.string();
                    break;
                case /* int32 goal_count */ 8:
                    message.goalCount = reader.int32();
                    break;
                case /* string activity_name */ 9:
                    message.activityName = reader.string();
                    break;
                case /* int32 done_count */ 10:
                    message.doneCount = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TaskActivity, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 activity_count = 1; */
        if (message.activityCount !== 0)
            writer.tag(1, WireType.Varint).int32(message.activityCount);
        /* int32 id = 2; */
        if (message.id !== 0)
            writer.tag(2, WireType.Varint).int32(message.id);
        /* int32 taskid = 3; */
        if (message.taskid !== 0)
            writer.tag(3, WireType.Varint).int32(message.taskid);
        /* int32 activity_id = 4; */
        if (message.activityId !== 0)
            writer.tag(4, WireType.Varint).int32(message.activityId);
        /* int32 activity_type = 5; */
        if (message.activityType !== 0)
            writer.tag(5, WireType.Varint).int32(message.activityType);
        /* string mob_name = 6; */
        if (message.mobName !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.mobName);
        /* string item_name = 7; */
        if (message.itemName !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.itemName);
        /* int32 goal_count = 8; */
        if (message.goalCount !== 0)
            writer.tag(8, WireType.Varint).int32(message.goalCount);
        /* string activity_name = 9; */
        if (message.activityName !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.activityName);
        /* int32 done_count = 10; */
        if (message.doneCount !== 0)
            writer.tag(10, WireType.Varint).int32(message.doneCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.TaskActivity
 */
export const TaskActivity = new TaskActivity$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TaskHistoryEntry$Type extends MessageType<TaskHistoryEntry> {
    constructor() {
        super("eq.TaskHistoryEntry", [
            { no: 1, name: "task_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "completed_time", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TaskHistoryEntry>): TaskHistoryEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.taskId = 0;
        message.name = "";
        message.completedTime = 0;
        if (value !== undefined)
            reflectionMergePartial<TaskHistoryEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskHistoryEntry): TaskHistoryEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 task_id */ 1:
                    message.taskId = reader.int32();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* int32 completed_time */ 3:
                    message.completedTime = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TaskHistoryEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 task_id = 1; */
        if (message.taskId !== 0)
            writer.tag(1, WireType.Varint).int32(message.taskId);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* int32 completed_time = 3; */
        if (message.completedTime !== 0)
            writer.tag(3, WireType.Varint).int32(message.completedTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.TaskHistoryEntry
 */
export const TaskHistoryEntry = new TaskHistoryEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TaskHistory$Type extends MessageType<TaskHistory> {
    constructor() {
        super("eq.TaskHistory", [
            { no: 1, name: "count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "entries", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TaskHistoryEntry }
        ]);
    }
    create(value?: PartialMessage<TaskHistory>): TaskHistory {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.count = 0;
        message.entries = [];
        if (value !== undefined)
            reflectionMergePartial<TaskHistory>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskHistory): TaskHistory {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 count */ 1:
                    message.count = reader.int32();
                    break;
                case /* repeated eq.TaskHistoryEntry entries */ 2:
                    message.entries.push(TaskHistoryEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TaskHistory, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 count = 1; */
        if (message.count !== 0)
            writer.tag(1, WireType.Varint).int32(message.count);
        /* repeated eq.TaskHistoryEntry entries = 2; */
        for (let i = 0; i < message.entries.length; i++)
            TaskHistoryEntry.internalBinaryWrite(message.entries[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.TaskHistory
 */
export const TaskHistory = new TaskHistory$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AcceptNewTask$Type extends MessageType<AcceptNewTask> {
    constructor() {
        super("eq.AcceptNewTask", [
            { no: 1, name: "task_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "task_master_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AcceptNewTask>): AcceptNewTask {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.taskId = 0;
        message.taskMasterId = 0;
        if (value !== undefined)
            reflectionMergePartial<AcceptNewTask>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AcceptNewTask): AcceptNewTask {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 task_id */ 1:
                    message.taskId = reader.int32();
                    break;
                case /* int32 task_master_id */ 2:
                    message.taskMasterId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AcceptNewTask, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 task_id = 1; */
        if (message.taskId !== 0)
            writer.tag(1, WireType.Varint).int32(message.taskId);
        /* int32 task_master_id = 2; */
        if (message.taskMasterId !== 0)
            writer.tag(2, WireType.Varint).int32(message.taskMasterId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.AcceptNewTask
 */
export const AcceptNewTask = new AcceptNewTask$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CancelTask$Type extends MessageType<CancelTask> {
    constructor() {
        super("eq.CancelTask", []);
    }
    create(value?: PartialMessage<CancelTask>): CancelTask {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CancelTask>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CancelTask): CancelTask {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CancelTask, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.CancelTask
 */
export const CancelTask = new CancelTask$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvaliableTask$Type extends MessageType<AvaliableTask> {
    constructor() {
        super("eq.AvaliableTask", [
            { no: 1, name: "task_index", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "task_master_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "task_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "activity_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "desc", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "reward_platinum", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "reward_gold", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "reward_silver", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "reward_copper", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "some_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AvaliableTask>): AvaliableTask {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.taskIndex = 0;
        message.taskMasterId = 0;
        message.taskId = 0;
        message.activityCount = 0;
        message.desc = "";
        message.rewardPlatinum = 0;
        message.rewardGold = 0;
        message.rewardSilver = 0;
        message.rewardCopper = 0;
        message.someName = "";
        if (value !== undefined)
            reflectionMergePartial<AvaliableTask>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvaliableTask): AvaliableTask {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 task_index */ 1:
                    message.taskIndex = reader.int32();
                    break;
                case /* int32 task_master_id */ 2:
                    message.taskMasterId = reader.int32();
                    break;
                case /* int32 task_id */ 3:
                    message.taskId = reader.int32();
                    break;
                case /* int32 activity_count */ 4:
                    message.activityCount = reader.int32();
                    break;
                case /* string desc */ 5:
                    message.desc = reader.string();
                    break;
                case /* int32 reward_platinum */ 6:
                    message.rewardPlatinum = reader.int32();
                    break;
                case /* int32 reward_gold */ 7:
                    message.rewardGold = reader.int32();
                    break;
                case /* int32 reward_silver */ 8:
                    message.rewardSilver = reader.int32();
                    break;
                case /* int32 reward_copper */ 9:
                    message.rewardCopper = reader.int32();
                    break;
                case /* string some_name */ 10:
                    message.someName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvaliableTask, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 task_index = 1; */
        if (message.taskIndex !== 0)
            writer.tag(1, WireType.Varint).int32(message.taskIndex);
        /* int32 task_master_id = 2; */
        if (message.taskMasterId !== 0)
            writer.tag(2, WireType.Varint).int32(message.taskMasterId);
        /* int32 task_id = 3; */
        if (message.taskId !== 0)
            writer.tag(3, WireType.Varint).int32(message.taskId);
        /* int32 activity_count = 4; */
        if (message.activityCount !== 0)
            writer.tag(4, WireType.Varint).int32(message.activityCount);
        /* string desc = 5; */
        if (message.desc !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.desc);
        /* int32 reward_platinum = 6; */
        if (message.rewardPlatinum !== 0)
            writer.tag(6, WireType.Varint).int32(message.rewardPlatinum);
        /* int32 reward_gold = 7; */
        if (message.rewardGold !== 0)
            writer.tag(7, WireType.Varint).int32(message.rewardGold);
        /* int32 reward_silver = 8; */
        if (message.rewardSilver !== 0)
            writer.tag(8, WireType.Varint).int32(message.rewardSilver);
        /* int32 reward_copper = 9; */
        if (message.rewardCopper !== 0)
            writer.tag(9, WireType.Varint).int32(message.rewardCopper);
        /* string some_name = 10; */
        if (message.someName !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.someName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.AvaliableTask
 */
export const AvaliableTask = new AvaliableTask$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BankerChange$Type extends MessageType<BankerChange> {
    constructor() {
        super("eq.BankerChange", [
            { no: 1, name: "platinum", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "gold", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "silver", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "copper", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "platinum_bank", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "gold_bank", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "silver_bank", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "copper_bank", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<BankerChange>): BankerChange {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.platinum = 0;
        message.gold = 0;
        message.silver = 0;
        message.copper = 0;
        message.platinumBank = 0;
        message.goldBank = 0;
        message.silverBank = 0;
        message.copperBank = 0;
        if (value !== undefined)
            reflectionMergePartial<BankerChange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BankerChange): BankerChange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 platinum */ 1:
                    message.platinum = reader.int32();
                    break;
                case /* int32 gold */ 2:
                    message.gold = reader.int32();
                    break;
                case /* int32 silver */ 3:
                    message.silver = reader.int32();
                    break;
                case /* int32 copper */ 4:
                    message.copper = reader.int32();
                    break;
                case /* int32 platinum_bank */ 5:
                    message.platinumBank = reader.int32();
                    break;
                case /* int32 gold_bank */ 6:
                    message.goldBank = reader.int32();
                    break;
                case /* int32 silver_bank */ 7:
                    message.silverBank = reader.int32();
                    break;
                case /* int32 copper_bank */ 8:
                    message.copperBank = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BankerChange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 platinum = 1; */
        if (message.platinum !== 0)
            writer.tag(1, WireType.Varint).int32(message.platinum);
        /* int32 gold = 2; */
        if (message.gold !== 0)
            writer.tag(2, WireType.Varint).int32(message.gold);
        /* int32 silver = 3; */
        if (message.silver !== 0)
            writer.tag(3, WireType.Varint).int32(message.silver);
        /* int32 copper = 4; */
        if (message.copper !== 0)
            writer.tag(4, WireType.Varint).int32(message.copper);
        /* int32 platinum_bank = 5; */
        if (message.platinumBank !== 0)
            writer.tag(5, WireType.Varint).int32(message.platinumBank);
        /* int32 gold_bank = 6; */
        if (message.goldBank !== 0)
            writer.tag(6, WireType.Varint).int32(message.goldBank);
        /* int32 silver_bank = 7; */
        if (message.silverBank !== 0)
            writer.tag(7, WireType.Varint).int32(message.silverBank);
        /* int32 copper_bank = 8; */
        if (message.copperBank !== 0)
            writer.tag(8, WireType.Varint).int32(message.copperBank);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.BankerChange
 */
export const BankerChange = new BankerChange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LeadershipExpUpdate$Type extends MessageType<LeadershipExpUpdate> {
    constructor() {
        super("eq.LeadershipExpUpdate", [
            { no: 1, name: "group_leadership_exp", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "group_leadership_points", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "raid_leadership_exp", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "raid_leadership_points", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<LeadershipExpUpdate>): LeadershipExpUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.groupLeadershipExp = 0;
        message.groupLeadershipPoints = 0;
        message.raidLeadershipExp = 0;
        message.raidLeadershipPoints = 0;
        if (value !== undefined)
            reflectionMergePartial<LeadershipExpUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LeadershipExpUpdate): LeadershipExpUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double group_leadership_exp */ 1:
                    message.groupLeadershipExp = reader.double();
                    break;
                case /* int32 group_leadership_points */ 2:
                    message.groupLeadershipPoints = reader.int32();
                    break;
                case /* double raid_leadership_exp */ 3:
                    message.raidLeadershipExp = reader.double();
                    break;
                case /* int32 raid_leadership_points */ 4:
                    message.raidLeadershipPoints = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LeadershipExpUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double group_leadership_exp = 1; */
        if (message.groupLeadershipExp !== 0)
            writer.tag(1, WireType.Bit64).double(message.groupLeadershipExp);
        /* int32 group_leadership_points = 2; */
        if (message.groupLeadershipPoints !== 0)
            writer.tag(2, WireType.Varint).int32(message.groupLeadershipPoints);
        /* double raid_leadership_exp = 3; */
        if (message.raidLeadershipExp !== 0)
            writer.tag(3, WireType.Bit64).double(message.raidLeadershipExp);
        /* int32 raid_leadership_points = 4; */
        if (message.raidLeadershipPoints !== 0)
            writer.tag(4, WireType.Varint).int32(message.raidLeadershipPoints);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.LeadershipExpUpdate
 */
export const LeadershipExpUpdate = new LeadershipExpUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateLeadershipAA$Type extends MessageType<UpdateLeadershipAA> {
    constructor() {
        super("eq.UpdateLeadershipAA", [
            { no: 1, name: "ability_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "new_rank", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "pointsleft", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateLeadershipAA>): UpdateLeadershipAA {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.abilityId = 0;
        message.newRank = 0;
        message.pointsleft = 0;
        if (value !== undefined)
            reflectionMergePartial<UpdateLeadershipAA>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateLeadershipAA): UpdateLeadershipAA {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 ability_id */ 1:
                    message.abilityId = reader.int32();
                    break;
                case /* int32 new_rank */ 2:
                    message.newRank = reader.int32();
                    break;
                case /* int32 pointsleft */ 3:
                    message.pointsleft = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateLeadershipAA, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 ability_id = 1; */
        if (message.abilityId !== 0)
            writer.tag(1, WireType.Varint).int32(message.abilityId);
        /* int32 new_rank = 2; */
        if (message.newRank !== 0)
            writer.tag(2, WireType.Varint).int32(message.newRank);
        /* int32 pointsleft = 3; */
        if (message.pointsleft !== 0)
            writer.tag(3, WireType.Varint).int32(message.pointsleft);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.UpdateLeadershipAA
 */
export const UpdateLeadershipAA = new UpdateLeadershipAA$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LeadExpUpdate$Type extends MessageType<LeadExpUpdate> {
    constructor() {
        super("eq.LeadExpUpdate", [
            { no: 1, name: "group_leadership_exp", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "group_leadership_points", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "raid_leadership_exp", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "raid_leadership_points", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<LeadExpUpdate>): LeadExpUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.groupLeadershipExp = 0;
        message.groupLeadershipPoints = 0;
        message.raidLeadershipExp = 0;
        message.raidLeadershipPoints = 0;
        if (value !== undefined)
            reflectionMergePartial<LeadExpUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LeadExpUpdate): LeadExpUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 group_leadership_exp */ 1:
                    message.groupLeadershipExp = reader.int32();
                    break;
                case /* int32 group_leadership_points */ 2:
                    message.groupLeadershipPoints = reader.int32();
                    break;
                case /* int32 raid_leadership_exp */ 3:
                    message.raidLeadershipExp = reader.int32();
                    break;
                case /* int32 raid_leadership_points */ 4:
                    message.raidLeadershipPoints = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LeadExpUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 group_leadership_exp = 1; */
        if (message.groupLeadershipExp !== 0)
            writer.tag(1, WireType.Varint).int32(message.groupLeadershipExp);
        /* int32 group_leadership_points = 2; */
        if (message.groupLeadershipPoints !== 0)
            writer.tag(2, WireType.Varint).int32(message.groupLeadershipPoints);
        /* int32 raid_leadership_exp = 3; */
        if (message.raidLeadershipExp !== 0)
            writer.tag(3, WireType.Varint).int32(message.raidLeadershipExp);
        /* int32 raid_leadership_points = 4; */
        if (message.raidLeadershipPoints !== 0)
            writer.tag(4, WireType.Varint).int32(message.raidLeadershipPoints);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.LeadExpUpdate
 */
export const LeadExpUpdate = new LeadExpUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RaidGeneral$Type extends MessageType<RaidGeneral> {
    constructor() {
        super("eq.RaidGeneral", [
            { no: 1, name: "action", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "player_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "leader_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "parameter", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<RaidGeneral>): RaidGeneral {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.action = 0;
        message.playerName = "";
        message.leaderName = "";
        message.parameter = 0;
        if (value !== undefined)
            reflectionMergePartial<RaidGeneral>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RaidGeneral): RaidGeneral {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 action */ 1:
                    message.action = reader.int32();
                    break;
                case /* string player_name */ 2:
                    message.playerName = reader.string();
                    break;
                case /* string leader_name */ 3:
                    message.leaderName = reader.string();
                    break;
                case /* int32 parameter */ 4:
                    message.parameter = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RaidGeneral, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 action = 1; */
        if (message.action !== 0)
            writer.tag(1, WireType.Varint).int32(message.action);
        /* string player_name = 2; */
        if (message.playerName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.playerName);
        /* string leader_name = 3; */
        if (message.leaderName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.leaderName);
        /* int32 parameter = 4; */
        if (message.parameter !== 0)
            writer.tag(4, WireType.Varint).int32(message.parameter);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.RaidGeneral
 */
export const RaidGeneral = new RaidGeneral$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RaidAddMember$Type extends MessageType<RaidAddMember> {
    constructor() {
        super("eq.RaidAddMember", [
            { no: 1, name: "raid_gen", kind: "message", T: () => RaidGeneral },
            { no: 2, name: "char_class", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "level", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "is_group_leader", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<RaidAddMember>): RaidAddMember {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.charClass = 0;
        message.level = 0;
        message.isGroupLeader = 0;
        if (value !== undefined)
            reflectionMergePartial<RaidAddMember>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RaidAddMember): RaidAddMember {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* eq.RaidGeneral raid_gen */ 1:
                    message.raidGen = RaidGeneral.internalBinaryRead(reader, reader.uint32(), options, message.raidGen);
                    break;
                case /* int32 char_class */ 2:
                    message.charClass = reader.int32();
                    break;
                case /* int32 level */ 3:
                    message.level = reader.int32();
                    break;
                case /* int32 is_group_leader */ 4:
                    message.isGroupLeader = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RaidAddMember, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* eq.RaidGeneral raid_gen = 1; */
        if (message.raidGen)
            RaidGeneral.internalBinaryWrite(message.raidGen, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 char_class = 2; */
        if (message.charClass !== 0)
            writer.tag(2, WireType.Varint).int32(message.charClass);
        /* int32 level = 3; */
        if (message.level !== 0)
            writer.tag(3, WireType.Varint).int32(message.level);
        /* int32 is_group_leader = 4; */
        if (message.isGroupLeader !== 0)
            writer.tag(4, WireType.Varint).int32(message.isGroupLeader);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.RaidAddMember
 */
export const RaidAddMember = new RaidAddMember$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RaidNote$Type extends MessageType<RaidNote> {
    constructor() {
        super("eq.RaidNote", [
            { no: 1, name: "general", kind: "message", T: () => RaidGeneral },
            { no: 2, name: "note", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RaidNote>): RaidNote {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.note = "";
        if (value !== undefined)
            reflectionMergePartial<RaidNote>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RaidNote): RaidNote {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* eq.RaidGeneral general */ 1:
                    message.general = RaidGeneral.internalBinaryRead(reader, reader.uint32(), options, message.general);
                    break;
                case /* string note */ 2:
                    message.note = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RaidNote, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* eq.RaidGeneral general = 1; */
        if (message.general)
            RaidGeneral.internalBinaryWrite(message.general, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string note = 2; */
        if (message.note !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.note);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.RaidNote
 */
export const RaidNote = new RaidNote$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RaidMOTD$Type extends MessageType<RaidMOTD> {
    constructor() {
        super("eq.RaidMOTD", [
            { no: 1, name: "general", kind: "message", T: () => RaidGeneral },
            { no: 2, name: "motd", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RaidMOTD>): RaidMOTD {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.motd = "";
        if (value !== undefined)
            reflectionMergePartial<RaidMOTD>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RaidMOTD): RaidMOTD {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* eq.RaidGeneral general */ 1:
                    message.general = RaidGeneral.internalBinaryRead(reader, reader.uint32(), options, message.general);
                    break;
                case /* string motd */ 2:
                    message.motd = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RaidMOTD, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* eq.RaidGeneral general = 1; */
        if (message.general)
            RaidGeneral.internalBinaryWrite(message.general, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string motd = 2; */
        if (message.motd !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.motd);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.RaidMOTD
 */
export const RaidMOTD = new RaidMOTD$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RaidLeadershipUpdate$Type extends MessageType<RaidLeadershipUpdate> {
    constructor() {
        super("eq.RaidLeadershipUpdate", [
            { no: 1, name: "action", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "player_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "leader_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "group", kind: "message", T: () => GroupLeadershipAA },
            { no: 5, name: "raid", kind: "message", T: () => RaidLeadershipAA }
        ]);
    }
    create(value?: PartialMessage<RaidLeadershipUpdate>): RaidLeadershipUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.action = 0;
        message.playerName = "";
        message.leaderName = "";
        if (value !== undefined)
            reflectionMergePartial<RaidLeadershipUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RaidLeadershipUpdate): RaidLeadershipUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 action */ 1:
                    message.action = reader.int32();
                    break;
                case /* string player_name */ 2:
                    message.playerName = reader.string();
                    break;
                case /* string leader_name */ 3:
                    message.leaderName = reader.string();
                    break;
                case /* eq.GroupLeadershipAA group */ 4:
                    message.group = GroupLeadershipAA.internalBinaryRead(reader, reader.uint32(), options, message.group);
                    break;
                case /* eq.RaidLeadershipAA raid */ 5:
                    message.raid = RaidLeadershipAA.internalBinaryRead(reader, reader.uint32(), options, message.raid);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RaidLeadershipUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 action = 1; */
        if (message.action !== 0)
            writer.tag(1, WireType.Varint).int32(message.action);
        /* string player_name = 2; */
        if (message.playerName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.playerName);
        /* string leader_name = 3; */
        if (message.leaderName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.leaderName);
        /* eq.GroupLeadershipAA group = 4; */
        if (message.group)
            GroupLeadershipAA.internalBinaryWrite(message.group, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* eq.RaidLeadershipAA raid = 5; */
        if (message.raid)
            RaidLeadershipAA.internalBinaryWrite(message.raid, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.RaidLeadershipUpdate
 */
export const RaidLeadershipUpdate = new RaidLeadershipUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RaidCreate$Type extends MessageType<RaidCreate> {
    constructor() {
        super("eq.RaidCreate", [
            { no: 1, name: "action", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "leader_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "leader_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<RaidCreate>): RaidCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.action = 0;
        message.leaderName = "";
        message.leaderId = 0;
        if (value !== undefined)
            reflectionMergePartial<RaidCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RaidCreate): RaidCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 action */ 1:
                    message.action = reader.int32();
                    break;
                case /* string leader_name */ 2:
                    message.leaderName = reader.string();
                    break;
                case /* int32 leader_id */ 3:
                    message.leaderId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RaidCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 action = 1; */
        if (message.action !== 0)
            writer.tag(1, WireType.Varint).int32(message.action);
        /* string leader_name = 2; */
        if (message.leaderName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.leaderName);
        /* int32 leader_id = 3; */
        if (message.leaderId !== 0)
            writer.tag(3, WireType.Varint).int32(message.leaderId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.RaidCreate
 */
export const RaidCreate = new RaidCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RaidMemberInfo$Type extends MessageType<RaidMemberInfo> {
    constructor() {
        super("eq.RaidMemberInfo", [
            { no: 1, name: "group_number", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "member_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "char_class", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "level", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "is_raid_leader", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "is_group_leader", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "main_tank", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<RaidMemberInfo>): RaidMemberInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.groupNumber = 0;
        message.memberName = "";
        message.charClass = 0;
        message.level = 0;
        message.isRaidLeader = 0;
        message.isGroupLeader = 0;
        message.mainTank = 0;
        if (value !== undefined)
            reflectionMergePartial<RaidMemberInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RaidMemberInfo): RaidMemberInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 group_number */ 1:
                    message.groupNumber = reader.int32();
                    break;
                case /* string member_name */ 2:
                    message.memberName = reader.string();
                    break;
                case /* int32 char_class */ 3:
                    message.charClass = reader.int32();
                    break;
                case /* int32 level */ 4:
                    message.level = reader.int32();
                    break;
                case /* int32 is_raid_leader */ 5:
                    message.isRaidLeader = reader.int32();
                    break;
                case /* int32 is_group_leader */ 6:
                    message.isGroupLeader = reader.int32();
                    break;
                case /* int32 main_tank */ 7:
                    message.mainTank = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RaidMemberInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 group_number = 1; */
        if (message.groupNumber !== 0)
            writer.tag(1, WireType.Varint).int32(message.groupNumber);
        /* string member_name = 2; */
        if (message.memberName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.memberName);
        /* int32 char_class = 3; */
        if (message.charClass !== 0)
            writer.tag(3, WireType.Varint).int32(message.charClass);
        /* int32 level = 4; */
        if (message.level !== 0)
            writer.tag(4, WireType.Varint).int32(message.level);
        /* int32 is_raid_leader = 5; */
        if (message.isRaidLeader !== 0)
            writer.tag(5, WireType.Varint).int32(message.isRaidLeader);
        /* int32 is_group_leader = 6; */
        if (message.isGroupLeader !== 0)
            writer.tag(6, WireType.Varint).int32(message.isGroupLeader);
        /* int32 main_tank = 7; */
        if (message.mainTank !== 0)
            writer.tag(7, WireType.Varint).int32(message.mainTank);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.RaidMemberInfo
 */
export const RaidMemberInfo = new RaidMemberInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RaidDetails$Type extends MessageType<RaidDetails> {
    constructor() {
        super("eq.RaidDetails", [
            { no: 1, name: "action", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "leader_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "abilities", kind: "message", T: () => LeadershipAA },
            { no: 4, name: "leader_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<RaidDetails>): RaidDetails {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.action = 0;
        message.leaderName = "";
        message.leaderId = 0;
        if (value !== undefined)
            reflectionMergePartial<RaidDetails>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RaidDetails): RaidDetails {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 action */ 1:
                    message.action = reader.int32();
                    break;
                case /* string leader_name */ 2:
                    message.leaderName = reader.string();
                    break;
                case /* eq.LeadershipAA abilities */ 3:
                    message.abilities = LeadershipAA.internalBinaryRead(reader, reader.uint32(), options, message.abilities);
                    break;
                case /* int32 leader_id */ 4:
                    message.leaderId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RaidDetails, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 action = 1; */
        if (message.action !== 0)
            writer.tag(1, WireType.Varint).int32(message.action);
        /* string leader_name = 2; */
        if (message.leaderName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.leaderName);
        /* eq.LeadershipAA abilities = 3; */
        if (message.abilities)
            LeadershipAA.internalBinaryWrite(message.abilities, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* int32 leader_id = 4; */
        if (message.leaderId !== 0)
            writer.tag(4, WireType.Varint).int32(message.leaderId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.RaidDetails
 */
export const RaidDetails = new RaidDetails$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RaidMembers$Type extends MessageType<RaidMembers> {
    constructor() {
        super("eq.RaidMembers", [
            { no: 1, name: "details", kind: "message", T: () => RaidDetails },
            { no: 2, name: "member_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "members", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RaidMemberInfo },
            { no: 4, name: "empty", kind: "message", T: () => RaidMemberInfo }
        ]);
    }
    create(value?: PartialMessage<RaidMembers>): RaidMembers {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.memberCount = 0;
        message.members = [];
        if (value !== undefined)
            reflectionMergePartial<RaidMembers>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RaidMembers): RaidMembers {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* eq.RaidDetails details */ 1:
                    message.details = RaidDetails.internalBinaryRead(reader, reader.uint32(), options, message.details);
                    break;
                case /* int32 member_count */ 2:
                    message.memberCount = reader.int32();
                    break;
                case /* repeated eq.RaidMemberInfo members */ 3:
                    message.members.push(RaidMemberInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* eq.RaidMemberInfo empty */ 4:
                    message.empty = RaidMemberInfo.internalBinaryRead(reader, reader.uint32(), options, message.empty);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RaidMembers, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* eq.RaidDetails details = 1; */
        if (message.details)
            RaidDetails.internalBinaryWrite(message.details, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 member_count = 2; */
        if (message.memberCount !== 0)
            writer.tag(2, WireType.Varint).int32(message.memberCount);
        /* repeated eq.RaidMemberInfo members = 3; */
        for (let i = 0; i < message.members.length; i++)
            RaidMemberInfo.internalBinaryWrite(message.members[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* eq.RaidMemberInfo empty = 4; */
        if (message.empty)
            RaidMemberInfo.internalBinaryWrite(message.empty, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.RaidMembers
 */
export const RaidMembers = new RaidMembers$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DynamicWall$Type extends MessageType<DynamicWall> {
    constructor() {
        super("eq.DynamicWall", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "z", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "one_hundred", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<DynamicWall>): DynamicWall {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.y = 0;
        message.x = 0;
        message.z = 0;
        message.oneHundred = 0;
        if (value !== undefined)
            reflectionMergePartial<DynamicWall>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DynamicWall): DynamicWall {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* float y */ 2:
                    message.y = reader.float();
                    break;
                case /* float x */ 3:
                    message.x = reader.float();
                    break;
                case /* float z */ 4:
                    message.z = reader.float();
                    break;
                case /* int32 one_hundred */ 5:
                    message.oneHundred = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DynamicWall, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* float y = 2; */
        if (message.y !== 0)
            writer.tag(2, WireType.Bit32).float(message.y);
        /* float x = 3; */
        if (message.x !== 0)
            writer.tag(3, WireType.Bit32).float(message.x);
        /* float z = 4; */
        if (message.z !== 0)
            writer.tag(4, WireType.Bit32).float(message.z);
        /* int32 one_hundred = 5; */
        if (message.oneHundred !== 0)
            writer.tag(5, WireType.Varint).int32(message.oneHundred);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.DynamicWall
 */
export const DynamicWall = new DynamicWall$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BandolierCreate$Type extends MessageType<BandolierCreate> {
    constructor() {
        super("eq.BandolierCreate", [
            { no: 1, name: "action", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "number", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BandolierCreate>): BandolierCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.action = 0;
        message.number = 0;
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<BandolierCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BandolierCreate): BandolierCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 action */ 1:
                    message.action = reader.int32();
                    break;
                case /* int32 number */ 2:
                    message.number = reader.int32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BandolierCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 action = 1; */
        if (message.action !== 0)
            writer.tag(1, WireType.Varint).int32(message.action);
        /* int32 number = 2; */
        if (message.number !== 0)
            writer.tag(2, WireType.Varint).int32(message.number);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.BandolierCreate
 */
export const BandolierCreate = new BandolierCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BandolierDelete$Type extends MessageType<BandolierDelete> {
    constructor() {
        super("eq.BandolierDelete", [
            { no: 1, name: "action", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "number", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<BandolierDelete>): BandolierDelete {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.action = 0;
        message.number = 0;
        if (value !== undefined)
            reflectionMergePartial<BandolierDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BandolierDelete): BandolierDelete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 action */ 1:
                    message.action = reader.int32();
                    break;
                case /* int32 number */ 2:
                    message.number = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BandolierDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 action = 1; */
        if (message.action !== 0)
            writer.tag(1, WireType.Varint).int32(message.action);
        /* int32 number = 2; */
        if (message.number !== 0)
            writer.tag(2, WireType.Varint).int32(message.number);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.BandolierDelete
 */
export const BandolierDelete = new BandolierDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BandolierSet$Type extends MessageType<BandolierSet> {
    constructor() {
        super("eq.BandolierSet", [
            { no: 1, name: "action", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "number", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<BandolierSet>): BandolierSet {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.action = 0;
        message.number = 0;
        if (value !== undefined)
            reflectionMergePartial<BandolierSet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BandolierSet): BandolierSet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 action */ 1:
                    message.action = reader.int32();
                    break;
                case /* int32 number */ 2:
                    message.number = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BandolierSet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 action = 1; */
        if (message.action !== 0)
            writer.tag(1, WireType.Varint).int32(message.action);
        /* int32 number = 2; */
        if (message.number !== 0)
            writer.tag(2, WireType.Varint).int32(message.number);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.BandolierSet
 */
export const BandolierSet = new BandolierSet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Arrow$Type extends MessageType<Arrow> {
    constructor() {
        super("eq.Arrow", [
            { no: 1, name: "type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "src_y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "src_x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "src_z", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "velocity", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "launch_angle", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "tilt", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "arc", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "source_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "target_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "item_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "model_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Arrow>): Arrow {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.srcY = 0;
        message.srcX = 0;
        message.srcZ = 0;
        message.velocity = 0;
        message.launchAngle = 0;
        message.tilt = 0;
        message.arc = 0;
        message.sourceId = 0;
        message.targetId = 0;
        message.itemId = 0;
        message.modelName = "";
        if (value !== undefined)
            reflectionMergePartial<Arrow>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Arrow): Arrow {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 type */ 1:
                    message.type = reader.int32();
                    break;
                case /* float src_y */ 2:
                    message.srcY = reader.float();
                    break;
                case /* float src_x */ 3:
                    message.srcX = reader.float();
                    break;
                case /* float src_z */ 4:
                    message.srcZ = reader.float();
                    break;
                case /* float velocity */ 5:
                    message.velocity = reader.float();
                    break;
                case /* float launch_angle */ 6:
                    message.launchAngle = reader.float();
                    break;
                case /* float tilt */ 7:
                    message.tilt = reader.float();
                    break;
                case /* float arc */ 8:
                    message.arc = reader.float();
                    break;
                case /* int32 source_id */ 9:
                    message.sourceId = reader.int32();
                    break;
                case /* int32 target_id */ 10:
                    message.targetId = reader.int32();
                    break;
                case /* int32 item_id */ 11:
                    message.itemId = reader.int32();
                    break;
                case /* string model_name */ 12:
                    message.modelName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Arrow, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* float src_y = 2; */
        if (message.srcY !== 0)
            writer.tag(2, WireType.Bit32).float(message.srcY);
        /* float src_x = 3; */
        if (message.srcX !== 0)
            writer.tag(3, WireType.Bit32).float(message.srcX);
        /* float src_z = 4; */
        if (message.srcZ !== 0)
            writer.tag(4, WireType.Bit32).float(message.srcZ);
        /* float velocity = 5; */
        if (message.velocity !== 0)
            writer.tag(5, WireType.Bit32).float(message.velocity);
        /* float launch_angle = 6; */
        if (message.launchAngle !== 0)
            writer.tag(6, WireType.Bit32).float(message.launchAngle);
        /* float tilt = 7; */
        if (message.tilt !== 0)
            writer.tag(7, WireType.Bit32).float(message.tilt);
        /* float arc = 8; */
        if (message.arc !== 0)
            writer.tag(8, WireType.Bit32).float(message.arc);
        /* int32 source_id = 9; */
        if (message.sourceId !== 0)
            writer.tag(9, WireType.Varint).int32(message.sourceId);
        /* int32 target_id = 10; */
        if (message.targetId !== 0)
            writer.tag(10, WireType.Varint).int32(message.targetId);
        /* int32 item_id = 11; */
        if (message.itemId !== 0)
            writer.tag(11, WireType.Varint).int32(message.itemId);
        /* string model_name = 12; */
        if (message.modelName !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.modelName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Arrow
 */
export const Arrow = new Arrow$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Consent$Type extends MessageType<Consent> {
    constructor() {
        super("eq.Consent", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Consent>): Consent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<Consent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Consent): Consent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Consent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Consent
 */
export const Consent = new Consent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventureMerchant$Type extends MessageType<AdventureMerchant> {
    constructor() {
        super("eq.AdventureMerchant", [
            { no: 1, name: "entity_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AdventureMerchant>): AdventureMerchant {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entityId = 0;
        if (value !== undefined)
            reflectionMergePartial<AdventureMerchant>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureMerchant): AdventureMerchant {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 entity_id */ 1:
                    message.entityId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdventureMerchant, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 entity_id = 1; */
        if (message.entityId !== 0)
            writer.tag(1, WireType.Varint).int32(message.entityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.AdventureMerchant
 */
export const AdventureMerchant = new AdventureMerchant$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Save$Type extends MessageType<Save> {
    constructor() {
        super("eq.Save", []);
    }
    create(value?: PartialMessage<Save>): Save {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Save>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Save): Save {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Save, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Save
 */
export const Save = new Save$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GMtoggle$Type extends MessageType<GMtoggle> {
    constructor() {
        super("eq.GMtoggle", [
            { no: 1, name: "toggle", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GMtoggle>): GMtoggle {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.toggle = 0;
        if (value !== undefined)
            reflectionMergePartial<GMtoggle>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GMtoggle): GMtoggle {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 toggle */ 1:
                    message.toggle = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GMtoggle, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 toggle = 1; */
        if (message.toggle !== 0)
            writer.tag(1, WireType.Varint).int32(message.toggle);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.GMtoggle
 */
export const GMtoggle = new GMtoggle$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroupInvite$Type extends MessageType<GroupInvite> {
    constructor() {
        super("eq.GroupInvite", [
            { no: 1, name: "invitee_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "inviter_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GroupInvite>): GroupInvite {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.inviteeName = "";
        message.inviterName = "";
        if (value !== undefined)
            reflectionMergePartial<GroupInvite>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GroupInvite): GroupInvite {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string invitee_name */ 1:
                    message.inviteeName = reader.string();
                    break;
                case /* string inviter_name */ 2:
                    message.inviterName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GroupInvite, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string invitee_name = 1; */
        if (message.inviteeName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.inviteeName);
        /* string inviter_name = 2; */
        if (message.inviterName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.inviterName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.GroupInvite
 */
export const GroupInvite = new GroupInvite$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ColoredText$Type extends MessageType<ColoredText> {
    constructor() {
        super("eq.ColoredText", [
            { no: 1, name: "color", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "msg", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ColoredText>): ColoredText {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.color = 0;
        message.msg = "";
        if (value !== undefined)
            reflectionMergePartial<ColoredText>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ColoredText): ColoredText {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 color */ 1:
                    message.color = reader.int32();
                    break;
                case /* string msg */ 2:
                    message.msg = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ColoredText, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 color = 1; */
        if (message.color !== 0)
            writer.tag(1, WireType.Varint).int32(message.color);
        /* string msg = 2; */
        if (message.msg !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.msg);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.ColoredText
 */
export const ColoredText = new ColoredText$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UseAA$Type extends MessageType<UseAA> {
    constructor() {
        super("eq.UseAA", [
            { no: 1, name: "begin", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "ability", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "end", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<UseAA>): UseAA {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.begin = 0;
        message.ability = 0;
        message.end = 0;
        if (value !== undefined)
            reflectionMergePartial<UseAA>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UseAA): UseAA {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 begin */ 1:
                    message.begin = reader.int32();
                    break;
                case /* int32 ability */ 2:
                    message.ability = reader.int32();
                    break;
                case /* int32 end */ 3:
                    message.end = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UseAA, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 begin = 1; */
        if (message.begin !== 0)
            writer.tag(1, WireType.Varint).int32(message.begin);
        /* int32 ability = 2; */
        if (message.ability !== 0)
            writer.tag(2, WireType.Varint).int32(message.ability);
        /* int32 end = 3; */
        if (message.end !== 0)
            writer.tag(3, WireType.Varint).int32(message.end);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.UseAA
 */
export const UseAA = new UseAA$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AA_Ability$Type extends MessageType<AA_Ability> {
    constructor() {
        super("eq.AA_Ability", [
            { no: 1, name: "skill_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "base_value", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "limit_value", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "slot", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AA_Ability>): AA_Ability {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.skillId = 0;
        message.baseValue = 0;
        message.limitValue = 0;
        message.slot = 0;
        if (value !== undefined)
            reflectionMergePartial<AA_Ability>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AA_Ability): AA_Ability {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 skill_id */ 1:
                    message.skillId = reader.int32();
                    break;
                case /* int32 base_value */ 2:
                    message.baseValue = reader.int32();
                    break;
                case /* int32 limit_value */ 3:
                    message.limitValue = reader.int32();
                    break;
                case /* int32 slot */ 4:
                    message.slot = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AA_Ability, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 skill_id = 1; */
        if (message.skillId !== 0)
            writer.tag(1, WireType.Varint).int32(message.skillId);
        /* int32 base_value = 2; */
        if (message.baseValue !== 0)
            writer.tag(2, WireType.Varint).int32(message.baseValue);
        /* int32 limit_value = 3; */
        if (message.limitValue !== 0)
            writer.tag(3, WireType.Varint).int32(message.limitValue);
        /* int32 slot = 4; */
        if (message.slot !== 0)
            writer.tag(4, WireType.Varint).int32(message.slot);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.AA_Ability
 */
export const AA_Ability = new AA_Ability$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SendAA$Type extends MessageType<SendAA> {
    constructor() {
        super("eq.SendAA", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "hotkey_sid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "hotkey_sid2", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "title_sid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "desc_sid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "class_type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "cost", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "seq", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "current_level", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "prereq_skill", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "prereq_minpoints", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "spellid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "spell_type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "spell_refresh", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 16, name: "classes", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 17, name: "max_level", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 18, name: "last_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 19, name: "next_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 20, name: "cost2", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 21, name: "count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 22, name: "abilities", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AA_Ability }
        ]);
    }
    create(value?: PartialMessage<SendAA>): SendAA {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.hotkeySid = 0;
        message.hotkeySid2 = 0;
        message.titleSid = 0;
        message.descSid = 0;
        message.classType = 0;
        message.cost = 0;
        message.seq = 0;
        message.currentLevel = 0;
        message.prereqSkill = 0;
        message.prereqMinpoints = 0;
        message.type = 0;
        message.spellid = 0;
        message.spellType = 0;
        message.spellRefresh = 0;
        message.classes = 0;
        message.maxLevel = 0;
        message.lastId = 0;
        message.nextId = 0;
        message.cost2 = 0;
        message.count = 0;
        message.abilities = [];
        if (value !== undefined)
            reflectionMergePartial<SendAA>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendAA): SendAA {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* int32 hotkey_sid */ 2:
                    message.hotkeySid = reader.int32();
                    break;
                case /* int32 hotkey_sid2 */ 3:
                    message.hotkeySid2 = reader.int32();
                    break;
                case /* int32 title_sid */ 4:
                    message.titleSid = reader.int32();
                    break;
                case /* int32 desc_sid */ 5:
                    message.descSid = reader.int32();
                    break;
                case /* int32 class_type */ 6:
                    message.classType = reader.int32();
                    break;
                case /* int32 cost */ 7:
                    message.cost = reader.int32();
                    break;
                case /* int32 seq */ 8:
                    message.seq = reader.int32();
                    break;
                case /* int32 current_level */ 9:
                    message.currentLevel = reader.int32();
                    break;
                case /* int32 prereq_skill */ 10:
                    message.prereqSkill = reader.int32();
                    break;
                case /* int32 prereq_minpoints */ 11:
                    message.prereqMinpoints = reader.int32();
                    break;
                case /* int32 type */ 12:
                    message.type = reader.int32();
                    break;
                case /* int32 spellid */ 13:
                    message.spellid = reader.int32();
                    break;
                case /* int32 spell_type */ 14:
                    message.spellType = reader.int32();
                    break;
                case /* int32 spell_refresh */ 15:
                    message.spellRefresh = reader.int32();
                    break;
                case /* int32 classes */ 16:
                    message.classes = reader.int32();
                    break;
                case /* int32 max_level */ 17:
                    message.maxLevel = reader.int32();
                    break;
                case /* int32 last_id */ 18:
                    message.lastId = reader.int32();
                    break;
                case /* int32 next_id */ 19:
                    message.nextId = reader.int32();
                    break;
                case /* int32 cost2 */ 20:
                    message.cost2 = reader.int32();
                    break;
                case /* int32 count */ 21:
                    message.count = reader.int32();
                    break;
                case /* repeated eq.AA_Ability abilities */ 22:
                    message.abilities.push(AA_Ability.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SendAA, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* int32 hotkey_sid = 2; */
        if (message.hotkeySid !== 0)
            writer.tag(2, WireType.Varint).int32(message.hotkeySid);
        /* int32 hotkey_sid2 = 3; */
        if (message.hotkeySid2 !== 0)
            writer.tag(3, WireType.Varint).int32(message.hotkeySid2);
        /* int32 title_sid = 4; */
        if (message.titleSid !== 0)
            writer.tag(4, WireType.Varint).int32(message.titleSid);
        /* int32 desc_sid = 5; */
        if (message.descSid !== 0)
            writer.tag(5, WireType.Varint).int32(message.descSid);
        /* int32 class_type = 6; */
        if (message.classType !== 0)
            writer.tag(6, WireType.Varint).int32(message.classType);
        /* int32 cost = 7; */
        if (message.cost !== 0)
            writer.tag(7, WireType.Varint).int32(message.cost);
        /* int32 seq = 8; */
        if (message.seq !== 0)
            writer.tag(8, WireType.Varint).int32(message.seq);
        /* int32 current_level = 9; */
        if (message.currentLevel !== 0)
            writer.tag(9, WireType.Varint).int32(message.currentLevel);
        /* int32 prereq_skill = 10; */
        if (message.prereqSkill !== 0)
            writer.tag(10, WireType.Varint).int32(message.prereqSkill);
        /* int32 prereq_minpoints = 11; */
        if (message.prereqMinpoints !== 0)
            writer.tag(11, WireType.Varint).int32(message.prereqMinpoints);
        /* int32 type = 12; */
        if (message.type !== 0)
            writer.tag(12, WireType.Varint).int32(message.type);
        /* int32 spellid = 13; */
        if (message.spellid !== 0)
            writer.tag(13, WireType.Varint).int32(message.spellid);
        /* int32 spell_type = 14; */
        if (message.spellType !== 0)
            writer.tag(14, WireType.Varint).int32(message.spellType);
        /* int32 spell_refresh = 15; */
        if (message.spellRefresh !== 0)
            writer.tag(15, WireType.Varint).int32(message.spellRefresh);
        /* int32 classes = 16; */
        if (message.classes !== 0)
            writer.tag(16, WireType.Varint).int32(message.classes);
        /* int32 max_level = 17; */
        if (message.maxLevel !== 0)
            writer.tag(17, WireType.Varint).int32(message.maxLevel);
        /* int32 last_id = 18; */
        if (message.lastId !== 0)
            writer.tag(18, WireType.Varint).int32(message.lastId);
        /* int32 next_id = 19; */
        if (message.nextId !== 0)
            writer.tag(19, WireType.Varint).int32(message.nextId);
        /* int32 cost2 = 20; */
        if (message.cost2 !== 0)
            writer.tag(20, WireType.Varint).int32(message.cost2);
        /* int32 count = 21; */
        if (message.count !== 0)
            writer.tag(21, WireType.Varint).int32(message.count);
        /* repeated eq.AA_Ability abilities = 22; */
        for (let i = 0; i < message.abilities.length; i++)
            AA_Ability.internalBinaryWrite(message.abilities[i], writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.SendAA
 */
export const SendAA = new SendAA$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AA_List$Type extends MessageType<AA_List> {
    constructor() {
        super("eq.AA_List", [
            { no: 1, name: "count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "aa", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SendAA }
        ]);
    }
    create(value?: PartialMessage<AA_List>): AA_List {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.count = 0;
        message.aa = [];
        if (value !== undefined)
            reflectionMergePartial<AA_List>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AA_List): AA_List {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 count */ 1:
                    message.count = reader.int32();
                    break;
                case /* repeated eq.SendAA aa */ 2:
                    message.aa.push(SendAA.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AA_List, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 count = 1; */
        if (message.count !== 0)
            writer.tag(1, WireType.Varint).int32(message.count);
        /* repeated eq.SendAA aa = 2; */
        for (let i = 0; i < message.aa.length; i++)
            SendAA.internalBinaryWrite(message.aa[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.AA_List
 */
export const AA_List = new AA_List$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AA_Action$Type extends MessageType<AA_Action> {
    constructor() {
        super("eq.AA_Action", [
            { no: 1, name: "action", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "ability", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "target_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "exp_value", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AA_Action>): AA_Action {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.action = 0;
        message.ability = 0;
        message.targetId = 0;
        message.expValue = 0;
        if (value !== undefined)
            reflectionMergePartial<AA_Action>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AA_Action): AA_Action {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 action */ 1:
                    message.action = reader.int32();
                    break;
                case /* int32 ability */ 2:
                    message.ability = reader.int32();
                    break;
                case /* int32 target_id */ 3:
                    message.targetId = reader.int32();
                    break;
                case /* int32 exp_value */ 4:
                    message.expValue = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AA_Action, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 action = 1; */
        if (message.action !== 0)
            writer.tag(1, WireType.Varint).int32(message.action);
        /* int32 ability = 2; */
        if (message.ability !== 0)
            writer.tag(2, WireType.Varint).int32(message.ability);
        /* int32 target_id = 3; */
        if (message.targetId !== 0)
            writer.tag(3, WireType.Varint).int32(message.targetId);
        /* int32 exp_value = 4; */
        if (message.expValue !== 0)
            writer.tag(4, WireType.Varint).int32(message.expValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.AA_Action
 */
export const AA_Action = new AA_Action$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AAExpUpdate$Type extends MessageType<AAExpUpdate> {
    constructor() {
        super("eq.AAExpUpdate", [
            { no: 1, name: "aapoints_unspent", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "aaxp_percent", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AAExpUpdate>): AAExpUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.aapointsUnspent = 0;
        message.aaxpPercent = 0;
        if (value !== undefined)
            reflectionMergePartial<AAExpUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AAExpUpdate): AAExpUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 aapoints_unspent */ 1:
                    message.aapointsUnspent = reader.int32();
                    break;
                case /* int32 aaxp_percent */ 2:
                    message.aaxpPercent = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AAExpUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 aapoints_unspent = 1; */
        if (message.aapointsUnspent !== 0)
            writer.tag(1, WireType.Varint).int32(message.aapointsUnspent);
        /* int32 aaxp_percent = 2; */
        if (message.aaxpPercent !== 0)
            writer.tag(2, WireType.Varint).int32(message.aaxpPercent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.AAExpUpdate
 */
export const AAExpUpdate = new AAExpUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AltAdvStats$Type extends MessageType<AltAdvStats> {
    constructor() {
        super("eq.AltAdvStats", [
            { no: 1, name: "experience", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "unspent", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "percentage", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AltAdvStats>): AltAdvStats {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.experience = 0;
        message.unspent = 0;
        message.percentage = 0;
        if (value !== undefined)
            reflectionMergePartial<AltAdvStats>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AltAdvStats): AltAdvStats {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 experience */ 1:
                    message.experience = reader.int32();
                    break;
                case /* int32 unspent */ 2:
                    message.unspent = reader.int32();
                    break;
                case /* int32 percentage */ 3:
                    message.percentage = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AltAdvStats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 experience = 1; */
        if (message.experience !== 0)
            writer.tag(1, WireType.Varint).int32(message.experience);
        /* int32 unspent = 2; */
        if (message.unspent !== 0)
            writer.tag(2, WireType.Varint).int32(message.unspent);
        /* int32 percentage = 3; */
        if (message.percentage !== 0)
            writer.tag(3, WireType.Varint).int32(message.percentage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.AltAdvStats
 */
export const AltAdvStats = new AltAdvStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerAA$Type extends MessageType<PlayerAA> {
    constructor() {
        super("eq.PlayerAA", [
            { no: 1, name: "aa_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AA_Array }
        ]);
    }
    create(value?: PartialMessage<PlayerAA>): PlayerAA {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.aaList = [];
        if (value !== undefined)
            reflectionMergePartial<PlayerAA>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerAA): PlayerAA {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eq.AA_Array aa_list */ 1:
                    message.aaList.push(AA_Array.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerAA, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated eq.AA_Array aa_list = 1; */
        for (let i = 0; i < message.aaList.length; i++)
            AA_Array.internalBinaryWrite(message.aaList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.PlayerAA
 */
export const PlayerAA = new PlayerAA$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AATable$Type extends MessageType<AATable> {
    constructor() {
        super("eq.AATable", [
            { no: 1, name: "aa_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AA_Array }
        ]);
    }
    create(value?: PartialMessage<AATable>): AATable {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.aaList = [];
        if (value !== undefined)
            reflectionMergePartial<AATable>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AATable): AATable {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated eq.AA_Array aa_list */ 1:
                    message.aaList.push(AA_Array.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AATable, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated eq.AA_Array aa_list = 1; */
        for (let i = 0; i < message.aaList.length; i++)
            AA_Array.internalBinaryWrite(message.aaList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.AATable
 */
export const AATable = new AATable$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Weather$Type extends MessageType<Weather> {
    constructor() {
        super("eq.Weather", [
            { no: 1, name: "val", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "mode", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Weather>): Weather {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.val = 0;
        message.type = 0;
        message.mode = 0;
        if (value !== undefined)
            reflectionMergePartial<Weather>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Weather): Weather {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 val */ 1:
                    message.val = reader.int32();
                    break;
                case /* int32 type */ 2:
                    message.type = reader.int32();
                    break;
                case /* int32 mode */ 3:
                    message.mode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Weather, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 val = 1; */
        if (message.val !== 0)
            writer.tag(1, WireType.Varint).int32(message.val);
        /* int32 type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* int32 mode = 3; */
        if (message.mode !== 0)
            writer.tag(3, WireType.Varint).int32(message.mode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Weather
 */
export const Weather = new Weather$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoadSpellSet$Type extends MessageType<LoadSpellSet> {
    constructor() {
        super("eq.LoadSpellSet", [
            { no: 1, name: "spell", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<LoadSpellSet>): LoadSpellSet {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.spell = [];
        if (value !== undefined)
            reflectionMergePartial<LoadSpellSet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoadSpellSet): LoadSpellSet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 spell */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.spell.push(reader.int32());
                    else
                        message.spell.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoadSpellSet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 spell = 1; */
        if (message.spell.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.spell.length; i++)
                writer.int32(message.spell[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.LoadSpellSet
 */
export const LoadSpellSet = new LoadSpellSet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ApplyPoison$Type extends MessageType<ApplyPoison> {
    constructor() {
        super("eq.ApplyPoison", [
            { no: 1, name: "inventory_slot", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "success", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ApplyPoison>): ApplyPoison {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.inventorySlot = 0;
        message.success = 0;
        if (value !== undefined)
            reflectionMergePartial<ApplyPoison>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ApplyPoison): ApplyPoison {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 inventory_slot */ 1:
                    message.inventorySlot = reader.int32();
                    break;
                case /* int32 success */ 2:
                    message.success = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ApplyPoison, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 inventory_slot = 1; */
        if (message.inventorySlot !== 0)
            writer.tag(1, WireType.Varint).int32(message.inventorySlot);
        /* int32 success = 2; */
        if (message.success !== 0)
            writer.tag(2, WireType.Varint).int32(message.success);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.ApplyPoison
 */
export const ApplyPoison = new ApplyPoison$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GuildMemberUpdate$Type extends MessageType<GuildMemberUpdate> {
    constructor() {
        super("eq.GuildMemberUpdate", [
            { no: 1, name: "guild_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "member_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "zone_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "instance_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GuildMemberUpdate>): GuildMemberUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.guildId = 0;
        message.memberName = "";
        message.zoneId = 0;
        message.instanceId = 0;
        if (value !== undefined)
            reflectionMergePartial<GuildMemberUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GuildMemberUpdate): GuildMemberUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 guild_id */ 1:
                    message.guildId = reader.int32();
                    break;
                case /* string member_name */ 2:
                    message.memberName = reader.string();
                    break;
                case /* int32 zone_id */ 3:
                    message.zoneId = reader.int32();
                    break;
                case /* int32 instance_id */ 4:
                    message.instanceId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GuildMemberUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 guild_id = 1; */
        if (message.guildId !== 0)
            writer.tag(1, WireType.Varint).int32(message.guildId);
        /* string member_name = 2; */
        if (message.memberName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.memberName);
        /* int32 zone_id = 3; */
        if (message.zoneId !== 0)
            writer.tag(3, WireType.Varint).int32(message.zoneId);
        /* int32 instance_id = 4; */
        if (message.instanceId !== 0)
            writer.tag(4, WireType.Varint).int32(message.instanceId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.GuildMemberUpdate
 */
export const GuildMemberUpdate = new GuildMemberUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VeteranRewardItem$Type extends MessageType<VeteranRewardItem> {
    constructor() {
        super("eq.VeteranRewardItem", [
            { no: 1, name: "item_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "item_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<VeteranRewardItem>): VeteranRewardItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.itemId = 0;
        message.itemName = "";
        if (value !== undefined)
            reflectionMergePartial<VeteranRewardItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VeteranRewardItem): VeteranRewardItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 item_id */ 1:
                    message.itemId = reader.int32();
                    break;
                case /* string item_name */ 2:
                    message.itemName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VeteranRewardItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 item_id = 1; */
        if (message.itemId !== 0)
            writer.tag(1, WireType.Varint).int32(message.itemId);
        /* string item_name = 2; */
        if (message.itemName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.itemName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.VeteranRewardItem
 */
export const VeteranRewardItem = new VeteranRewardItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VeteranReward$Type extends MessageType<VeteranReward> {
    constructor() {
        super("eq.VeteranReward", [
            { no: 1, name: "claim_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "item", kind: "message", T: () => VeteranRewardItem }
        ]);
    }
    create(value?: PartialMessage<VeteranReward>): VeteranReward {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.claimId = 0;
        if (value !== undefined)
            reflectionMergePartial<VeteranReward>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VeteranReward): VeteranReward {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 claim_id */ 1:
                    message.claimId = reader.int32();
                    break;
                case /* eq.VeteranRewardItem item */ 2:
                    message.item = VeteranRewardItem.internalBinaryRead(reader, reader.uint32(), options, message.item);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VeteranReward, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 claim_id = 1; */
        if (message.claimId !== 0)
            writer.tag(1, WireType.Varint).int32(message.claimId);
        /* eq.VeteranRewardItem item = 2; */
        if (message.item)
            VeteranRewardItem.internalBinaryWrite(message.item, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.VeteranReward
 */
export const VeteranReward = new VeteranReward$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpeditionInvite$Type extends MessageType<ExpeditionInvite> {
    constructor() {
        super("eq.ExpeditionInvite", [
            { no: 1, name: "client_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "inviter_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "expedition_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "swapping", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "swap_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "padding", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "dz_zone_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "dz_instance_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ExpeditionInvite>): ExpeditionInvite {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clientId = 0;
        message.inviterName = "";
        message.expeditionName = "";
        message.swapping = 0;
        message.swapName = "";
        message.padding = [];
        message.dzZoneId = 0;
        message.dzInstanceId = 0;
        if (value !== undefined)
            reflectionMergePartial<ExpeditionInvite>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExpeditionInvite): ExpeditionInvite {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 client_id */ 1:
                    message.clientId = reader.int32();
                    break;
                case /* string inviter_name */ 2:
                    message.inviterName = reader.string();
                    break;
                case /* string expedition_name */ 3:
                    message.expeditionName = reader.string();
                    break;
                case /* int32 swapping */ 4:
                    message.swapping = reader.int32();
                    break;
                case /* string swap_name */ 5:
                    message.swapName = reader.string();
                    break;
                case /* repeated int32 padding */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.padding.push(reader.int32());
                    else
                        message.padding.push(reader.int32());
                    break;
                case /* int32 dz_zone_id */ 7:
                    message.dzZoneId = reader.int32();
                    break;
                case /* int32 dz_instance_id */ 8:
                    message.dzInstanceId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExpeditionInvite, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 client_id = 1; */
        if (message.clientId !== 0)
            writer.tag(1, WireType.Varint).int32(message.clientId);
        /* string inviter_name = 2; */
        if (message.inviterName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.inviterName);
        /* string expedition_name = 3; */
        if (message.expeditionName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.expeditionName);
        /* int32 swapping = 4; */
        if (message.swapping !== 0)
            writer.tag(4, WireType.Varint).int32(message.swapping);
        /* string swap_name = 5; */
        if (message.swapName !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.swapName);
        /* repeated int32 padding = 6; */
        if (message.padding.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.padding.length; i++)
                writer.int32(message.padding[i]);
            writer.join();
        }
        /* int32 dz_zone_id = 7; */
        if (message.dzZoneId !== 0)
            writer.tag(7, WireType.Varint).int32(message.dzZoneId);
        /* int32 dz_instance_id = 8; */
        if (message.dzInstanceId !== 0)
            writer.tag(8, WireType.Varint).int32(message.dzInstanceId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.ExpeditionInvite
 */
export const ExpeditionInvite = new ExpeditionInvite$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpeditionInviteResponse$Type extends MessageType<ExpeditionInviteResponse> {
    constructor() {
        super("eq.ExpeditionInviteResponse", [
            { no: 1, name: "dz_zone_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "dz_instance_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "accepted", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "swapping", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "swap_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ExpeditionInviteResponse>): ExpeditionInviteResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.dzZoneId = 0;
        message.dzInstanceId = 0;
        message.accepted = 0;
        message.swapping = 0;
        message.swapName = "";
        if (value !== undefined)
            reflectionMergePartial<ExpeditionInviteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExpeditionInviteResponse): ExpeditionInviteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 dz_zone_id */ 1:
                    message.dzZoneId = reader.int32();
                    break;
                case /* int32 dz_instance_id */ 2:
                    message.dzInstanceId = reader.int32();
                    break;
                case /* int32 accepted */ 3:
                    message.accepted = reader.int32();
                    break;
                case /* int32 swapping */ 4:
                    message.swapping = reader.int32();
                    break;
                case /* string swap_name */ 5:
                    message.swapName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExpeditionInviteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 dz_zone_id = 1; */
        if (message.dzZoneId !== 0)
            writer.tag(1, WireType.Varint).int32(message.dzZoneId);
        /* int32 dz_instance_id = 2; */
        if (message.dzInstanceId !== 0)
            writer.tag(2, WireType.Varint).int32(message.dzInstanceId);
        /* int32 accepted = 3; */
        if (message.accepted !== 0)
            writer.tag(3, WireType.Varint).int32(message.accepted);
        /* int32 swapping = 4; */
        if (message.swapping !== 0)
            writer.tag(4, WireType.Varint).int32(message.swapping);
        /* string swap_name = 5; */
        if (message.swapName !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.swapName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.ExpeditionInviteResponse
 */
export const ExpeditionInviteResponse = new ExpeditionInviteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DynamicZoneInfo$Type extends MessageType<DynamicZoneInfo> {
    constructor() {
        super("eq.DynamicZoneInfo", [
            { no: 1, name: "client_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "assigned", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "max_players", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "dz_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "leader_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DynamicZoneInfo>): DynamicZoneInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clientId = 0;
        message.assigned = 0;
        message.maxPlayers = 0;
        message.dzName = "";
        message.leaderName = "";
        if (value !== undefined)
            reflectionMergePartial<DynamicZoneInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DynamicZoneInfo): DynamicZoneInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 client_id */ 1:
                    message.clientId = reader.int32();
                    break;
                case /* int32 assigned */ 2:
                    message.assigned = reader.int32();
                    break;
                case /* int32 max_players */ 3:
                    message.maxPlayers = reader.int32();
                    break;
                case /* string dz_name */ 4:
                    message.dzName = reader.string();
                    break;
                case /* string leader_name */ 5:
                    message.leaderName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DynamicZoneInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 client_id = 1; */
        if (message.clientId !== 0)
            writer.tag(1, WireType.Varint).int32(message.clientId);
        /* int32 assigned = 2; */
        if (message.assigned !== 0)
            writer.tag(2, WireType.Varint).int32(message.assigned);
        /* int32 max_players = 3; */
        if (message.maxPlayers !== 0)
            writer.tag(3, WireType.Varint).int32(message.maxPlayers);
        /* string dz_name = 4; */
        if (message.dzName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.dzName);
        /* string leader_name = 5; */
        if (message.leaderName !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.leaderName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.DynamicZoneInfo
 */
export const DynamicZoneInfo = new DynamicZoneInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DynamicZoneMemberEntry$Type extends MessageType<DynamicZoneMemberEntry> {
    constructor() {
        super("eq.DynamicZoneMemberEntry", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "online_status", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<DynamicZoneMemberEntry>): DynamicZoneMemberEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.onlineStatus = 0;
        if (value !== undefined)
            reflectionMergePartial<DynamicZoneMemberEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DynamicZoneMemberEntry): DynamicZoneMemberEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* int32 online_status */ 2:
                    message.onlineStatus = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DynamicZoneMemberEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* int32 online_status = 2; */
        if (message.onlineStatus !== 0)
            writer.tag(2, WireType.Varint).int32(message.onlineStatus);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.DynamicZoneMemberEntry
 */
export const DynamicZoneMemberEntry = new DynamicZoneMemberEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DynamicZoneMemberList$Type extends MessageType<DynamicZoneMemberList> {
    constructor() {
        super("eq.DynamicZoneMemberList", [
            { no: 1, name: "client_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "members", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DynamicZoneMemberEntry }
        ]);
    }
    create(value?: PartialMessage<DynamicZoneMemberList>): DynamicZoneMemberList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clientId = 0;
        message.count = 0;
        message.members = [];
        if (value !== undefined)
            reflectionMergePartial<DynamicZoneMemberList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DynamicZoneMemberList): DynamicZoneMemberList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 client_id */ 1:
                    message.clientId = reader.int32();
                    break;
                case /* int32 count */ 2:
                    message.count = reader.int32();
                    break;
                case /* repeated eq.DynamicZoneMemberEntry members */ 3:
                    message.members.push(DynamicZoneMemberEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DynamicZoneMemberList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 client_id = 1; */
        if (message.clientId !== 0)
            writer.tag(1, WireType.Varint).int32(message.clientId);
        /* int32 count = 2; */
        if (message.count !== 0)
            writer.tag(2, WireType.Varint).int32(message.count);
        /* repeated eq.DynamicZoneMemberEntry members = 3; */
        for (let i = 0; i < message.members.length; i++)
            DynamicZoneMemberEntry.internalBinaryWrite(message.members[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.DynamicZoneMemberList
 */
export const DynamicZoneMemberList = new DynamicZoneMemberList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DynamicZoneMemberListName$Type extends MessageType<DynamicZoneMemberListName> {
    constructor() {
        super("eq.DynamicZoneMemberListName", [
            { no: 1, name: "client_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "add_name", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DynamicZoneMemberListName>): DynamicZoneMemberListName {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clientId = 0;
        message.addName = 0;
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<DynamicZoneMemberListName>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DynamicZoneMemberListName): DynamicZoneMemberListName {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 client_id */ 1:
                    message.clientId = reader.int32();
                    break;
                case /* int32 add_name */ 2:
                    message.addName = reader.int32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DynamicZoneMemberListName, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 client_id = 1; */
        if (message.clientId !== 0)
            writer.tag(1, WireType.Varint).int32(message.clientId);
        /* int32 add_name = 2; */
        if (message.addName !== 0)
            writer.tag(2, WireType.Varint).int32(message.addName);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.DynamicZoneMemberListName
 */
export const DynamicZoneMemberListName = new DynamicZoneMemberListName$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpeditionLockoutTimerEntry$Type extends MessageType<ExpeditionLockoutTimerEntry> {
    constructor() {
        super("eq.ExpeditionLockoutTimerEntry", [
            { no: 1, name: "expedition_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "seconds_remaining", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "event_type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "event_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ExpeditionLockoutTimerEntry>): ExpeditionLockoutTimerEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.expeditionName = "";
        message.secondsRemaining = 0;
        message.eventType = 0;
        message.eventName = "";
        if (value !== undefined)
            reflectionMergePartial<ExpeditionLockoutTimerEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExpeditionLockoutTimerEntry): ExpeditionLockoutTimerEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string expedition_name */ 1:
                    message.expeditionName = reader.string();
                    break;
                case /* int32 seconds_remaining */ 2:
                    message.secondsRemaining = reader.int32();
                    break;
                case /* int32 event_type */ 3:
                    message.eventType = reader.int32();
                    break;
                case /* string event_name */ 4:
                    message.eventName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExpeditionLockoutTimerEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string expedition_name = 1; */
        if (message.expeditionName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.expeditionName);
        /* int32 seconds_remaining = 2; */
        if (message.secondsRemaining !== 0)
            writer.tag(2, WireType.Varint).int32(message.secondsRemaining);
        /* int32 event_type = 3; */
        if (message.eventType !== 0)
            writer.tag(3, WireType.Varint).int32(message.eventType);
        /* string event_name = 4; */
        if (message.eventName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.eventName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.ExpeditionLockoutTimerEntry
 */
export const ExpeditionLockoutTimerEntry = new ExpeditionLockoutTimerEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpeditionLockoutTimers$Type extends MessageType<ExpeditionLockoutTimers> {
    constructor() {
        super("eq.ExpeditionLockoutTimers", [
            { no: 1, name: "client_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "timers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ExpeditionLockoutTimerEntry }
        ]);
    }
    create(value?: PartialMessage<ExpeditionLockoutTimers>): ExpeditionLockoutTimers {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clientId = 0;
        message.count = 0;
        message.timers = [];
        if (value !== undefined)
            reflectionMergePartial<ExpeditionLockoutTimers>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExpeditionLockoutTimers): ExpeditionLockoutTimers {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 client_id */ 1:
                    message.clientId = reader.int32();
                    break;
                case /* int32 count */ 2:
                    message.count = reader.int32();
                    break;
                case /* repeated eq.ExpeditionLockoutTimerEntry timers */ 3:
                    message.timers.push(ExpeditionLockoutTimerEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExpeditionLockoutTimers, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 client_id = 1; */
        if (message.clientId !== 0)
            writer.tag(1, WireType.Varint).int32(message.clientId);
        /* int32 count = 2; */
        if (message.count !== 0)
            writer.tag(2, WireType.Varint).int32(message.count);
        /* repeated eq.ExpeditionLockoutTimerEntry timers = 3; */
        for (let i = 0; i < message.timers.length; i++)
            ExpeditionLockoutTimerEntry.internalBinaryWrite(message.timers[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.ExpeditionLockoutTimers
 */
export const ExpeditionLockoutTimers = new ExpeditionLockoutTimers$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DynamicZoneLeaderName$Type extends MessageType<DynamicZoneLeaderName> {
    constructor() {
        super("eq.DynamicZoneLeaderName", [
            { no: 1, name: "client_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "leader_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DynamicZoneLeaderName>): DynamicZoneLeaderName {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clientId = 0;
        message.leaderName = "";
        if (value !== undefined)
            reflectionMergePartial<DynamicZoneLeaderName>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DynamicZoneLeaderName): DynamicZoneLeaderName {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 client_id */ 1:
                    message.clientId = reader.int32();
                    break;
                case /* string leader_name */ 2:
                    message.leaderName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DynamicZoneLeaderName, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 client_id = 1; */
        if (message.clientId !== 0)
            writer.tag(1, WireType.Varint).int32(message.clientId);
        /* string leader_name = 2; */
        if (message.leaderName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.leaderName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.DynamicZoneLeaderName
 */
export const DynamicZoneLeaderName = new DynamicZoneLeaderName$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpeditionCommand$Type extends MessageType<ExpeditionCommand> {
    constructor() {
        super("eq.ExpeditionCommand", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ExpeditionCommand>): ExpeditionCommand {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<ExpeditionCommand>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExpeditionCommand): ExpeditionCommand {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExpeditionCommand, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.ExpeditionCommand
 */
export const ExpeditionCommand = new ExpeditionCommand$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpeditionCommandSwap$Type extends MessageType<ExpeditionCommandSwap> {
    constructor() {
        super("eq.ExpeditionCommandSwap", [
            { no: 1, name: "add_player_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "rem_player_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ExpeditionCommandSwap>): ExpeditionCommandSwap {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.addPlayerName = "";
        message.remPlayerName = "";
        if (value !== undefined)
            reflectionMergePartial<ExpeditionCommandSwap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExpeditionCommandSwap): ExpeditionCommandSwap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string add_player_name */ 1:
                    message.addPlayerName = reader.string();
                    break;
                case /* string rem_player_name */ 2:
                    message.remPlayerName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExpeditionCommandSwap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string add_player_name = 1; */
        if (message.addPlayerName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.addPlayerName);
        /* string rem_player_name = 2; */
        if (message.remPlayerName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.remPlayerName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.ExpeditionCommandSwap
 */
export const ExpeditionCommandSwap = new ExpeditionCommandSwap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpeditionExpireWarning$Type extends MessageType<ExpeditionExpireWarning> {
    constructor() {
        super("eq.ExpeditionExpireWarning", [
            { no: 1, name: "client_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "minutes_remaining", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ExpeditionExpireWarning>): ExpeditionExpireWarning {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clientId = 0;
        message.minutesRemaining = 0;
        if (value !== undefined)
            reflectionMergePartial<ExpeditionExpireWarning>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExpeditionExpireWarning): ExpeditionExpireWarning {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 client_id */ 1:
                    message.clientId = reader.int32();
                    break;
                case /* int32 minutes_remaining */ 2:
                    message.minutesRemaining = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExpeditionExpireWarning, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 client_id = 1; */
        if (message.clientId !== 0)
            writer.tag(1, WireType.Varint).int32(message.clientId);
        /* int32 minutes_remaining = 2; */
        if (message.minutesRemaining !== 0)
            writer.tag(2, WireType.Varint).int32(message.minutesRemaining);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.ExpeditionExpireWarning
 */
export const ExpeditionExpireWarning = new ExpeditionExpireWarning$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DynamicZoneCompassEntry$Type extends MessageType<DynamicZoneCompassEntry> {
    constructor() {
        super("eq.DynamicZoneCompassEntry", [
            { no: 1, name: "dz_zone_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "dz_instance_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "dz_type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "dz_switch_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "z", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<DynamicZoneCompassEntry>): DynamicZoneCompassEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.dzZoneId = 0;
        message.dzInstanceId = 0;
        message.dzType = 0;
        message.dzSwitchId = 0;
        message.y = 0;
        message.x = 0;
        message.z = 0;
        if (value !== undefined)
            reflectionMergePartial<DynamicZoneCompassEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DynamicZoneCompassEntry): DynamicZoneCompassEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 dz_zone_id */ 1:
                    message.dzZoneId = reader.int32();
                    break;
                case /* int32 dz_instance_id */ 2:
                    message.dzInstanceId = reader.int32();
                    break;
                case /* int32 dz_type */ 3:
                    message.dzType = reader.int32();
                    break;
                case /* int32 dz_switch_id */ 4:
                    message.dzSwitchId = reader.int32();
                    break;
                case /* float y */ 5:
                    message.y = reader.float();
                    break;
                case /* float x */ 6:
                    message.x = reader.float();
                    break;
                case /* float z */ 7:
                    message.z = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DynamicZoneCompassEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 dz_zone_id = 1; */
        if (message.dzZoneId !== 0)
            writer.tag(1, WireType.Varint).int32(message.dzZoneId);
        /* int32 dz_instance_id = 2; */
        if (message.dzInstanceId !== 0)
            writer.tag(2, WireType.Varint).int32(message.dzInstanceId);
        /* int32 dz_type = 3; */
        if (message.dzType !== 0)
            writer.tag(3, WireType.Varint).int32(message.dzType);
        /* int32 dz_switch_id = 4; */
        if (message.dzSwitchId !== 0)
            writer.tag(4, WireType.Varint).int32(message.dzSwitchId);
        /* float y = 5; */
        if (message.y !== 0)
            writer.tag(5, WireType.Bit32).float(message.y);
        /* float x = 6; */
        if (message.x !== 0)
            writer.tag(6, WireType.Bit32).float(message.x);
        /* float z = 7; */
        if (message.z !== 0)
            writer.tag(7, WireType.Bit32).float(message.z);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.DynamicZoneCompassEntry
 */
export const DynamicZoneCompassEntry = new DynamicZoneCompassEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DynamicZoneCompass$Type extends MessageType<DynamicZoneCompass> {
    constructor() {
        super("eq.DynamicZoneCompass", [
            { no: 1, name: "client_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "entries", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DynamicZoneCompassEntry }
        ]);
    }
    create(value?: PartialMessage<DynamicZoneCompass>): DynamicZoneCompass {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clientId = 0;
        message.count = 0;
        message.entries = [];
        if (value !== undefined)
            reflectionMergePartial<DynamicZoneCompass>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DynamicZoneCompass): DynamicZoneCompass {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 client_id */ 1:
                    message.clientId = reader.int32();
                    break;
                case /* int32 count */ 2:
                    message.count = reader.int32();
                    break;
                case /* repeated eq.DynamicZoneCompassEntry entries */ 3:
                    message.entries.push(DynamicZoneCompassEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DynamicZoneCompass, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 client_id = 1; */
        if (message.clientId !== 0)
            writer.tag(1, WireType.Varint).int32(message.clientId);
        /* int32 count = 2; */
        if (message.count !== 0)
            writer.tag(2, WireType.Varint).int32(message.count);
        /* repeated eq.DynamicZoneCompassEntry entries = 3; */
        for (let i = 0; i < message.entries.length; i++)
            DynamicZoneCompassEntry.internalBinaryWrite(message.entries[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.DynamicZoneCompass
 */
export const DynamicZoneCompass = new DynamicZoneCompass$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DynamicZoneChooseZoneEntry$Type extends MessageType<DynamicZoneChooseZoneEntry> {
    constructor() {
        super("eq.DynamicZoneChooseZoneEntry", [
            { no: 1, name: "dz_zone_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "dz_instance_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "dz_type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "leader_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DynamicZoneChooseZoneEntry>): DynamicZoneChooseZoneEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.dzZoneId = 0;
        message.dzInstanceId = 0;
        message.dzType = 0;
        message.description = "";
        message.leaderName = "";
        if (value !== undefined)
            reflectionMergePartial<DynamicZoneChooseZoneEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DynamicZoneChooseZoneEntry): DynamicZoneChooseZoneEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 dz_zone_id */ 1:
                    message.dzZoneId = reader.int32();
                    break;
                case /* int32 dz_instance_id */ 2:
                    message.dzInstanceId = reader.int32();
                    break;
                case /* int32 dz_type */ 3:
                    message.dzType = reader.int32();
                    break;
                case /* string description */ 4:
                    message.description = reader.string();
                    break;
                case /* string leader_name */ 5:
                    message.leaderName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DynamicZoneChooseZoneEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 dz_zone_id = 1; */
        if (message.dzZoneId !== 0)
            writer.tag(1, WireType.Varint).int32(message.dzZoneId);
        /* int32 dz_instance_id = 2; */
        if (message.dzInstanceId !== 0)
            writer.tag(2, WireType.Varint).int32(message.dzInstanceId);
        /* int32 dz_type = 3; */
        if (message.dzType !== 0)
            writer.tag(3, WireType.Varint).int32(message.dzType);
        /* string description = 4; */
        if (message.description !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.description);
        /* string leader_name = 5; */
        if (message.leaderName !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.leaderName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.DynamicZoneChooseZoneEntry
 */
export const DynamicZoneChooseZoneEntry = new DynamicZoneChooseZoneEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DynamicZoneChooseZone$Type extends MessageType<DynamicZoneChooseZone> {
    constructor() {
        super("eq.DynamicZoneChooseZone", [
            { no: 1, name: "client_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "choices", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DynamicZoneChooseZoneEntry }
        ]);
    }
    create(value?: PartialMessage<DynamicZoneChooseZone>): DynamicZoneChooseZone {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clientId = 0;
        message.count = 0;
        message.choices = [];
        if (value !== undefined)
            reflectionMergePartial<DynamicZoneChooseZone>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DynamicZoneChooseZone): DynamicZoneChooseZone {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 client_id */ 1:
                    message.clientId = reader.int32();
                    break;
                case /* int32 count */ 2:
                    message.count = reader.int32();
                    break;
                case /* repeated eq.DynamicZoneChooseZoneEntry choices */ 3:
                    message.choices.push(DynamicZoneChooseZoneEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DynamicZoneChooseZone, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 client_id = 1; */
        if (message.clientId !== 0)
            writer.tag(1, WireType.Varint).int32(message.clientId);
        /* int32 count = 2; */
        if (message.count !== 0)
            writer.tag(2, WireType.Varint).int32(message.count);
        /* repeated eq.DynamicZoneChooseZoneEntry choices = 3; */
        for (let i = 0; i < message.choices.length; i++)
            DynamicZoneChooseZoneEntry.internalBinaryWrite(message.choices[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.DynamicZoneChooseZone
 */
export const DynamicZoneChooseZone = new DynamicZoneChooseZone$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DynamicZoneChooseZoneReply$Type extends MessageType<DynamicZoneChooseZoneReply> {
    constructor() {
        super("eq.DynamicZoneChooseZoneReply", [
            { no: 1, name: "dz_zone_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "dz_instance_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "dz_type", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<DynamicZoneChooseZoneReply>): DynamicZoneChooseZoneReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.dzZoneId = 0;
        message.dzInstanceId = 0;
        message.dzType = 0;
        if (value !== undefined)
            reflectionMergePartial<DynamicZoneChooseZoneReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DynamicZoneChooseZoneReply): DynamicZoneChooseZoneReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 dz_zone_id */ 1:
                    message.dzZoneId = reader.int32();
                    break;
                case /* int32 dz_instance_id */ 2:
                    message.dzInstanceId = reader.int32();
                    break;
                case /* int32 dz_type */ 3:
                    message.dzType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DynamicZoneChooseZoneReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 dz_zone_id = 1; */
        if (message.dzZoneId !== 0)
            writer.tag(1, WireType.Varint).int32(message.dzZoneId);
        /* int32 dz_instance_id = 2; */
        if (message.dzInstanceId !== 0)
            writer.tag(2, WireType.Varint).int32(message.dzInstanceId);
        /* int32 dz_type = 3; */
        if (message.dzType !== 0)
            writer.tag(3, WireType.Varint).int32(message.dzType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.DynamicZoneChooseZoneReply
 */
export const DynamicZoneChooseZoneReply = new DynamicZoneChooseZoneReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LFGuild_SearchPlayer$Type extends MessageType<LFGuild_SearchPlayer> {
    constructor() {
        super("eq.LFGuild_SearchPlayer", [
            { no: 1, name: "command", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "from_level", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "to_level", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "min_aa", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "time_zone", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "classes", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<LFGuild_SearchPlayer>): LFGuild_SearchPlayer {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.command = 0;
        message.fromLevel = 0;
        message.toLevel = 0;
        message.minAa = 0;
        message.timeZone = 0;
        message.classes = 0;
        if (value !== undefined)
            reflectionMergePartial<LFGuild_SearchPlayer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LFGuild_SearchPlayer): LFGuild_SearchPlayer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 command */ 1:
                    message.command = reader.int32();
                    break;
                case /* int32 from_level */ 2:
                    message.fromLevel = reader.int32();
                    break;
                case /* int32 to_level */ 3:
                    message.toLevel = reader.int32();
                    break;
                case /* int32 min_aa */ 4:
                    message.minAa = reader.int32();
                    break;
                case /* int32 time_zone */ 5:
                    message.timeZone = reader.int32();
                    break;
                case /* int32 classes */ 6:
                    message.classes = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LFGuild_SearchPlayer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 command = 1; */
        if (message.command !== 0)
            writer.tag(1, WireType.Varint).int32(message.command);
        /* int32 from_level = 2; */
        if (message.fromLevel !== 0)
            writer.tag(2, WireType.Varint).int32(message.fromLevel);
        /* int32 to_level = 3; */
        if (message.toLevel !== 0)
            writer.tag(3, WireType.Varint).int32(message.toLevel);
        /* int32 min_aa = 4; */
        if (message.minAa !== 0)
            writer.tag(4, WireType.Varint).int32(message.minAa);
        /* int32 time_zone = 5; */
        if (message.timeZone !== 0)
            writer.tag(5, WireType.Varint).int32(message.timeZone);
        /* int32 classes = 6; */
        if (message.classes !== 0)
            writer.tag(6, WireType.Varint).int32(message.classes);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.LFGuild_SearchPlayer
 */
export const LFGuild_SearchPlayer = new LFGuild_SearchPlayer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LFGuild_SearchGuild$Type extends MessageType<LFGuild_SearchGuild> {
    constructor() {
        super("eq.LFGuild_SearchGuild", [
            { no: 1, name: "command", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "level", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "aa_points", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "time_zone", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "char_class", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<LFGuild_SearchGuild>): LFGuild_SearchGuild {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.command = 0;
        message.level = 0;
        message.aaPoints = 0;
        message.timeZone = 0;
        message.charClass = 0;
        if (value !== undefined)
            reflectionMergePartial<LFGuild_SearchGuild>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LFGuild_SearchGuild): LFGuild_SearchGuild {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 command */ 1:
                    message.command = reader.int32();
                    break;
                case /* int32 level */ 2:
                    message.level = reader.int32();
                    break;
                case /* int32 aa_points */ 3:
                    message.aaPoints = reader.int32();
                    break;
                case /* int32 time_zone */ 4:
                    message.timeZone = reader.int32();
                    break;
                case /* int32 char_class */ 5:
                    message.charClass = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LFGuild_SearchGuild, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 command = 1; */
        if (message.command !== 0)
            writer.tag(1, WireType.Varint).int32(message.command);
        /* int32 level = 2; */
        if (message.level !== 0)
            writer.tag(2, WireType.Varint).int32(message.level);
        /* int32 aa_points = 3; */
        if (message.aaPoints !== 0)
            writer.tag(3, WireType.Varint).int32(message.aaPoints);
        /* int32 time_zone = 4; */
        if (message.timeZone !== 0)
            writer.tag(4, WireType.Varint).int32(message.timeZone);
        /* int32 char_class = 5; */
        if (message.charClass !== 0)
            writer.tag(5, WireType.Varint).int32(message.charClass);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.LFGuild_SearchGuild
 */
export const LFGuild_SearchGuild = new LFGuild_SearchGuild$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LFGuild_Playertoggle$Type extends MessageType<LFGuild_Playertoggle> {
    constructor() {
        super("eq.LFGuild_Playertoggle", [
            { no: 1, name: "command", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "comment", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "time_zone", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "toggle", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "expires", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<LFGuild_Playertoggle>): LFGuild_Playertoggle {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.command = 0;
        message.comment = "";
        message.timeZone = 0;
        message.toggle = 0;
        message.expires = 0;
        if (value !== undefined)
            reflectionMergePartial<LFGuild_Playertoggle>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LFGuild_Playertoggle): LFGuild_Playertoggle {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 command */ 1:
                    message.command = reader.int32();
                    break;
                case /* string comment */ 2:
                    message.comment = reader.string();
                    break;
                case /* int32 time_zone */ 3:
                    message.timeZone = reader.int32();
                    break;
                case /* int32 toggle */ 4:
                    message.toggle = reader.int32();
                    break;
                case /* int32 expires */ 5:
                    message.expires = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LFGuild_Playertoggle, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 command = 1; */
        if (message.command !== 0)
            writer.tag(1, WireType.Varint).int32(message.command);
        /* string comment = 2; */
        if (message.comment !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.comment);
        /* int32 time_zone = 3; */
        if (message.timeZone !== 0)
            writer.tag(3, WireType.Varint).int32(message.timeZone);
        /* int32 toggle = 4; */
        if (message.toggle !== 0)
            writer.tag(4, WireType.Varint).int32(message.toggle);
        /* int32 expires = 5; */
        if (message.expires !== 0)
            writer.tag(5, WireType.Varint).int32(message.expires);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.LFGuild_Playertoggle
 */
export const LFGuild_Playertoggle = new LFGuild_Playertoggle$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LFGuild_Guildtoggle$Type extends MessageType<LFGuild_Guildtoggle> {
    constructor() {
        super("eq.LFGuild_Guildtoggle", [
            { no: 1, name: "command", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "comment", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "from_level", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "to_level", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "classes", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "aa_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "time_zone", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "toggle", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "expires", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LFGuild_Guildtoggle>): LFGuild_Guildtoggle {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.command = 0;
        message.comment = "";
        message.fromLevel = 0;
        message.toLevel = 0;
        message.classes = 0;
        message.aaCount = 0;
        message.timeZone = 0;
        message.toggle = 0;
        message.expires = 0;
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<LFGuild_Guildtoggle>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LFGuild_Guildtoggle): LFGuild_Guildtoggle {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 command */ 1:
                    message.command = reader.int32();
                    break;
                case /* string comment */ 2:
                    message.comment = reader.string();
                    break;
                case /* int32 from_level */ 3:
                    message.fromLevel = reader.int32();
                    break;
                case /* int32 to_level */ 4:
                    message.toLevel = reader.int32();
                    break;
                case /* int32 classes */ 5:
                    message.classes = reader.int32();
                    break;
                case /* int32 aa_count */ 6:
                    message.aaCount = reader.int32();
                    break;
                case /* int32 time_zone */ 7:
                    message.timeZone = reader.int32();
                    break;
                case /* int32 toggle */ 8:
                    message.toggle = reader.int32();
                    break;
                case /* int32 expires */ 9:
                    message.expires = reader.int32();
                    break;
                case /* string name */ 10:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LFGuild_Guildtoggle, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 command = 1; */
        if (message.command !== 0)
            writer.tag(1, WireType.Varint).int32(message.command);
        /* string comment = 2; */
        if (message.comment !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.comment);
        /* int32 from_level = 3; */
        if (message.fromLevel !== 0)
            writer.tag(3, WireType.Varint).int32(message.fromLevel);
        /* int32 to_level = 4; */
        if (message.toLevel !== 0)
            writer.tag(4, WireType.Varint).int32(message.toLevel);
        /* int32 classes = 5; */
        if (message.classes !== 0)
            writer.tag(5, WireType.Varint).int32(message.classes);
        /* int32 aa_count = 6; */
        if (message.aaCount !== 0)
            writer.tag(6, WireType.Varint).int32(message.aaCount);
        /* int32 time_zone = 7; */
        if (message.timeZone !== 0)
            writer.tag(7, WireType.Varint).int32(message.timeZone);
        /* int32 toggle = 8; */
        if (message.toggle !== 0)
            writer.tag(8, WireType.Varint).int32(message.toggle);
        /* int32 expires = 9; */
        if (message.expires !== 0)
            writer.tag(9, WireType.Varint).int32(message.expires);
        /* string name = 10; */
        if (message.name !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.LFGuild_Guildtoggle
 */
export const LFGuild_Guildtoggle = new LFGuild_Guildtoggle$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SayLinkBodyFrame$Type extends MessageType<SayLinkBodyFrame> {
    constructor() {
        super("eq.SayLinkBodyFrame", [
            { no: 1, name: "action_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "item_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "augment1", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "augment2", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "augment3", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "augment4", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "augment5", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "is_evolving", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "evolve_group", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "evolve_level", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SayLinkBodyFrame>): SayLinkBodyFrame {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.actionId = "";
        message.itemId = "";
        message.augment1 = "";
        message.augment2 = "";
        message.augment3 = "";
        message.augment4 = "";
        message.augment5 = "";
        message.isEvolving = "";
        message.evolveGroup = "";
        message.evolveLevel = "";
        message.hash = "";
        if (value !== undefined)
            reflectionMergePartial<SayLinkBodyFrame>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SayLinkBodyFrame): SayLinkBodyFrame {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string action_id */ 1:
                    message.actionId = reader.string();
                    break;
                case /* string item_id */ 2:
                    message.itemId = reader.string();
                    break;
                case /* string augment1 */ 3:
                    message.augment1 = reader.string();
                    break;
                case /* string augment2 */ 4:
                    message.augment2 = reader.string();
                    break;
                case /* string augment3 */ 5:
                    message.augment3 = reader.string();
                    break;
                case /* string augment4 */ 6:
                    message.augment4 = reader.string();
                    break;
                case /* string augment5 */ 7:
                    message.augment5 = reader.string();
                    break;
                case /* string is_evolving */ 8:
                    message.isEvolving = reader.string();
                    break;
                case /* string evolve_group */ 9:
                    message.evolveGroup = reader.string();
                    break;
                case /* string evolve_level */ 10:
                    message.evolveLevel = reader.string();
                    break;
                case /* string hash */ 11:
                    message.hash = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SayLinkBodyFrame, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string action_id = 1; */
        if (message.actionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.actionId);
        /* string item_id = 2; */
        if (message.itemId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.itemId);
        /* string augment1 = 3; */
        if (message.augment1 !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.augment1);
        /* string augment2 = 4; */
        if (message.augment2 !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.augment2);
        /* string augment3 = 5; */
        if (message.augment3 !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.augment3);
        /* string augment4 = 6; */
        if (message.augment4 !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.augment4);
        /* string augment5 = 7; */
        if (message.augment5 !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.augment5);
        /* string is_evolving = 8; */
        if (message.isEvolving !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.isEvolving);
        /* string evolve_group = 9; */
        if (message.evolveGroup !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.evolveGroup);
        /* string evolve_level = 10; */
        if (message.evolveLevel !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.evolveLevel);
        /* string hash = 11; */
        if (message.hash !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.hash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.SayLinkBodyFrame
 */
export const SayLinkBodyFrame = new SayLinkBodyFrame$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WebLogin$Type extends MessageType<WebLogin> {
    constructor() {
        super("eq.WebLogin", [
            { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WebLogin>): WebLogin {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.username = "";
        message.password = "";
        if (value !== undefined)
            reflectionMergePartial<WebLogin>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WebLogin): WebLogin {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string username */ 1:
                    message.username = reader.string();
                    break;
                case /* string password */ 2:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WebLogin, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string username = 1; */
        if (message.username !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.username);
        /* string password = 2; */
        if (message.password !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.WebLogin
 */
export const WebLogin = new WebLogin$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WebLoginServerRequest$Type extends MessageType<WebLoginServerRequest> {
    constructor() {
        super("eq.WebLoginServerRequest", [
            { no: 1, name: "sequence", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<WebLoginServerRequest>): WebLoginServerRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sequence = 0;
        if (value !== undefined)
            reflectionMergePartial<WebLoginServerRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WebLoginServerRequest): WebLoginServerRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 sequence */ 1:
                    message.sequence = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WebLoginServerRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 sequence = 1; */
        if (message.sequence !== 0)
            writer.tag(1, WireType.Varint).int32(message.sequence);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.WebLoginServerRequest
 */
export const WebLoginServerRequest = new WebLoginServerRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WebLoginReply$Type extends MessageType<WebLoginReply> {
    constructor() {
        super("eq.WebLoginReply", [
            { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "error_str_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "failed_attempts", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "lsid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "show_player_count", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<WebLoginReply>): WebLoginReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.key = "";
        message.errorStrId = 0;
        message.failedAttempts = 0;
        message.lsid = 0;
        message.success = false;
        message.showPlayerCount = false;
        if (value !== undefined)
            reflectionMergePartial<WebLoginReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WebLoginReply): WebLoginReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string key */ 1:
                    message.key = reader.string();
                    break;
                case /* int32 error_str_id */ 2:
                    message.errorStrId = reader.int32();
                    break;
                case /* int32 failed_attempts */ 3:
                    message.failedAttempts = reader.int32();
                    break;
                case /* int32 lsid */ 4:
                    message.lsid = reader.int32();
                    break;
                case /* bool success */ 5:
                    message.success = reader.bool();
                    break;
                case /* bool show_player_count */ 6:
                    message.showPlayerCount = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WebLoginReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string key = 1; */
        if (message.key !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        /* int32 error_str_id = 2; */
        if (message.errorStrId !== 0)
            writer.tag(2, WireType.Varint).int32(message.errorStrId);
        /* int32 failed_attempts = 3; */
        if (message.failedAttempts !== 0)
            writer.tag(3, WireType.Varint).int32(message.failedAttempts);
        /* int32 lsid = 4; */
        if (message.lsid !== 0)
            writer.tag(4, WireType.Varint).int32(message.lsid);
        /* bool success = 5; */
        if (message.success !== false)
            writer.tag(5, WireType.Varint).bool(message.success);
        /* bool show_player_count = 6; */
        if (message.showPlayerCount !== false)
            writer.tag(6, WireType.Varint).bool(message.showPlayerCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.WebLoginReply
 */
export const WebLoginReply = new WebLoginReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WebLoginWorldServer$Type extends MessageType<WebLoginWorldServer> {
    constructor() {
        super("eq.WebLoginWorldServer", [
            { no: 1, name: "buffer", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ip", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "long_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "country_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "language_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "server_type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "server_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "status", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "players_online", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<WebLoginWorldServer>): WebLoginWorldServer {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.buffer = "";
        message.ip = "";
        message.longName = "";
        message.countryCode = "";
        message.languageCode = "";
        message.serverType = 0;
        message.serverId = 0;
        message.status = 0;
        message.playersOnline = 0;
        if (value !== undefined)
            reflectionMergePartial<WebLoginWorldServer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WebLoginWorldServer): WebLoginWorldServer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string buffer */ 1:
                    message.buffer = reader.string();
                    break;
                case /* string ip */ 2:
                    message.ip = reader.string();
                    break;
                case /* string long_name */ 3:
                    message.longName = reader.string();
                    break;
                case /* string country_code */ 4:
                    message.countryCode = reader.string();
                    break;
                case /* string language_code */ 5:
                    message.languageCode = reader.string();
                    break;
                case /* int32 server_type */ 6:
                    message.serverType = reader.int32();
                    break;
                case /* int32 server_id */ 7:
                    message.serverId = reader.int32();
                    break;
                case /* int32 status */ 8:
                    message.status = reader.int32();
                    break;
                case /* int32 players_online */ 9:
                    message.playersOnline = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WebLoginWorldServer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string buffer = 1; */
        if (message.buffer !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.buffer);
        /* string ip = 2; */
        if (message.ip !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.ip);
        /* string long_name = 3; */
        if (message.longName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.longName);
        /* string country_code = 4; */
        if (message.countryCode !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.countryCode);
        /* string language_code = 5; */
        if (message.languageCode !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.languageCode);
        /* int32 server_type = 6; */
        if (message.serverType !== 0)
            writer.tag(6, WireType.Varint).int32(message.serverType);
        /* int32 server_id = 7; */
        if (message.serverId !== 0)
            writer.tag(7, WireType.Varint).int32(message.serverId);
        /* int32 status = 8; */
        if (message.status !== 0)
            writer.tag(8, WireType.Varint).int32(message.status);
        /* int32 players_online = 9; */
        if (message.playersOnline !== 0)
            writer.tag(9, WireType.Varint).int32(message.playersOnline);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.WebLoginWorldServer
 */
export const WebLoginWorldServer = new WebLoginWorldServer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WebLoginServerResponse$Type extends MessageType<WebLoginServerResponse> {
    constructor() {
        super("eq.WebLoginServerResponse", [
            { no: 1, name: "server_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "servers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => WebLoginWorldServer }
        ]);
    }
    create(value?: PartialMessage<WebLoginServerResponse>): WebLoginServerResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serverCount = 0;
        message.servers = [];
        if (value !== undefined)
            reflectionMergePartial<WebLoginServerResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WebLoginServerResponse): WebLoginServerResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 server_count */ 1:
                    message.serverCount = reader.int32();
                    break;
                case /* repeated eq.WebLoginWorldServer servers */ 2:
                    message.servers.push(WebLoginWorldServer.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WebLoginServerResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 server_count = 1; */
        if (message.serverCount !== 0)
            writer.tag(1, WireType.Varint).int32(message.serverCount);
        /* repeated eq.WebLoginWorldServer servers = 2; */
        for (let i = 0; i < message.servers.length; i++)
            WebLoginWorldServer.internalBinaryWrite(message.servers[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.WebLoginServerResponse
 */
export const WebLoginServerResponse = new WebLoginServerResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WebPlayEverquestRequest$Type extends MessageType<WebPlayEverquestRequest> {
    constructor() {
        super("eq.WebPlayEverquestRequest", [
            { no: 1, name: "server_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<WebPlayEverquestRequest>): WebPlayEverquestRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serverId = 0;
        if (value !== undefined)
            reflectionMergePartial<WebPlayEverquestRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WebPlayEverquestRequest): WebPlayEverquestRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 server_id */ 1:
                    message.serverId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WebPlayEverquestRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 server_id = 1; */
        if (message.serverId !== 0)
            writer.tag(1, WireType.Varint).int32(message.serverId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.WebPlayEverquestRequest
 */
export const WebPlayEverquestRequest = new WebPlayEverquestRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WebPlayEverquestResponse$Type extends MessageType<WebPlayEverquestResponse> {
    constructor() {
        super("eq.WebPlayEverquestResponse", [
            { no: 1, name: "server_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "error_str_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<WebPlayEverquestResponse>): WebPlayEverquestResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serverId = 0;
        message.success = false;
        message.errorStrId = 0;
        if (value !== undefined)
            reflectionMergePartial<WebPlayEverquestResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WebPlayEverquestResponse): WebPlayEverquestResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 server_id */ 1:
                    message.serverId = reader.int32();
                    break;
                case /* bool success */ 2:
                    message.success = reader.bool();
                    break;
                case /* int32 error_str_id */ 3:
                    message.errorStrId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WebPlayEverquestResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 server_id = 1; */
        if (message.serverId !== 0)
            writer.tag(1, WireType.Varint).int32(message.serverId);
        /* bool success = 2; */
        if (message.success !== false)
            writer.tag(2, WireType.Varint).bool(message.success);
        /* int32 error_str_id = 3; */
        if (message.errorStrId !== 0)
            writer.tag(3, WireType.Varint).int32(message.errorStrId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.WebPlayEverquestResponse
 */
export const WebPlayEverquestResponse = new WebPlayEverquestResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WebSession$Type extends MessageType<WebSession> {
    constructor() {
        super("eq.WebSession", [
            { no: 1, name: "remote_addr", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "remote_ip", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "remote_port", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<WebSession>): WebSession {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.remoteAddr = "";
        message.remoteIp = 0;
        message.remotePort = 0;
        if (value !== undefined)
            reflectionMergePartial<WebSession>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WebSession): WebSession {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string remote_addr */ 1:
                    message.remoteAddr = reader.string();
                    break;
                case /* int32 remote_ip */ 2:
                    message.remoteIp = reader.int32();
                    break;
                case /* int32 remote_port */ 3:
                    message.remotePort = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WebSession, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string remote_addr = 1; */
        if (message.remoteAddr !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.remoteAddr);
        /* int32 remote_ip = 2; */
        if (message.remoteIp !== 0)
            writer.tag(2, WireType.Varint).int32(message.remoteIp);
        /* int32 remote_port = 3; */
        if (message.remotePort !== 0)
            writer.tag(3, WireType.Varint).int32(message.remotePort);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.WebSession
 */
export const WebSession = new WebSession$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Zero$Type extends MessageType<Zero> {
    constructor() {
        super("eq.Zero", []);
    }
    create(value?: PartialMessage<Zero>): Zero {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Zero>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Zero): Zero {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Zero, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Zero
 */
export const Zero = new Zero$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Int$Type extends MessageType<Int> {
    constructor() {
        super("eq.Int", [
            { no: 1, name: "value", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Int>): Int {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = 0;
        if (value !== undefined)
            reflectionMergePartial<Int>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Int): Int {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 value */ 1:
                    message.value = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Int, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 value = 1; */
        if (message.value !== 0)
            writer.tag(1, WireType.Varint).int32(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Int
 */
export const Int = new Int$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Bool$Type extends MessageType<Bool> {
    constructor() {
        super("eq.Bool", [
            { no: 1, name: "value", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Bool>): Bool {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = false;
        if (value !== undefined)
            reflectionMergePartial<Bool>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Bool): Bool {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool value */ 1:
                    message.value = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Bool, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool value = 1; */
        if (message.value !== false)
            writer.tag(1, WireType.Varint).bool(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.Bool
 */
export const Bool = new Bool$Type();
// @generated message type with reflection information, may provide speed optimized methods
class String$$Type extends MessageType<String$> {
    constructor() {
        super("eq.String", [
            { no: 1, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<String$>): String$ {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = "";
        if (value !== undefined)
            reflectionMergePartial<String$>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: String$): String$ {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string value */ 1:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: String$, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string value = 1; */
        if (message.value !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eq.String
 */
export const String$ = new String$$Type();
